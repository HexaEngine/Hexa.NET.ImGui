// ------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
// ------------------------------------------------------------------------------

using System;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;
using HexaGen.Runtime;
using System.Numerics;
using Hexa.NET.ImGui;

namespace Hexa.NET.ImPlot
{
	public unsafe partial class ImPlot
	{

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void CalculateBins(in uint values, int count, ImPlotBin meth, ImPlotRange range, int* binsOut, ref double widthOut)
		{
			fixed (uint* pvalues = &values)
			{
				fixed (double* pwidthOut = &widthOut)
				{
					CalculateBinsNative((uint*)pvalues, count, meth, range, binsOut, (double*)pwidthOut);
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void CalculateBins(uint* values, int count, ImPlotBin meth, ImPlotRange range, ref int binsOut, ref double widthOut)
		{
			fixed (int* pbinsOut = &binsOut)
			{
				fixed (double* pwidthOut = &widthOut)
				{
					CalculateBinsNative(values, count, meth, range, (int*)pbinsOut, (double*)pwidthOut);
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void CalculateBins(in uint values, int count, ImPlotBin meth, ImPlotRange range, ref int binsOut, ref double widthOut)
		{
			fixed (uint* pvalues = &values)
			{
				fixed (int* pbinsOut = &binsOut)
				{
					fixed (double* pwidthOut = &widthOut)
					{
						CalculateBinsNative((uint*)pvalues, count, meth, range, (int*)pbinsOut, (double*)pwidthOut);
					}
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void CalculateBinsNative(long* values, int count, ImPlotBin meth, ImPlotRange range, int* binsOut, double* widthOut)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<long*, int, ImPlotBin, ImPlotRange, int*, double*, void>)funcTable[707])(values, count, meth, range, binsOut, widthOut);
			#else
			((delegate* unmanaged[Cdecl]<nint, int, ImPlotBin, ImPlotRange, nint, nint, void>)funcTable[707])((nint)values, count, meth, range, (nint)binsOut, (nint)widthOut);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void CalculateBins(long* values, int count, ImPlotBin meth, ImPlotRange range, int* binsOut, double* widthOut)
		{
			CalculateBinsNative(values, count, meth, range, binsOut, widthOut);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void CalculateBins(in long values, int count, ImPlotBin meth, ImPlotRange range, int* binsOut, double* widthOut)
		{
			fixed (long* pvalues = &values)
			{
				CalculateBinsNative((long*)pvalues, count, meth, range, binsOut, widthOut);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void CalculateBins(long* values, int count, ImPlotBin meth, ImPlotRange range, ref int binsOut, double* widthOut)
		{
			fixed (int* pbinsOut = &binsOut)
			{
				CalculateBinsNative(values, count, meth, range, (int*)pbinsOut, widthOut);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void CalculateBins(in long values, int count, ImPlotBin meth, ImPlotRange range, ref int binsOut, double* widthOut)
		{
			fixed (long* pvalues = &values)
			{
				fixed (int* pbinsOut = &binsOut)
				{
					CalculateBinsNative((long*)pvalues, count, meth, range, (int*)pbinsOut, widthOut);
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void CalculateBins(long* values, int count, ImPlotBin meth, ImPlotRange range, int* binsOut, ref double widthOut)
		{
			fixed (double* pwidthOut = &widthOut)
			{
				CalculateBinsNative(values, count, meth, range, binsOut, (double*)pwidthOut);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void CalculateBins(in long values, int count, ImPlotBin meth, ImPlotRange range, int* binsOut, ref double widthOut)
		{
			fixed (long* pvalues = &values)
			{
				fixed (double* pwidthOut = &widthOut)
				{
					CalculateBinsNative((long*)pvalues, count, meth, range, binsOut, (double*)pwidthOut);
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void CalculateBins(long* values, int count, ImPlotBin meth, ImPlotRange range, ref int binsOut, ref double widthOut)
		{
			fixed (int* pbinsOut = &binsOut)
			{
				fixed (double* pwidthOut = &widthOut)
				{
					CalculateBinsNative(values, count, meth, range, (int*)pbinsOut, (double*)pwidthOut);
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void CalculateBins(in long values, int count, ImPlotBin meth, ImPlotRange range, ref int binsOut, ref double widthOut)
		{
			fixed (long* pvalues = &values)
			{
				fixed (int* pbinsOut = &binsOut)
				{
					fixed (double* pwidthOut = &widthOut)
					{
						CalculateBinsNative((long*)pvalues, count, meth, range, (int*)pbinsOut, (double*)pwidthOut);
					}
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void CalculateBinsNative(ulong* values, int count, ImPlotBin meth, ImPlotRange range, int* binsOut, double* widthOut)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<ulong*, int, ImPlotBin, ImPlotRange, int*, double*, void>)funcTable[708])(values, count, meth, range, binsOut, widthOut);
			#else
			((delegate* unmanaged[Cdecl]<nint, int, ImPlotBin, ImPlotRange, nint, nint, void>)funcTable[708])((nint)values, count, meth, range, (nint)binsOut, (nint)widthOut);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void CalculateBins(ulong* values, int count, ImPlotBin meth, ImPlotRange range, int* binsOut, double* widthOut)
		{
			CalculateBinsNative(values, count, meth, range, binsOut, widthOut);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void CalculateBins(in ulong values, int count, ImPlotBin meth, ImPlotRange range, int* binsOut, double* widthOut)
		{
			fixed (ulong* pvalues = &values)
			{
				CalculateBinsNative((ulong*)pvalues, count, meth, range, binsOut, widthOut);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void CalculateBins(ulong* values, int count, ImPlotBin meth, ImPlotRange range, ref int binsOut, double* widthOut)
		{
			fixed (int* pbinsOut = &binsOut)
			{
				CalculateBinsNative(values, count, meth, range, (int*)pbinsOut, widthOut);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void CalculateBins(in ulong values, int count, ImPlotBin meth, ImPlotRange range, ref int binsOut, double* widthOut)
		{
			fixed (ulong* pvalues = &values)
			{
				fixed (int* pbinsOut = &binsOut)
				{
					CalculateBinsNative((ulong*)pvalues, count, meth, range, (int*)pbinsOut, widthOut);
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void CalculateBins(ulong* values, int count, ImPlotBin meth, ImPlotRange range, int* binsOut, ref double widthOut)
		{
			fixed (double* pwidthOut = &widthOut)
			{
				CalculateBinsNative(values, count, meth, range, binsOut, (double*)pwidthOut);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void CalculateBins(in ulong values, int count, ImPlotBin meth, ImPlotRange range, int* binsOut, ref double widthOut)
		{
			fixed (ulong* pvalues = &values)
			{
				fixed (double* pwidthOut = &widthOut)
				{
					CalculateBinsNative((ulong*)pvalues, count, meth, range, binsOut, (double*)pwidthOut);
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void CalculateBins(ulong* values, int count, ImPlotBin meth, ImPlotRange range, ref int binsOut, ref double widthOut)
		{
			fixed (int* pbinsOut = &binsOut)
			{
				fixed (double* pwidthOut = &widthOut)
				{
					CalculateBinsNative(values, count, meth, range, (int*)pbinsOut, (double*)pwidthOut);
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void CalculateBins(in ulong values, int count, ImPlotBin meth, ImPlotRange range, ref int binsOut, ref double widthOut)
		{
			fixed (ulong* pvalues = &values)
			{
				fixed (int* pbinsOut = &binsOut)
				{
					fixed (double* pwidthOut = &widthOut)
					{
						CalculateBinsNative((ulong*)pvalues, count, meth, range, (int*)pbinsOut, (double*)pwidthOut);
					}
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte IsLeapYearNative(int year)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<int, byte>)funcTable[709])(year);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<int, byte>)funcTable[709])(year);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool IsLeapYear(int year)
		{
			byte ret = IsLeapYearNative(year);
			return ret != 0;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int GetDaysInMonthNative(int year, int month)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<int, int, int>)funcTable[710])(year, month);
			#else
			return (int)((delegate* unmanaged[Cdecl]<int, int, int>)funcTable[710])(year, month);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static int GetDaysInMonth(int year, int month)
		{
			int ret = GetDaysInMonthNative(year, month);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void MkGmtTimeNative(ImPlotTime* pOut, Tm* ptm)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<ImPlotTime*, Tm*, void>)funcTable[711])(pOut, ptm);
			#else
			((delegate* unmanaged[Cdecl]<nint, nint, void>)funcTable[711])((nint)pOut, (nint)ptm);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static ImPlotTime MkGmtTime(Tm* ptm)
		{
			ImPlotTime ret;
			MkGmtTimeNative(&ret, ptm);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void MkGmtTime(ImPlotTimePtr pOut, Tm* ptm)
		{
			MkGmtTimeNative((ImPlotTime*)pOut, ptm);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void MkGmtTime(ref ImPlotTime pOut, Tm* ptm)
		{
			fixed (ImPlotTime* ppOut = &pOut)
			{
				MkGmtTimeNative((ImPlotTime*)ppOut, ptm);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static ImPlotTime MkGmtTime(ref Tm ptm)
		{
			fixed (Tm* pptm = &ptm)
			{
				ImPlotTime ret;
				MkGmtTimeNative(&ret, (Tm*)pptm);
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void MkGmtTime(ImPlotTimePtr pOut, ref Tm ptm)
		{
			fixed (Tm* pptm = &ptm)
			{
				MkGmtTimeNative((ImPlotTime*)pOut, (Tm*)pptm);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void MkGmtTime(ref ImPlotTime pOut, ref Tm ptm)
		{
			fixed (ImPlotTime* ppOut = &pOut)
			{
				fixed (Tm* pptm = &ptm)
				{
					MkGmtTimeNative((ImPlotTime*)ppOut, (Tm*)pptm);
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static Tm* GetGmtTimeNative(ImPlotTime t, Tm* ptm)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<ImPlotTime, Tm*, Tm*>)funcTable[712])(t, ptm);
			#else
			return (Tm*)((delegate* unmanaged[Cdecl]<ImPlotTime, nint, nint>)funcTable[712])(t, (nint)ptm);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static Tm* GetGmtTime(ImPlotTime t, Tm* ptm)
		{
			Tm* ret = GetGmtTimeNative(t, ptm);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static Tm* GetGmtTime(ImPlotTime t, ref Tm ptm)
		{
			fixed (Tm* pptm = &ptm)
			{
				Tm* ret = GetGmtTimeNative(t, (Tm*)pptm);
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void MkLocTimeNative(ImPlotTime* pOut, Tm* ptm)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<ImPlotTime*, Tm*, void>)funcTable[713])(pOut, ptm);
			#else
			((delegate* unmanaged[Cdecl]<nint, nint, void>)funcTable[713])((nint)pOut, (nint)ptm);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static ImPlotTime MkLocTime(Tm* ptm)
		{
			ImPlotTime ret;
			MkLocTimeNative(&ret, ptm);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void MkLocTime(ImPlotTimePtr pOut, Tm* ptm)
		{
			MkLocTimeNative((ImPlotTime*)pOut, ptm);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void MkLocTime(ref ImPlotTime pOut, Tm* ptm)
		{
			fixed (ImPlotTime* ppOut = &pOut)
			{
				MkLocTimeNative((ImPlotTime*)ppOut, ptm);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static ImPlotTime MkLocTime(ref Tm ptm)
		{
			fixed (Tm* pptm = &ptm)
			{
				ImPlotTime ret;
				MkLocTimeNative(&ret, (Tm*)pptm);
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void MkLocTime(ImPlotTimePtr pOut, ref Tm ptm)
		{
			fixed (Tm* pptm = &ptm)
			{
				MkLocTimeNative((ImPlotTime*)pOut, (Tm*)pptm);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void MkLocTime(ref ImPlotTime pOut, ref Tm ptm)
		{
			fixed (ImPlotTime* ppOut = &pOut)
			{
				fixed (Tm* pptm = &ptm)
				{
					MkLocTimeNative((ImPlotTime*)ppOut, (Tm*)pptm);
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static Tm* GetLocTimeNative(ImPlotTime t, Tm* ptm)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<ImPlotTime, Tm*, Tm*>)funcTable[714])(t, ptm);
			#else
			return (Tm*)((delegate* unmanaged[Cdecl]<ImPlotTime, nint, nint>)funcTable[714])(t, (nint)ptm);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static Tm* GetLocTime(ImPlotTime t, Tm* ptm)
		{
			Tm* ret = GetLocTimeNative(t, ptm);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static Tm* GetLocTime(ImPlotTime t, ref Tm ptm)
		{
			fixed (Tm* pptm = &ptm)
			{
				Tm* ret = GetLocTimeNative(t, (Tm*)pptm);
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void MkTimeNative(ImPlotTime* pOut, Tm* ptm)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<ImPlotTime*, Tm*, void>)funcTable[715])(pOut, ptm);
			#else
			((delegate* unmanaged[Cdecl]<nint, nint, void>)funcTable[715])((nint)pOut, (nint)ptm);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static ImPlotTime MkTime(Tm* ptm)
		{
			ImPlotTime ret;
			MkTimeNative(&ret, ptm);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void MkTime(ImPlotTimePtr pOut, Tm* ptm)
		{
			MkTimeNative((ImPlotTime*)pOut, ptm);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void MkTime(ref ImPlotTime pOut, Tm* ptm)
		{
			fixed (ImPlotTime* ppOut = &pOut)
			{
				MkTimeNative((ImPlotTime*)ppOut, ptm);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static ImPlotTime MkTime(ref Tm ptm)
		{
			fixed (Tm* pptm = &ptm)
			{
				ImPlotTime ret;
				MkTimeNative(&ret, (Tm*)pptm);
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void MkTime(ImPlotTimePtr pOut, ref Tm ptm)
		{
			fixed (Tm* pptm = &ptm)
			{
				MkTimeNative((ImPlotTime*)pOut, (Tm*)pptm);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void MkTime(ref ImPlotTime pOut, ref Tm ptm)
		{
			fixed (ImPlotTime* ppOut = &pOut)
			{
				fixed (Tm* pptm = &ptm)
				{
					MkTimeNative((ImPlotTime*)ppOut, (Tm*)pptm);
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static Tm* GetTimeNative(ImPlotTime t, Tm* ptm)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<ImPlotTime, Tm*, Tm*>)funcTable[716])(t, ptm);
			#else
			return (Tm*)((delegate* unmanaged[Cdecl]<ImPlotTime, nint, nint>)funcTable[716])(t, (nint)ptm);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static Tm* GetTime(ImPlotTime t, Tm* ptm)
		{
			Tm* ret = GetTimeNative(t, ptm);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static Tm* GetTime(ImPlotTime t, ref Tm ptm)
		{
			fixed (Tm* pptm = &ptm)
			{
				Tm* ret = GetTimeNative(t, (Tm*)pptm);
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void MakeTimeNative(ImPlotTime* pOut, int year, int month, int day, int hour, int min, int sec, int us)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<ImPlotTime*, int, int, int, int, int, int, int, void>)funcTable[717])(pOut, year, month, day, hour, min, sec, us);
			#else
			((delegate* unmanaged[Cdecl]<nint, int, int, int, int, int, int, int, void>)funcTable[717])((nint)pOut, year, month, day, hour, min, sec, us);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static ImPlotTime MakeTime(int year)
		{
			ImPlotTime ret;
			MakeTimeNative(&ret, year, (int)(0), (int)(1), (int)(0), (int)(0), (int)(0), (int)(0));
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static ImPlotTime MakeTime(int year, int month)
		{
			ImPlotTime ret;
			MakeTimeNative(&ret, year, month, (int)(1), (int)(0), (int)(0), (int)(0), (int)(0));
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void MakeTime(ImPlotTimePtr pOut, int year)
		{
			MakeTimeNative((ImPlotTime*)pOut, year, (int)(0), (int)(1), (int)(0), (int)(0), (int)(0), (int)(0));
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static ImPlotTime MakeTime(int year, int month, int day)
		{
			ImPlotTime ret;
			MakeTimeNative(&ret, year, month, day, (int)(0), (int)(0), (int)(0), (int)(0));
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void MakeTime(ImPlotTimePtr pOut, int year, int month)
		{
			MakeTimeNative((ImPlotTime*)pOut, year, month, (int)(1), (int)(0), (int)(0), (int)(0), (int)(0));
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static ImPlotTime MakeTime(int year, int month, int day, int hour)
		{
			ImPlotTime ret;
			MakeTimeNative(&ret, year, month, day, hour, (int)(0), (int)(0), (int)(0));
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void MakeTime(ImPlotTimePtr pOut, int year, int month, int day)
		{
			MakeTimeNative((ImPlotTime*)pOut, year, month, day, (int)(0), (int)(0), (int)(0), (int)(0));
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static ImPlotTime MakeTime(int year, int month, int day, int hour, int min)
		{
			ImPlotTime ret;
			MakeTimeNative(&ret, year, month, day, hour, min, (int)(0), (int)(0));
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void MakeTime(ImPlotTimePtr pOut, int year, int month, int day, int hour)
		{
			MakeTimeNative((ImPlotTime*)pOut, year, month, day, hour, (int)(0), (int)(0), (int)(0));
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static ImPlotTime MakeTime(int year, int month, int day, int hour, int min, int sec)
		{
			ImPlotTime ret;
			MakeTimeNative(&ret, year, month, day, hour, min, sec, (int)(0));
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void MakeTime(ImPlotTimePtr pOut, int year, int month, int day, int hour, int min)
		{
			MakeTimeNative((ImPlotTime*)pOut, year, month, day, hour, min, (int)(0), (int)(0));
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static ImPlotTime MakeTime(int year, int month, int day, int hour, int min, int sec, int us)
		{
			ImPlotTime ret;
			MakeTimeNative(&ret, year, month, day, hour, min, sec, us);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void MakeTime(ImPlotTimePtr pOut, int year, int month, int day, int hour, int min, int sec, int us)
		{
			MakeTimeNative((ImPlotTime*)pOut, year, month, day, hour, min, sec, us);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void MakeTime(ImPlotTimePtr pOut, int year, int month, int day, int hour, int min, int sec)
		{
			MakeTimeNative((ImPlotTime*)pOut, year, month, day, hour, min, sec, (int)(0));
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void MakeTime(ref ImPlotTime pOut, int year, int month, int day, int hour, int min, int sec, int us)
		{
			fixed (ImPlotTime* ppOut = &pOut)
			{
				MakeTimeNative((ImPlotTime*)ppOut, year, month, day, hour, min, sec, us);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void MakeTime(ref ImPlotTime pOut, int year, int month, int day, int hour, int min, int sec)
		{
			fixed (ImPlotTime* ppOut = &pOut)
			{
				MakeTimeNative((ImPlotTime*)ppOut, year, month, day, hour, min, sec, (int)(0));
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void MakeTime(ref ImPlotTime pOut, int year, int month, int day, int hour, int min)
		{
			fixed (ImPlotTime* ppOut = &pOut)
			{
				MakeTimeNative((ImPlotTime*)ppOut, year, month, day, hour, min, (int)(0), (int)(0));
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void MakeTime(ref ImPlotTime pOut, int year, int month, int day, int hour)
		{
			fixed (ImPlotTime* ppOut = &pOut)
			{
				MakeTimeNative((ImPlotTime*)ppOut, year, month, day, hour, (int)(0), (int)(0), (int)(0));
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void MakeTime(ref ImPlotTime pOut, int year, int month, int day)
		{
			fixed (ImPlotTime* ppOut = &pOut)
			{
				MakeTimeNative((ImPlotTime*)ppOut, year, month, day, (int)(0), (int)(0), (int)(0), (int)(0));
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void MakeTime(ref ImPlotTime pOut, int year, int month)
		{
			fixed (ImPlotTime* ppOut = &pOut)
			{
				MakeTimeNative((ImPlotTime*)ppOut, year, month, (int)(1), (int)(0), (int)(0), (int)(0), (int)(0));
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void MakeTime(ref ImPlotTime pOut, int year)
		{
			fixed (ImPlotTime* ppOut = &pOut)
			{
				MakeTimeNative((ImPlotTime*)ppOut, year, (int)(0), (int)(1), (int)(0), (int)(0), (int)(0), (int)(0));
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int GetYearNative(ImPlotTime t)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<ImPlotTime, int>)funcTable[718])(t);
			#else
			return (int)((delegate* unmanaged[Cdecl]<ImPlotTime, int>)funcTable[718])(t);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static int GetYear(ImPlotTime t)
		{
			int ret = GetYearNative(t);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int GetMonthNative(ImPlotTime t)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<ImPlotTime, int>)funcTable[719])(t);
			#else
			return (int)((delegate* unmanaged[Cdecl]<ImPlotTime, int>)funcTable[719])(t);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static int GetMonth(ImPlotTime t)
		{
			int ret = GetMonthNative(t);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void AddTimeNative(ImPlotTime* pOut, ImPlotTime t, ImPlotTimeUnit unit, int count)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<ImPlotTime*, ImPlotTime, ImPlotTimeUnit, int, void>)funcTable[720])(pOut, t, unit, count);
			#else
			((delegate* unmanaged[Cdecl]<nint, ImPlotTime, ImPlotTimeUnit, int, void>)funcTable[720])((nint)pOut, t, unit, count);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static ImPlotTime AddTime(ImPlotTime t, ImPlotTimeUnit unit, int count)
		{
			ImPlotTime ret;
			AddTimeNative(&ret, t, unit, count);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void AddTime(ImPlotTimePtr pOut, ImPlotTime t, ImPlotTimeUnit unit, int count)
		{
			AddTimeNative((ImPlotTime*)pOut, t, unit, count);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void AddTime(ref ImPlotTime pOut, ImPlotTime t, ImPlotTimeUnit unit, int count)
		{
			fixed (ImPlotTime* ppOut = &pOut)
			{
				AddTimeNative((ImPlotTime*)ppOut, t, unit, count);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void FloorTimeNative(ImPlotTime* pOut, ImPlotTime t, ImPlotTimeUnit unit)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<ImPlotTime*, ImPlotTime, ImPlotTimeUnit, void>)funcTable[721])(pOut, t, unit);
			#else
			((delegate* unmanaged[Cdecl]<nint, ImPlotTime, ImPlotTimeUnit, void>)funcTable[721])((nint)pOut, t, unit);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static ImPlotTime FloorTime(ImPlotTime t, ImPlotTimeUnit unit)
		{
			ImPlotTime ret;
			FloorTimeNative(&ret, t, unit);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void FloorTime(ImPlotTimePtr pOut, ImPlotTime t, ImPlotTimeUnit unit)
		{
			FloorTimeNative((ImPlotTime*)pOut, t, unit);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void FloorTime(ref ImPlotTime pOut, ImPlotTime t, ImPlotTimeUnit unit)
		{
			fixed (ImPlotTime* ppOut = &pOut)
			{
				FloorTimeNative((ImPlotTime*)ppOut, t, unit);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void CeilTimeNative(ImPlotTime* pOut, ImPlotTime t, ImPlotTimeUnit unit)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<ImPlotTime*, ImPlotTime, ImPlotTimeUnit, void>)funcTable[722])(pOut, t, unit);
			#else
			((delegate* unmanaged[Cdecl]<nint, ImPlotTime, ImPlotTimeUnit, void>)funcTable[722])((nint)pOut, t, unit);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static ImPlotTime CeilTime(ImPlotTime t, ImPlotTimeUnit unit)
		{
			ImPlotTime ret;
			CeilTimeNative(&ret, t, unit);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void CeilTime(ImPlotTimePtr pOut, ImPlotTime t, ImPlotTimeUnit unit)
		{
			CeilTimeNative((ImPlotTime*)pOut, t, unit);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void CeilTime(ref ImPlotTime pOut, ImPlotTime t, ImPlotTimeUnit unit)
		{
			fixed (ImPlotTime* ppOut = &pOut)
			{
				CeilTimeNative((ImPlotTime*)ppOut, t, unit);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void RoundTimeNative(ImPlotTime* pOut, ImPlotTime t, ImPlotTimeUnit unit)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<ImPlotTime*, ImPlotTime, ImPlotTimeUnit, void>)funcTable[723])(pOut, t, unit);
			#else
			((delegate* unmanaged[Cdecl]<nint, ImPlotTime, ImPlotTimeUnit, void>)funcTable[723])((nint)pOut, t, unit);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static ImPlotTime RoundTime(ImPlotTime t, ImPlotTimeUnit unit)
		{
			ImPlotTime ret;
			RoundTimeNative(&ret, t, unit);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void RoundTime(ImPlotTimePtr pOut, ImPlotTime t, ImPlotTimeUnit unit)
		{
			RoundTimeNative((ImPlotTime*)pOut, t, unit);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void RoundTime(ref ImPlotTime pOut, ImPlotTime t, ImPlotTimeUnit unit)
		{
			fixed (ImPlotTime* ppOut = &pOut)
			{
				RoundTimeNative((ImPlotTime*)ppOut, t, unit);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void CombineDateTimeNative(ImPlotTime* pOut, ImPlotTime datePart, ImPlotTime timePart)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<ImPlotTime*, ImPlotTime, ImPlotTime, void>)funcTable[724])(pOut, datePart, timePart);
			#else
			((delegate* unmanaged[Cdecl]<nint, ImPlotTime, ImPlotTime, void>)funcTable[724])((nint)pOut, datePart, timePart);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static ImPlotTime CombineDateTime(ImPlotTime datePart, ImPlotTime timePart)
		{
			ImPlotTime ret;
			CombineDateTimeNative(&ret, datePart, timePart);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void CombineDateTime(ImPlotTimePtr pOut, ImPlotTime datePart, ImPlotTime timePart)
		{
			CombineDateTimeNative((ImPlotTime*)pOut, datePart, timePart);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void CombineDateTime(ref ImPlotTime pOut, ImPlotTime datePart, ImPlotTime timePart)
		{
			fixed (ImPlotTime* ppOut = &pOut)
			{
				CombineDateTimeNative((ImPlotTime*)ppOut, datePart, timePart);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void NowNative(ImPlotTime* pOut)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<ImPlotTime*, void>)funcTable[725])(pOut);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)funcTable[725])((nint)pOut);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static ImPlotTime Now()
		{
			ImPlotTime ret;
			NowNative(&ret);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void Now(ImPlotTimePtr pOut)
		{
			NowNative((ImPlotTime*)pOut);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void Now(ref ImPlotTime pOut)
		{
			fixed (ImPlotTime* ppOut = &pOut)
			{
				NowNative((ImPlotTime*)ppOut);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void TodayNative(ImPlotTime* pOut)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<ImPlotTime*, void>)funcTable[726])(pOut);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)funcTable[726])((nint)pOut);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static ImPlotTime Today()
		{
			ImPlotTime ret;
			TodayNative(&ret);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void Today(ImPlotTimePtr pOut)
		{
			TodayNative((ImPlotTime*)pOut);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void Today(ref ImPlotTime pOut)
		{
			fixed (ImPlotTime* ppOut = &pOut)
			{
				TodayNative((ImPlotTime*)ppOut);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int FormatTimeNative(ImPlotTime t, byte* buffer, int size, ImPlotTimeFmt fmt, byte use24HrClk)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<ImPlotTime, byte*, int, ImPlotTimeFmt, byte, int>)funcTable[727])(t, buffer, size, fmt, use24HrClk);
			#else
			return (int)((delegate* unmanaged[Cdecl]<ImPlotTime, nint, int, ImPlotTimeFmt, byte, int>)funcTable[727])(t, (nint)buffer, size, fmt, use24HrClk);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static int FormatTime(ImPlotTime t, byte* buffer, int size, ImPlotTimeFmt fmt, bool use24HrClk)
		{
			int ret = FormatTimeNative(t, buffer, size, fmt, use24HrClk ? (byte)1 : (byte)0);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static int FormatTime(ImPlotTime t, ref byte buffer, int size, ImPlotTimeFmt fmt, bool use24HrClk)
		{
			fixed (byte* pbuffer = &buffer)
			{
				int ret = FormatTimeNative(t, (byte*)pbuffer, size, fmt, use24HrClk ? (byte)1 : (byte)0);
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static int FormatTime(ImPlotTime t, ref string buffer, int size, ImPlotTimeFmt fmt, bool use24HrClk)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (buffer != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(buffer);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(buffer, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			int ret = FormatTimeNative(t, pStr0, size, fmt, use24HrClk ? (byte)1 : (byte)0);
			buffer = Utils.DecodeStringUTF8(pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int FormatDateNative(ImPlotTime t, byte* buffer, int size, ImPlotDateFmt fmt, byte useIso8601)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<ImPlotTime, byte*, int, ImPlotDateFmt, byte, int>)funcTable[728])(t, buffer, size, fmt, useIso8601);
			#else
			return (int)((delegate* unmanaged[Cdecl]<ImPlotTime, nint, int, ImPlotDateFmt, byte, int>)funcTable[728])(t, (nint)buffer, size, fmt, useIso8601);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static int FormatDate(ImPlotTime t, byte* buffer, int size, ImPlotDateFmt fmt, bool useIso8601)
		{
			int ret = FormatDateNative(t, buffer, size, fmt, useIso8601 ? (byte)1 : (byte)0);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static int FormatDate(ImPlotTime t, ref byte buffer, int size, ImPlotDateFmt fmt, bool useIso8601)
		{
			fixed (byte* pbuffer = &buffer)
			{
				int ret = FormatDateNative(t, (byte*)pbuffer, size, fmt, useIso8601 ? (byte)1 : (byte)0);
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static int FormatDate(ImPlotTime t, ref string buffer, int size, ImPlotDateFmt fmt, bool useIso8601)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (buffer != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(buffer);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(buffer, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			int ret = FormatDateNative(t, pStr0, size, fmt, useIso8601 ? (byte)1 : (byte)0);
			buffer = Utils.DecodeStringUTF8(pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int FormatDateTimeNative(ImPlotTime t, byte* buffer, int size, ImPlotDateTimeSpec fmt)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<ImPlotTime, byte*, int, ImPlotDateTimeSpec, int>)funcTable[729])(t, buffer, size, fmt);
			#else
			return (int)((delegate* unmanaged[Cdecl]<ImPlotTime, nint, int, ImPlotDateTimeSpec, int>)funcTable[729])(t, (nint)buffer, size, fmt);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static int FormatDateTime(ImPlotTime t, byte* buffer, int size, ImPlotDateTimeSpec fmt)
		{
			int ret = FormatDateTimeNative(t, buffer, size, fmt);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static int FormatDateTime(ImPlotTime t, ref byte buffer, int size, ImPlotDateTimeSpec fmt)
		{
			fixed (byte* pbuffer = &buffer)
			{
				int ret = FormatDateTimeNative(t, (byte*)pbuffer, size, fmt);
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static int FormatDateTime(ImPlotTime t, ref string buffer, int size, ImPlotDateTimeSpec fmt)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (buffer != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(buffer);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(buffer, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			int ret = FormatDateTimeNative(t, pStr0, size, fmt);
			buffer = Utils.DecodeStringUTF8(pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte ShowDatePickerNative(byte* id, int* level, ImPlotTime* t, ImPlotTime* t1, ImPlotTime* t2)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<byte*, int*, ImPlotTime*, ImPlotTime*, ImPlotTime*, byte>)funcTable[730])(id, level, t, t1, t2);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<nint, nint, nint, nint, nint, byte>)funcTable[730])((nint)id, (nint)level, (nint)t, (nint)t1, (nint)t2);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool ShowDatePicker(byte* id, int* level, ImPlotTimePtr t, ImPlotTimePtr t1, ImPlotTimePtr t2)
		{
			byte ret = ShowDatePickerNative(id, level, (ImPlotTime*)t, (ImPlotTime*)t1, (ImPlotTime*)t2);
			return ret != 0;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool ShowDatePicker(byte* id, int* level, ImPlotTimePtr t, ImPlotTimePtr t1)
		{
			byte ret = ShowDatePickerNative(id, level, (ImPlotTime*)t, (ImPlotTime*)t1, (ImPlotTime*)(default));
			return ret != 0;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool ShowDatePicker(byte* id, int* level, ImPlotTimePtr t)
		{
			byte ret = ShowDatePickerNative(id, level, (ImPlotTime*)t, (ImPlotTime*)(default), (ImPlotTime*)(default));
			return ret != 0;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool ShowDatePicker(in byte id, int* level, ImPlotTimePtr t, ImPlotTimePtr t1, ImPlotTimePtr t2)
		{
			fixed (byte* pid = &id)
			{
				byte ret = ShowDatePickerNative((byte*)pid, level, (ImPlotTime*)t, (ImPlotTime*)t1, (ImPlotTime*)t2);
				return ret != 0;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool ShowDatePicker(in byte id, int* level, ImPlotTimePtr t, ImPlotTimePtr t1)
		{
			fixed (byte* pid = &id)
			{
				byte ret = ShowDatePickerNative((byte*)pid, level, (ImPlotTime*)t, (ImPlotTime*)t1, (ImPlotTime*)(default));
				return ret != 0;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool ShowDatePicker(in byte id, int* level, ImPlotTimePtr t)
		{
			fixed (byte* pid = &id)
			{
				byte ret = ShowDatePickerNative((byte*)pid, level, (ImPlotTime*)t, (ImPlotTime*)(default), (ImPlotTime*)(default));
				return ret != 0;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool ShowDatePicker(ReadOnlySpan<byte> id, int* level, ImPlotTimePtr t, ImPlotTimePtr t1, ImPlotTimePtr t2)
		{
			fixed (byte* pid = id)
			{
				byte ret = ShowDatePickerNative((byte*)pid, level, (ImPlotTime*)t, (ImPlotTime*)t1, (ImPlotTime*)t2);
				return ret != 0;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool ShowDatePicker(ReadOnlySpan<byte> id, int* level, ImPlotTimePtr t, ImPlotTimePtr t1)
		{
			fixed (byte* pid = id)
			{
				byte ret = ShowDatePickerNative((byte*)pid, level, (ImPlotTime*)t, (ImPlotTime*)t1, (ImPlotTime*)(default));
				return ret != 0;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool ShowDatePicker(ReadOnlySpan<byte> id, int* level, ImPlotTimePtr t)
		{
			fixed (byte* pid = id)
			{
				byte ret = ShowDatePickerNative((byte*)pid, level, (ImPlotTime*)t, (ImPlotTime*)(default), (ImPlotTime*)(default));
				return ret != 0;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool ShowDatePicker(string id, int* level, ImPlotTimePtr t, ImPlotTimePtr t1, ImPlotTimePtr t2)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (id != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(id);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(id, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = ShowDatePickerNative(pStr0, level, (ImPlotTime*)t, (ImPlotTime*)t1, (ImPlotTime*)t2);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool ShowDatePicker(string id, int* level, ImPlotTimePtr t, ImPlotTimePtr t1)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (id != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(id);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(id, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = ShowDatePickerNative(pStr0, level, (ImPlotTime*)t, (ImPlotTime*)t1, (ImPlotTime*)(default));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool ShowDatePicker(string id, int* level, ImPlotTimePtr t)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (id != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(id);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(id, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = ShowDatePickerNative(pStr0, level, (ImPlotTime*)t, (ImPlotTime*)(default), (ImPlotTime*)(default));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool ShowDatePicker(byte* id, ref int level, ImPlotTimePtr t, ImPlotTimePtr t1, ImPlotTimePtr t2)
		{
			fixed (int* plevel = &level)
			{
				byte ret = ShowDatePickerNative(id, (int*)plevel, (ImPlotTime*)t, (ImPlotTime*)t1, (ImPlotTime*)t2);
				return ret != 0;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool ShowDatePicker(byte* id, ref int level, ImPlotTimePtr t, ImPlotTimePtr t1)
		{
			fixed (int* plevel = &level)
			{
				byte ret = ShowDatePickerNative(id, (int*)plevel, (ImPlotTime*)t, (ImPlotTime*)t1, (ImPlotTime*)(default));
				return ret != 0;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool ShowDatePicker(byte* id, ref int level, ImPlotTimePtr t)
		{
			fixed (int* plevel = &level)
			{
				byte ret = ShowDatePickerNative(id, (int*)plevel, (ImPlotTime*)t, (ImPlotTime*)(default), (ImPlotTime*)(default));
				return ret != 0;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool ShowDatePicker(in byte id, ref int level, ImPlotTimePtr t, ImPlotTimePtr t1, ImPlotTimePtr t2)
		{
			fixed (byte* pid = &id)
			{
				fixed (int* plevel = &level)
				{
					byte ret = ShowDatePickerNative((byte*)pid, (int*)plevel, (ImPlotTime*)t, (ImPlotTime*)t1, (ImPlotTime*)t2);
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool ShowDatePicker(in byte id, ref int level, ImPlotTimePtr t, ImPlotTimePtr t1)
		{
			fixed (byte* pid = &id)
			{
				fixed (int* plevel = &level)
				{
					byte ret = ShowDatePickerNative((byte*)pid, (int*)plevel, (ImPlotTime*)t, (ImPlotTime*)t1, (ImPlotTime*)(default));
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool ShowDatePicker(in byte id, ref int level, ImPlotTimePtr t)
		{
			fixed (byte* pid = &id)
			{
				fixed (int* plevel = &level)
				{
					byte ret = ShowDatePickerNative((byte*)pid, (int*)plevel, (ImPlotTime*)t, (ImPlotTime*)(default), (ImPlotTime*)(default));
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool ShowDatePicker(ReadOnlySpan<byte> id, ref int level, ImPlotTimePtr t, ImPlotTimePtr t1, ImPlotTimePtr t2)
		{
			fixed (byte* pid = id)
			{
				fixed (int* plevel = &level)
				{
					byte ret = ShowDatePickerNative((byte*)pid, (int*)plevel, (ImPlotTime*)t, (ImPlotTime*)t1, (ImPlotTime*)t2);
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool ShowDatePicker(ReadOnlySpan<byte> id, ref int level, ImPlotTimePtr t, ImPlotTimePtr t1)
		{
			fixed (byte* pid = id)
			{
				fixed (int* plevel = &level)
				{
					byte ret = ShowDatePickerNative((byte*)pid, (int*)plevel, (ImPlotTime*)t, (ImPlotTime*)t1, (ImPlotTime*)(default));
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool ShowDatePicker(ReadOnlySpan<byte> id, ref int level, ImPlotTimePtr t)
		{
			fixed (byte* pid = id)
			{
				fixed (int* plevel = &level)
				{
					byte ret = ShowDatePickerNative((byte*)pid, (int*)plevel, (ImPlotTime*)t, (ImPlotTime*)(default), (ImPlotTime*)(default));
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool ShowDatePicker(string id, ref int level, ImPlotTimePtr t, ImPlotTimePtr t1, ImPlotTimePtr t2)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (id != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(id);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(id, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (int* plevel = &level)
			{
				byte ret = ShowDatePickerNative(pStr0, (int*)plevel, (ImPlotTime*)t, (ImPlotTime*)t1, (ImPlotTime*)t2);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret != 0;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool ShowDatePicker(string id, ref int level, ImPlotTimePtr t, ImPlotTimePtr t1)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (id != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(id);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(id, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (int* plevel = &level)
			{
				byte ret = ShowDatePickerNative(pStr0, (int*)plevel, (ImPlotTime*)t, (ImPlotTime*)t1, (ImPlotTime*)(default));
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret != 0;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool ShowDatePicker(string id, ref int level, ImPlotTimePtr t)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (id != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(id);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(id, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (int* plevel = &level)
			{
				byte ret = ShowDatePickerNative(pStr0, (int*)plevel, (ImPlotTime*)t, (ImPlotTime*)(default), (ImPlotTime*)(default));
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret != 0;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool ShowDatePicker(byte* id, int* level, ref ImPlotTime t, ImPlotTimePtr t1, ImPlotTimePtr t2)
		{
			fixed (ImPlotTime* pt = &t)
			{
				byte ret = ShowDatePickerNative(id, level, (ImPlotTime*)pt, (ImPlotTime*)t1, (ImPlotTime*)t2);
				return ret != 0;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool ShowDatePicker(byte* id, int* level, ref ImPlotTime t, ImPlotTimePtr t1)
		{
			fixed (ImPlotTime* pt = &t)
			{
				byte ret = ShowDatePickerNative(id, level, (ImPlotTime*)pt, (ImPlotTime*)t1, (ImPlotTime*)(default));
				return ret != 0;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool ShowDatePicker(byte* id, int* level, ref ImPlotTime t)
		{
			fixed (ImPlotTime* pt = &t)
			{
				byte ret = ShowDatePickerNative(id, level, (ImPlotTime*)pt, (ImPlotTime*)(default), (ImPlotTime*)(default));
				return ret != 0;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool ShowDatePicker(in byte id, int* level, ref ImPlotTime t, ImPlotTimePtr t1, ImPlotTimePtr t2)
		{
			fixed (byte* pid = &id)
			{
				fixed (ImPlotTime* pt = &t)
				{
					byte ret = ShowDatePickerNative((byte*)pid, level, (ImPlotTime*)pt, (ImPlotTime*)t1, (ImPlotTime*)t2);
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool ShowDatePicker(in byte id, int* level, ref ImPlotTime t, ImPlotTimePtr t1)
		{
			fixed (byte* pid = &id)
			{
				fixed (ImPlotTime* pt = &t)
				{
					byte ret = ShowDatePickerNative((byte*)pid, level, (ImPlotTime*)pt, (ImPlotTime*)t1, (ImPlotTime*)(default));
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool ShowDatePicker(in byte id, int* level, ref ImPlotTime t)
		{
			fixed (byte* pid = &id)
			{
				fixed (ImPlotTime* pt = &t)
				{
					byte ret = ShowDatePickerNative((byte*)pid, level, (ImPlotTime*)pt, (ImPlotTime*)(default), (ImPlotTime*)(default));
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool ShowDatePicker(ReadOnlySpan<byte> id, int* level, ref ImPlotTime t, ImPlotTimePtr t1, ImPlotTimePtr t2)
		{
			fixed (byte* pid = id)
			{
				fixed (ImPlotTime* pt = &t)
				{
					byte ret = ShowDatePickerNative((byte*)pid, level, (ImPlotTime*)pt, (ImPlotTime*)t1, (ImPlotTime*)t2);
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool ShowDatePicker(ReadOnlySpan<byte> id, int* level, ref ImPlotTime t, ImPlotTimePtr t1)
		{
			fixed (byte* pid = id)
			{
				fixed (ImPlotTime* pt = &t)
				{
					byte ret = ShowDatePickerNative((byte*)pid, level, (ImPlotTime*)pt, (ImPlotTime*)t1, (ImPlotTime*)(default));
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool ShowDatePicker(ReadOnlySpan<byte> id, int* level, ref ImPlotTime t)
		{
			fixed (byte* pid = id)
			{
				fixed (ImPlotTime* pt = &t)
				{
					byte ret = ShowDatePickerNative((byte*)pid, level, (ImPlotTime*)pt, (ImPlotTime*)(default), (ImPlotTime*)(default));
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool ShowDatePicker(string id, int* level, ref ImPlotTime t, ImPlotTimePtr t1, ImPlotTimePtr t2)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (id != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(id);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(id, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (ImPlotTime* pt = &t)
			{
				byte ret = ShowDatePickerNative(pStr0, level, (ImPlotTime*)pt, (ImPlotTime*)t1, (ImPlotTime*)t2);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret != 0;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool ShowDatePicker(string id, int* level, ref ImPlotTime t, ImPlotTimePtr t1)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (id != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(id);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(id, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (ImPlotTime* pt = &t)
			{
				byte ret = ShowDatePickerNative(pStr0, level, (ImPlotTime*)pt, (ImPlotTime*)t1, (ImPlotTime*)(default));
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret != 0;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool ShowDatePicker(string id, int* level, ref ImPlotTime t)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (id != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(id);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(id, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (ImPlotTime* pt = &t)
			{
				byte ret = ShowDatePickerNative(pStr0, level, (ImPlotTime*)pt, (ImPlotTime*)(default), (ImPlotTime*)(default));
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret != 0;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool ShowDatePicker(byte* id, ref int level, ref ImPlotTime t, ImPlotTimePtr t1, ImPlotTimePtr t2)
		{
			fixed (int* plevel = &level)
			{
				fixed (ImPlotTime* pt = &t)
				{
					byte ret = ShowDatePickerNative(id, (int*)plevel, (ImPlotTime*)pt, (ImPlotTime*)t1, (ImPlotTime*)t2);
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool ShowDatePicker(byte* id, ref int level, ref ImPlotTime t, ImPlotTimePtr t1)
		{
			fixed (int* plevel = &level)
			{
				fixed (ImPlotTime* pt = &t)
				{
					byte ret = ShowDatePickerNative(id, (int*)plevel, (ImPlotTime*)pt, (ImPlotTime*)t1, (ImPlotTime*)(default));
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool ShowDatePicker(byte* id, ref int level, ref ImPlotTime t)
		{
			fixed (int* plevel = &level)
			{
				fixed (ImPlotTime* pt = &t)
				{
					byte ret = ShowDatePickerNative(id, (int*)plevel, (ImPlotTime*)pt, (ImPlotTime*)(default), (ImPlotTime*)(default));
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool ShowDatePicker(in byte id, ref int level, ref ImPlotTime t, ImPlotTimePtr t1, ImPlotTimePtr t2)
		{
			fixed (byte* pid = &id)
			{
				fixed (int* plevel = &level)
				{
					fixed (ImPlotTime* pt = &t)
					{
						byte ret = ShowDatePickerNative((byte*)pid, (int*)plevel, (ImPlotTime*)pt, (ImPlotTime*)t1, (ImPlotTime*)t2);
						return ret != 0;
					}
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool ShowDatePicker(in byte id, ref int level, ref ImPlotTime t, ImPlotTimePtr t1)
		{
			fixed (byte* pid = &id)
			{
				fixed (int* plevel = &level)
				{
					fixed (ImPlotTime* pt = &t)
					{
						byte ret = ShowDatePickerNative((byte*)pid, (int*)plevel, (ImPlotTime*)pt, (ImPlotTime*)t1, (ImPlotTime*)(default));
						return ret != 0;
					}
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool ShowDatePicker(in byte id, ref int level, ref ImPlotTime t)
		{
			fixed (byte* pid = &id)
			{
				fixed (int* plevel = &level)
				{
					fixed (ImPlotTime* pt = &t)
					{
						byte ret = ShowDatePickerNative((byte*)pid, (int*)plevel, (ImPlotTime*)pt, (ImPlotTime*)(default), (ImPlotTime*)(default));
						return ret != 0;
					}
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool ShowDatePicker(ReadOnlySpan<byte> id, ref int level, ref ImPlotTime t, ImPlotTimePtr t1, ImPlotTimePtr t2)
		{
			fixed (byte* pid = id)
			{
				fixed (int* plevel = &level)
				{
					fixed (ImPlotTime* pt = &t)
					{
						byte ret = ShowDatePickerNative((byte*)pid, (int*)plevel, (ImPlotTime*)pt, (ImPlotTime*)t1, (ImPlotTime*)t2);
						return ret != 0;
					}
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool ShowDatePicker(ReadOnlySpan<byte> id, ref int level, ref ImPlotTime t, ImPlotTimePtr t1)
		{
			fixed (byte* pid = id)
			{
				fixed (int* plevel = &level)
				{
					fixed (ImPlotTime* pt = &t)
					{
						byte ret = ShowDatePickerNative((byte*)pid, (int*)plevel, (ImPlotTime*)pt, (ImPlotTime*)t1, (ImPlotTime*)(default));
						return ret != 0;
					}
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool ShowDatePicker(ReadOnlySpan<byte> id, ref int level, ref ImPlotTime t)
		{
			fixed (byte* pid = id)
			{
				fixed (int* plevel = &level)
				{
					fixed (ImPlotTime* pt = &t)
					{
						byte ret = ShowDatePickerNative((byte*)pid, (int*)plevel, (ImPlotTime*)pt, (ImPlotTime*)(default), (ImPlotTime*)(default));
						return ret != 0;
					}
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool ShowDatePicker(string id, ref int level, ref ImPlotTime t, ImPlotTimePtr t1, ImPlotTimePtr t2)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (id != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(id);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(id, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (int* plevel = &level)
			{
				fixed (ImPlotTime* pt = &t)
				{
					byte ret = ShowDatePickerNative(pStr0, (int*)plevel, (ImPlotTime*)pt, (ImPlotTime*)t1, (ImPlotTime*)t2);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool ShowDatePicker(string id, ref int level, ref ImPlotTime t, ImPlotTimePtr t1)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (id != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(id);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(id, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (int* plevel = &level)
			{
				fixed (ImPlotTime* pt = &t)
				{
					byte ret = ShowDatePickerNative(pStr0, (int*)plevel, (ImPlotTime*)pt, (ImPlotTime*)t1, (ImPlotTime*)(default));
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool ShowDatePicker(string id, ref int level, ref ImPlotTime t)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (id != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(id);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(id, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (int* plevel = &level)
			{
				fixed (ImPlotTime* pt = &t)
				{
					byte ret = ShowDatePickerNative(pStr0, (int*)plevel, (ImPlotTime*)pt, (ImPlotTime*)(default), (ImPlotTime*)(default));
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool ShowDatePicker(byte* id, int* level, ImPlotTimePtr t, in ImPlotTime t1, ImPlotTimePtr t2)
		{
			fixed (ImPlotTime* pt1 = &t1)
			{
				byte ret = ShowDatePickerNative(id, level, (ImPlotTime*)t, (ImPlotTime*)pt1, (ImPlotTime*)t2);
				return ret != 0;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool ShowDatePicker(byte* id, int* level, ImPlotTimePtr t, in ImPlotTime t1)
		{
			fixed (ImPlotTime* pt1 = &t1)
			{
				byte ret = ShowDatePickerNative(id, level, (ImPlotTime*)t, (ImPlotTime*)pt1, (ImPlotTime*)(default));
				return ret != 0;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool ShowDatePicker(in byte id, int* level, ImPlotTimePtr t, in ImPlotTime t1, ImPlotTimePtr t2)
		{
			fixed (byte* pid = &id)
			{
				fixed (ImPlotTime* pt1 = &t1)
				{
					byte ret = ShowDatePickerNative((byte*)pid, level, (ImPlotTime*)t, (ImPlotTime*)pt1, (ImPlotTime*)t2);
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool ShowDatePicker(in byte id, int* level, ImPlotTimePtr t, in ImPlotTime t1)
		{
			fixed (byte* pid = &id)
			{
				fixed (ImPlotTime* pt1 = &t1)
				{
					byte ret = ShowDatePickerNative((byte*)pid, level, (ImPlotTime*)t, (ImPlotTime*)pt1, (ImPlotTime*)(default));
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool ShowDatePicker(ReadOnlySpan<byte> id, int* level, ImPlotTimePtr t, in ImPlotTime t1, ImPlotTimePtr t2)
		{
			fixed (byte* pid = id)
			{
				fixed (ImPlotTime* pt1 = &t1)
				{
					byte ret = ShowDatePickerNative((byte*)pid, level, (ImPlotTime*)t, (ImPlotTime*)pt1, (ImPlotTime*)t2);
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool ShowDatePicker(ReadOnlySpan<byte> id, int* level, ImPlotTimePtr t, in ImPlotTime t1)
		{
			fixed (byte* pid = id)
			{
				fixed (ImPlotTime* pt1 = &t1)
				{
					byte ret = ShowDatePickerNative((byte*)pid, level, (ImPlotTime*)t, (ImPlotTime*)pt1, (ImPlotTime*)(default));
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool ShowDatePicker(string id, int* level, ImPlotTimePtr t, in ImPlotTime t1, ImPlotTimePtr t2)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (id != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(id);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(id, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (ImPlotTime* pt1 = &t1)
			{
				byte ret = ShowDatePickerNative(pStr0, level, (ImPlotTime*)t, (ImPlotTime*)pt1, (ImPlotTime*)t2);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret != 0;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool ShowDatePicker(string id, int* level, ImPlotTimePtr t, in ImPlotTime t1)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (id != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(id);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(id, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (ImPlotTime* pt1 = &t1)
			{
				byte ret = ShowDatePickerNative(pStr0, level, (ImPlotTime*)t, (ImPlotTime*)pt1, (ImPlotTime*)(default));
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret != 0;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool ShowDatePicker(byte* id, ref int level, ImPlotTimePtr t, in ImPlotTime t1, ImPlotTimePtr t2)
		{
			fixed (int* plevel = &level)
			{
				fixed (ImPlotTime* pt1 = &t1)
				{
					byte ret = ShowDatePickerNative(id, (int*)plevel, (ImPlotTime*)t, (ImPlotTime*)pt1, (ImPlotTime*)t2);
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool ShowDatePicker(byte* id, ref int level, ImPlotTimePtr t, in ImPlotTime t1)
		{
			fixed (int* plevel = &level)
			{
				fixed (ImPlotTime* pt1 = &t1)
				{
					byte ret = ShowDatePickerNative(id, (int*)plevel, (ImPlotTime*)t, (ImPlotTime*)pt1, (ImPlotTime*)(default));
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool ShowDatePicker(in byte id, ref int level, ImPlotTimePtr t, in ImPlotTime t1, ImPlotTimePtr t2)
		{
			fixed (byte* pid = &id)
			{
				fixed (int* plevel = &level)
				{
					fixed (ImPlotTime* pt1 = &t1)
					{
						byte ret = ShowDatePickerNative((byte*)pid, (int*)plevel, (ImPlotTime*)t, (ImPlotTime*)pt1, (ImPlotTime*)t2);
						return ret != 0;
					}
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool ShowDatePicker(in byte id, ref int level, ImPlotTimePtr t, in ImPlotTime t1)
		{
			fixed (byte* pid = &id)
			{
				fixed (int* plevel = &level)
				{
					fixed (ImPlotTime* pt1 = &t1)
					{
						byte ret = ShowDatePickerNative((byte*)pid, (int*)plevel, (ImPlotTime*)t, (ImPlotTime*)pt1, (ImPlotTime*)(default));
						return ret != 0;
					}
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool ShowDatePicker(ReadOnlySpan<byte> id, ref int level, ImPlotTimePtr t, in ImPlotTime t1, ImPlotTimePtr t2)
		{
			fixed (byte* pid = id)
			{
				fixed (int* plevel = &level)
				{
					fixed (ImPlotTime* pt1 = &t1)
					{
						byte ret = ShowDatePickerNative((byte*)pid, (int*)plevel, (ImPlotTime*)t, (ImPlotTime*)pt1, (ImPlotTime*)t2);
						return ret != 0;
					}
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool ShowDatePicker(ReadOnlySpan<byte> id, ref int level, ImPlotTimePtr t, in ImPlotTime t1)
		{
			fixed (byte* pid = id)
			{
				fixed (int* plevel = &level)
				{
					fixed (ImPlotTime* pt1 = &t1)
					{
						byte ret = ShowDatePickerNative((byte*)pid, (int*)plevel, (ImPlotTime*)t, (ImPlotTime*)pt1, (ImPlotTime*)(default));
						return ret != 0;
					}
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool ShowDatePicker(string id, ref int level, ImPlotTimePtr t, in ImPlotTime t1, ImPlotTimePtr t2)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (id != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(id);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(id, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (int* plevel = &level)
			{
				fixed (ImPlotTime* pt1 = &t1)
				{
					byte ret = ShowDatePickerNative(pStr0, (int*)plevel, (ImPlotTime*)t, (ImPlotTime*)pt1, (ImPlotTime*)t2);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool ShowDatePicker(string id, ref int level, ImPlotTimePtr t, in ImPlotTime t1)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (id != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(id);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(id, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (int* plevel = &level)
			{
				fixed (ImPlotTime* pt1 = &t1)
				{
					byte ret = ShowDatePickerNative(pStr0, (int*)plevel, (ImPlotTime*)t, (ImPlotTime*)pt1, (ImPlotTime*)(default));
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool ShowDatePicker(byte* id, int* level, ref ImPlotTime t, in ImPlotTime t1, ImPlotTimePtr t2)
		{
			fixed (ImPlotTime* pt = &t)
			{
				fixed (ImPlotTime* pt1 = &t1)
				{
					byte ret = ShowDatePickerNative(id, level, (ImPlotTime*)pt, (ImPlotTime*)pt1, (ImPlotTime*)t2);
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool ShowDatePicker(byte* id, int* level, ref ImPlotTime t, in ImPlotTime t1)
		{
			fixed (ImPlotTime* pt = &t)
			{
				fixed (ImPlotTime* pt1 = &t1)
				{
					byte ret = ShowDatePickerNative(id, level, (ImPlotTime*)pt, (ImPlotTime*)pt1, (ImPlotTime*)(default));
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool ShowDatePicker(in byte id, int* level, ref ImPlotTime t, in ImPlotTime t1, ImPlotTimePtr t2)
		{
			fixed (byte* pid = &id)
			{
				fixed (ImPlotTime* pt = &t)
				{
					fixed (ImPlotTime* pt1 = &t1)
					{
						byte ret = ShowDatePickerNative((byte*)pid, level, (ImPlotTime*)pt, (ImPlotTime*)pt1, (ImPlotTime*)t2);
						return ret != 0;
					}
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool ShowDatePicker(in byte id, int* level, ref ImPlotTime t, in ImPlotTime t1)
		{
			fixed (byte* pid = &id)
			{
				fixed (ImPlotTime* pt = &t)
				{
					fixed (ImPlotTime* pt1 = &t1)
					{
						byte ret = ShowDatePickerNative((byte*)pid, level, (ImPlotTime*)pt, (ImPlotTime*)pt1, (ImPlotTime*)(default));
						return ret != 0;
					}
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool ShowDatePicker(ReadOnlySpan<byte> id, int* level, ref ImPlotTime t, in ImPlotTime t1, ImPlotTimePtr t2)
		{
			fixed (byte* pid = id)
			{
				fixed (ImPlotTime* pt = &t)
				{
					fixed (ImPlotTime* pt1 = &t1)
					{
						byte ret = ShowDatePickerNative((byte*)pid, level, (ImPlotTime*)pt, (ImPlotTime*)pt1, (ImPlotTime*)t2);
						return ret != 0;
					}
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool ShowDatePicker(ReadOnlySpan<byte> id, int* level, ref ImPlotTime t, in ImPlotTime t1)
		{
			fixed (byte* pid = id)
			{
				fixed (ImPlotTime* pt = &t)
				{
					fixed (ImPlotTime* pt1 = &t1)
					{
						byte ret = ShowDatePickerNative((byte*)pid, level, (ImPlotTime*)pt, (ImPlotTime*)pt1, (ImPlotTime*)(default));
						return ret != 0;
					}
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool ShowDatePicker(string id, int* level, ref ImPlotTime t, in ImPlotTime t1, ImPlotTimePtr t2)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (id != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(id);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(id, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (ImPlotTime* pt = &t)
			{
				fixed (ImPlotTime* pt1 = &t1)
				{
					byte ret = ShowDatePickerNative(pStr0, level, (ImPlotTime*)pt, (ImPlotTime*)pt1, (ImPlotTime*)t2);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool ShowDatePicker(string id, int* level, ref ImPlotTime t, in ImPlotTime t1)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (id != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(id);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(id, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (ImPlotTime* pt = &t)
			{
				fixed (ImPlotTime* pt1 = &t1)
				{
					byte ret = ShowDatePickerNative(pStr0, level, (ImPlotTime*)pt, (ImPlotTime*)pt1, (ImPlotTime*)(default));
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool ShowDatePicker(byte* id, ref int level, ref ImPlotTime t, in ImPlotTime t1, ImPlotTimePtr t2)
		{
			fixed (int* plevel = &level)
			{
				fixed (ImPlotTime* pt = &t)
				{
					fixed (ImPlotTime* pt1 = &t1)
					{
						byte ret = ShowDatePickerNative(id, (int*)plevel, (ImPlotTime*)pt, (ImPlotTime*)pt1, (ImPlotTime*)t2);
						return ret != 0;
					}
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool ShowDatePicker(byte* id, ref int level, ref ImPlotTime t, in ImPlotTime t1)
		{
			fixed (int* plevel = &level)
			{
				fixed (ImPlotTime* pt = &t)
				{
					fixed (ImPlotTime* pt1 = &t1)
					{
						byte ret = ShowDatePickerNative(id, (int*)plevel, (ImPlotTime*)pt, (ImPlotTime*)pt1, (ImPlotTime*)(default));
						return ret != 0;
					}
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool ShowDatePicker(in byte id, ref int level, ref ImPlotTime t, in ImPlotTime t1, ImPlotTimePtr t2)
		{
			fixed (byte* pid = &id)
			{
				fixed (int* plevel = &level)
				{
					fixed (ImPlotTime* pt = &t)
					{
						fixed (ImPlotTime* pt1 = &t1)
						{
							byte ret = ShowDatePickerNative((byte*)pid, (int*)plevel, (ImPlotTime*)pt, (ImPlotTime*)pt1, (ImPlotTime*)t2);
							return ret != 0;
						}
					}
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool ShowDatePicker(in byte id, ref int level, ref ImPlotTime t, in ImPlotTime t1)
		{
			fixed (byte* pid = &id)
			{
				fixed (int* plevel = &level)
				{
					fixed (ImPlotTime* pt = &t)
					{
						fixed (ImPlotTime* pt1 = &t1)
						{
							byte ret = ShowDatePickerNative((byte*)pid, (int*)plevel, (ImPlotTime*)pt, (ImPlotTime*)pt1, (ImPlotTime*)(default));
							return ret != 0;
						}
					}
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool ShowDatePicker(ReadOnlySpan<byte> id, ref int level, ref ImPlotTime t, in ImPlotTime t1, ImPlotTimePtr t2)
		{
			fixed (byte* pid = id)
			{
				fixed (int* plevel = &level)
				{
					fixed (ImPlotTime* pt = &t)
					{
						fixed (ImPlotTime* pt1 = &t1)
						{
							byte ret = ShowDatePickerNative((byte*)pid, (int*)plevel, (ImPlotTime*)pt, (ImPlotTime*)pt1, (ImPlotTime*)t2);
							return ret != 0;
						}
					}
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool ShowDatePicker(ReadOnlySpan<byte> id, ref int level, ref ImPlotTime t, in ImPlotTime t1)
		{
			fixed (byte* pid = id)
			{
				fixed (int* plevel = &level)
				{
					fixed (ImPlotTime* pt = &t)
					{
						fixed (ImPlotTime* pt1 = &t1)
						{
							byte ret = ShowDatePickerNative((byte*)pid, (int*)plevel, (ImPlotTime*)pt, (ImPlotTime*)pt1, (ImPlotTime*)(default));
							return ret != 0;
						}
					}
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool ShowDatePicker(string id, ref int level, ref ImPlotTime t, in ImPlotTime t1, ImPlotTimePtr t2)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (id != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(id);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(id, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (int* plevel = &level)
			{
				fixed (ImPlotTime* pt = &t)
				{
					fixed (ImPlotTime* pt1 = &t1)
					{
						byte ret = ShowDatePickerNative(pStr0, (int*)plevel, (ImPlotTime*)pt, (ImPlotTime*)pt1, (ImPlotTime*)t2);
						if (pStrSize0 >= Utils.MaxStackallocSize)
						{
							Utils.Free(pStr0);
						}
						return ret != 0;
					}
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool ShowDatePicker(string id, ref int level, ref ImPlotTime t, in ImPlotTime t1)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (id != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(id);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(id, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (int* plevel = &level)
			{
				fixed (ImPlotTime* pt = &t)
				{
					fixed (ImPlotTime* pt1 = &t1)
					{
						byte ret = ShowDatePickerNative(pStr0, (int*)plevel, (ImPlotTime*)pt, (ImPlotTime*)pt1, (ImPlotTime*)(default));
						if (pStrSize0 >= Utils.MaxStackallocSize)
						{
							Utils.Free(pStr0);
						}
						return ret != 0;
					}
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool ShowDatePicker(byte* id, int* level, ImPlotTimePtr t, ImPlotTimePtr t1, in ImPlotTime t2)
		{
			fixed (ImPlotTime* pt2 = &t2)
			{
				byte ret = ShowDatePickerNative(id, level, (ImPlotTime*)t, (ImPlotTime*)t1, (ImPlotTime*)pt2);
				return ret != 0;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool ShowDatePicker(in byte id, int* level, ImPlotTimePtr t, ImPlotTimePtr t1, in ImPlotTime t2)
		{
			fixed (byte* pid = &id)
			{
				fixed (ImPlotTime* pt2 = &t2)
				{
					byte ret = ShowDatePickerNative((byte*)pid, level, (ImPlotTime*)t, (ImPlotTime*)t1, (ImPlotTime*)pt2);
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool ShowDatePicker(ReadOnlySpan<byte> id, int* level, ImPlotTimePtr t, ImPlotTimePtr t1, in ImPlotTime t2)
		{
			fixed (byte* pid = id)
			{
				fixed (ImPlotTime* pt2 = &t2)
				{
					byte ret = ShowDatePickerNative((byte*)pid, level, (ImPlotTime*)t, (ImPlotTime*)t1, (ImPlotTime*)pt2);
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool ShowDatePicker(string id, int* level, ImPlotTimePtr t, ImPlotTimePtr t1, in ImPlotTime t2)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (id != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(id);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(id, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (ImPlotTime* pt2 = &t2)
			{
				byte ret = ShowDatePickerNative(pStr0, level, (ImPlotTime*)t, (ImPlotTime*)t1, (ImPlotTime*)pt2);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret != 0;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool ShowDatePicker(byte* id, ref int level, ImPlotTimePtr t, ImPlotTimePtr t1, in ImPlotTime t2)
		{
			fixed (int* plevel = &level)
			{
				fixed (ImPlotTime* pt2 = &t2)
				{
					byte ret = ShowDatePickerNative(id, (int*)plevel, (ImPlotTime*)t, (ImPlotTime*)t1, (ImPlotTime*)pt2);
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool ShowDatePicker(in byte id, ref int level, ImPlotTimePtr t, ImPlotTimePtr t1, in ImPlotTime t2)
		{
			fixed (byte* pid = &id)
			{
				fixed (int* plevel = &level)
				{
					fixed (ImPlotTime* pt2 = &t2)
					{
						byte ret = ShowDatePickerNative((byte*)pid, (int*)plevel, (ImPlotTime*)t, (ImPlotTime*)t1, (ImPlotTime*)pt2);
						return ret != 0;
					}
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool ShowDatePicker(ReadOnlySpan<byte> id, ref int level, ImPlotTimePtr t, ImPlotTimePtr t1, in ImPlotTime t2)
		{
			fixed (byte* pid = id)
			{
				fixed (int* plevel = &level)
				{
					fixed (ImPlotTime* pt2 = &t2)
					{
						byte ret = ShowDatePickerNative((byte*)pid, (int*)plevel, (ImPlotTime*)t, (ImPlotTime*)t1, (ImPlotTime*)pt2);
						return ret != 0;
					}
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool ShowDatePicker(string id, ref int level, ImPlotTimePtr t, ImPlotTimePtr t1, in ImPlotTime t2)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (id != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(id);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(id, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (int* plevel = &level)
			{
				fixed (ImPlotTime* pt2 = &t2)
				{
					byte ret = ShowDatePickerNative(pStr0, (int*)plevel, (ImPlotTime*)t, (ImPlotTime*)t1, (ImPlotTime*)pt2);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool ShowDatePicker(byte* id, int* level, ref ImPlotTime t, ImPlotTimePtr t1, in ImPlotTime t2)
		{
			fixed (ImPlotTime* pt = &t)
			{
				fixed (ImPlotTime* pt2 = &t2)
				{
					byte ret = ShowDatePickerNative(id, level, (ImPlotTime*)pt, (ImPlotTime*)t1, (ImPlotTime*)pt2);
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool ShowDatePicker(in byte id, int* level, ref ImPlotTime t, ImPlotTimePtr t1, in ImPlotTime t2)
		{
			fixed (byte* pid = &id)
			{
				fixed (ImPlotTime* pt = &t)
				{
					fixed (ImPlotTime* pt2 = &t2)
					{
						byte ret = ShowDatePickerNative((byte*)pid, level, (ImPlotTime*)pt, (ImPlotTime*)t1, (ImPlotTime*)pt2);
						return ret != 0;
					}
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool ShowDatePicker(ReadOnlySpan<byte> id, int* level, ref ImPlotTime t, ImPlotTimePtr t1, in ImPlotTime t2)
		{
			fixed (byte* pid = id)
			{
				fixed (ImPlotTime* pt = &t)
				{
					fixed (ImPlotTime* pt2 = &t2)
					{
						byte ret = ShowDatePickerNative((byte*)pid, level, (ImPlotTime*)pt, (ImPlotTime*)t1, (ImPlotTime*)pt2);
						return ret != 0;
					}
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool ShowDatePicker(string id, int* level, ref ImPlotTime t, ImPlotTimePtr t1, in ImPlotTime t2)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (id != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(id);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(id, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (ImPlotTime* pt = &t)
			{
				fixed (ImPlotTime* pt2 = &t2)
				{
					byte ret = ShowDatePickerNative(pStr0, level, (ImPlotTime*)pt, (ImPlotTime*)t1, (ImPlotTime*)pt2);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool ShowDatePicker(byte* id, ref int level, ref ImPlotTime t, ImPlotTimePtr t1, in ImPlotTime t2)
		{
			fixed (int* plevel = &level)
			{
				fixed (ImPlotTime* pt = &t)
				{
					fixed (ImPlotTime* pt2 = &t2)
					{
						byte ret = ShowDatePickerNative(id, (int*)plevel, (ImPlotTime*)pt, (ImPlotTime*)t1, (ImPlotTime*)pt2);
						return ret != 0;
					}
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool ShowDatePicker(in byte id, ref int level, ref ImPlotTime t, ImPlotTimePtr t1, in ImPlotTime t2)
		{
			fixed (byte* pid = &id)
			{
				fixed (int* plevel = &level)
				{
					fixed (ImPlotTime* pt = &t)
					{
						fixed (ImPlotTime* pt2 = &t2)
						{
							byte ret = ShowDatePickerNative((byte*)pid, (int*)plevel, (ImPlotTime*)pt, (ImPlotTime*)t1, (ImPlotTime*)pt2);
							return ret != 0;
						}
					}
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool ShowDatePicker(ReadOnlySpan<byte> id, ref int level, ref ImPlotTime t, ImPlotTimePtr t1, in ImPlotTime t2)
		{
			fixed (byte* pid = id)
			{
				fixed (int* plevel = &level)
				{
					fixed (ImPlotTime* pt = &t)
					{
						fixed (ImPlotTime* pt2 = &t2)
						{
							byte ret = ShowDatePickerNative((byte*)pid, (int*)plevel, (ImPlotTime*)pt, (ImPlotTime*)t1, (ImPlotTime*)pt2);
							return ret != 0;
						}
					}
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool ShowDatePicker(string id, ref int level, ref ImPlotTime t, ImPlotTimePtr t1, in ImPlotTime t2)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (id != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(id);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(id, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (int* plevel = &level)
			{
				fixed (ImPlotTime* pt = &t)
				{
					fixed (ImPlotTime* pt2 = &t2)
					{
						byte ret = ShowDatePickerNative(pStr0, (int*)plevel, (ImPlotTime*)pt, (ImPlotTime*)t1, (ImPlotTime*)pt2);
						if (pStrSize0 >= Utils.MaxStackallocSize)
						{
							Utils.Free(pStr0);
						}
						return ret != 0;
					}
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool ShowDatePicker(byte* id, int* level, ImPlotTimePtr t, in ImPlotTime t1, in ImPlotTime t2)
		{
			fixed (ImPlotTime* pt1 = &t1)
			{
				fixed (ImPlotTime* pt2 = &t2)
				{
					byte ret = ShowDatePickerNative(id, level, (ImPlotTime*)t, (ImPlotTime*)pt1, (ImPlotTime*)pt2);
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool ShowDatePicker(in byte id, int* level, ImPlotTimePtr t, in ImPlotTime t1, in ImPlotTime t2)
		{
			fixed (byte* pid = &id)
			{
				fixed (ImPlotTime* pt1 = &t1)
				{
					fixed (ImPlotTime* pt2 = &t2)
					{
						byte ret = ShowDatePickerNative((byte*)pid, level, (ImPlotTime*)t, (ImPlotTime*)pt1, (ImPlotTime*)pt2);
						return ret != 0;
					}
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool ShowDatePicker(ReadOnlySpan<byte> id, int* level, ImPlotTimePtr t, in ImPlotTime t1, in ImPlotTime t2)
		{
			fixed (byte* pid = id)
			{
				fixed (ImPlotTime* pt1 = &t1)
				{
					fixed (ImPlotTime* pt2 = &t2)
					{
						byte ret = ShowDatePickerNative((byte*)pid, level, (ImPlotTime*)t, (ImPlotTime*)pt1, (ImPlotTime*)pt2);
						return ret != 0;
					}
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool ShowDatePicker(string id, int* level, ImPlotTimePtr t, in ImPlotTime t1, in ImPlotTime t2)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (id != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(id);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(id, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (ImPlotTime* pt1 = &t1)
			{
				fixed (ImPlotTime* pt2 = &t2)
				{
					byte ret = ShowDatePickerNative(pStr0, level, (ImPlotTime*)t, (ImPlotTime*)pt1, (ImPlotTime*)pt2);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool ShowDatePicker(byte* id, ref int level, ImPlotTimePtr t, in ImPlotTime t1, in ImPlotTime t2)
		{
			fixed (int* plevel = &level)
			{
				fixed (ImPlotTime* pt1 = &t1)
				{
					fixed (ImPlotTime* pt2 = &t2)
					{
						byte ret = ShowDatePickerNative(id, (int*)plevel, (ImPlotTime*)t, (ImPlotTime*)pt1, (ImPlotTime*)pt2);
						return ret != 0;
					}
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool ShowDatePicker(in byte id, ref int level, ImPlotTimePtr t, in ImPlotTime t1, in ImPlotTime t2)
		{
			fixed (byte* pid = &id)
			{
				fixed (int* plevel = &level)
				{
					fixed (ImPlotTime* pt1 = &t1)
					{
						fixed (ImPlotTime* pt2 = &t2)
						{
							byte ret = ShowDatePickerNative((byte*)pid, (int*)plevel, (ImPlotTime*)t, (ImPlotTime*)pt1, (ImPlotTime*)pt2);
							return ret != 0;
						}
					}
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool ShowDatePicker(ReadOnlySpan<byte> id, ref int level, ImPlotTimePtr t, in ImPlotTime t1, in ImPlotTime t2)
		{
			fixed (byte* pid = id)
			{
				fixed (int* plevel = &level)
				{
					fixed (ImPlotTime* pt1 = &t1)
					{
						fixed (ImPlotTime* pt2 = &t2)
						{
							byte ret = ShowDatePickerNative((byte*)pid, (int*)plevel, (ImPlotTime*)t, (ImPlotTime*)pt1, (ImPlotTime*)pt2);
							return ret != 0;
						}
					}
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool ShowDatePicker(string id, ref int level, ImPlotTimePtr t, in ImPlotTime t1, in ImPlotTime t2)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (id != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(id);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(id, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (int* plevel = &level)
			{
				fixed (ImPlotTime* pt1 = &t1)
				{
					fixed (ImPlotTime* pt2 = &t2)
					{
						byte ret = ShowDatePickerNative(pStr0, (int*)plevel, (ImPlotTime*)t, (ImPlotTime*)pt1, (ImPlotTime*)pt2);
						if (pStrSize0 >= Utils.MaxStackallocSize)
						{
							Utils.Free(pStr0);
						}
						return ret != 0;
					}
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool ShowDatePicker(byte* id, int* level, ref ImPlotTime t, in ImPlotTime t1, in ImPlotTime t2)
		{
			fixed (ImPlotTime* pt = &t)
			{
				fixed (ImPlotTime* pt1 = &t1)
				{
					fixed (ImPlotTime* pt2 = &t2)
					{
						byte ret = ShowDatePickerNative(id, level, (ImPlotTime*)pt, (ImPlotTime*)pt1, (ImPlotTime*)pt2);
						return ret != 0;
					}
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool ShowDatePicker(in byte id, int* level, ref ImPlotTime t, in ImPlotTime t1, in ImPlotTime t2)
		{
			fixed (byte* pid = &id)
			{
				fixed (ImPlotTime* pt = &t)
				{
					fixed (ImPlotTime* pt1 = &t1)
					{
						fixed (ImPlotTime* pt2 = &t2)
						{
							byte ret = ShowDatePickerNative((byte*)pid, level, (ImPlotTime*)pt, (ImPlotTime*)pt1, (ImPlotTime*)pt2);
							return ret != 0;
						}
					}
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool ShowDatePicker(ReadOnlySpan<byte> id, int* level, ref ImPlotTime t, in ImPlotTime t1, in ImPlotTime t2)
		{
			fixed (byte* pid = id)
			{
				fixed (ImPlotTime* pt = &t)
				{
					fixed (ImPlotTime* pt1 = &t1)
					{
						fixed (ImPlotTime* pt2 = &t2)
						{
							byte ret = ShowDatePickerNative((byte*)pid, level, (ImPlotTime*)pt, (ImPlotTime*)pt1, (ImPlotTime*)pt2);
							return ret != 0;
						}
					}
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool ShowDatePicker(string id, int* level, ref ImPlotTime t, in ImPlotTime t1, in ImPlotTime t2)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (id != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(id);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(id, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (ImPlotTime* pt = &t)
			{
				fixed (ImPlotTime* pt1 = &t1)
				{
					fixed (ImPlotTime* pt2 = &t2)
					{
						byte ret = ShowDatePickerNative(pStr0, level, (ImPlotTime*)pt, (ImPlotTime*)pt1, (ImPlotTime*)pt2);
						if (pStrSize0 >= Utils.MaxStackallocSize)
						{
							Utils.Free(pStr0);
						}
						return ret != 0;
					}
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool ShowDatePicker(byte* id, ref int level, ref ImPlotTime t, in ImPlotTime t1, in ImPlotTime t2)
		{
			fixed (int* plevel = &level)
			{
				fixed (ImPlotTime* pt = &t)
				{
					fixed (ImPlotTime* pt1 = &t1)
					{
						fixed (ImPlotTime* pt2 = &t2)
						{
							byte ret = ShowDatePickerNative(id, (int*)plevel, (ImPlotTime*)pt, (ImPlotTime*)pt1, (ImPlotTime*)pt2);
							return ret != 0;
						}
					}
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool ShowDatePicker(in byte id, ref int level, ref ImPlotTime t, in ImPlotTime t1, in ImPlotTime t2)
		{
			fixed (byte* pid = &id)
			{
				fixed (int* plevel = &level)
				{
					fixed (ImPlotTime* pt = &t)
					{
						fixed (ImPlotTime* pt1 = &t1)
						{
							fixed (ImPlotTime* pt2 = &t2)
							{
								byte ret = ShowDatePickerNative((byte*)pid, (int*)plevel, (ImPlotTime*)pt, (ImPlotTime*)pt1, (ImPlotTime*)pt2);
								return ret != 0;
							}
						}
					}
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool ShowDatePicker(ReadOnlySpan<byte> id, ref int level, ref ImPlotTime t, in ImPlotTime t1, in ImPlotTime t2)
		{
			fixed (byte* pid = id)
			{
				fixed (int* plevel = &level)
				{
					fixed (ImPlotTime* pt = &t)
					{
						fixed (ImPlotTime* pt1 = &t1)
						{
							fixed (ImPlotTime* pt2 = &t2)
							{
								byte ret = ShowDatePickerNative((byte*)pid, (int*)plevel, (ImPlotTime*)pt, (ImPlotTime*)pt1, (ImPlotTime*)pt2);
								return ret != 0;
							}
						}
					}
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool ShowDatePicker(string id, ref int level, ref ImPlotTime t, in ImPlotTime t1, in ImPlotTime t2)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (id != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(id);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(id, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (int* plevel = &level)
			{
				fixed (ImPlotTime* pt = &t)
				{
					fixed (ImPlotTime* pt1 = &t1)
					{
						fixed (ImPlotTime* pt2 = &t2)
						{
							byte ret = ShowDatePickerNative(pStr0, (int*)plevel, (ImPlotTime*)pt, (ImPlotTime*)pt1, (ImPlotTime*)pt2);
							if (pStrSize0 >= Utils.MaxStackallocSize)
							{
								Utils.Free(pStr0);
							}
							return ret != 0;
						}
					}
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte ShowTimePickerNative(byte* id, ImPlotTime* t)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<byte*, ImPlotTime*, byte>)funcTable[731])(id, t);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<nint, nint, byte>)funcTable[731])((nint)id, (nint)t);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool ShowTimePicker(byte* id, ImPlotTimePtr t)
		{
			byte ret = ShowTimePickerNative(id, (ImPlotTime*)t);
			return ret != 0;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool ShowTimePicker(in byte id, ImPlotTimePtr t)
		{
			fixed (byte* pid = &id)
			{
				byte ret = ShowTimePickerNative((byte*)pid, (ImPlotTime*)t);
				return ret != 0;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool ShowTimePicker(ReadOnlySpan<byte> id, ImPlotTimePtr t)
		{
			fixed (byte* pid = id)
			{
				byte ret = ShowTimePickerNative((byte*)pid, (ImPlotTime*)t);
				return ret != 0;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool ShowTimePicker(string id, ImPlotTimePtr t)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (id != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(id);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(id, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = ShowTimePickerNative(pStr0, (ImPlotTime*)t);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool ShowTimePicker(byte* id, ref ImPlotTime t)
		{
			fixed (ImPlotTime* pt = &t)
			{
				byte ret = ShowTimePickerNative(id, (ImPlotTime*)pt);
				return ret != 0;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool ShowTimePicker(in byte id, ref ImPlotTime t)
		{
			fixed (byte* pid = &id)
			{
				fixed (ImPlotTime* pt = &t)
				{
					byte ret = ShowTimePickerNative((byte*)pid, (ImPlotTime*)pt);
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool ShowTimePicker(ReadOnlySpan<byte> id, ref ImPlotTime t)
		{
			fixed (byte* pid = id)
			{
				fixed (ImPlotTime* pt = &t)
				{
					byte ret = ShowTimePickerNative((byte*)pid, (ImPlotTime*)pt);
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool ShowTimePicker(string id, ref ImPlotTime t)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (id != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(id);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(id, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (ImPlotTime* pt = &t)
			{
				byte ret = ShowTimePickerNative(pStr0, (ImPlotTime*)pt);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret != 0;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static double TransformForward_Log10Native(double v, void* noname1)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<double, void*, double>)funcTable[732])(v, noname1);
			#else
			return (double)((delegate* unmanaged[Cdecl]<double, nint, double>)funcTable[732])(v, (nint)noname1);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static double TransformForward_Log10(double v, void* noname1)
		{
			double ret = TransformForward_Log10Native(v, noname1);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static double TransformForward_Log10(double v, nint noname1)
		{
			double ret = TransformForward_Log10Native(v, (void*)noname1);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static double TransformInverse_Log10Native(double v, void* noname1)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<double, void*, double>)funcTable[733])(v, noname1);
			#else
			return (double)((delegate* unmanaged[Cdecl]<double, nint, double>)funcTable[733])(v, (nint)noname1);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static double TransformInverse_Log10(double v, void* noname1)
		{
			double ret = TransformInverse_Log10Native(v, noname1);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static double TransformInverse_Log10(double v, nint noname1)
		{
			double ret = TransformInverse_Log10Native(v, (void*)noname1);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static double TransformForward_SymLogNative(double v, void* noname1)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<double, void*, double>)funcTable[734])(v, noname1);
			#else
			return (double)((delegate* unmanaged[Cdecl]<double, nint, double>)funcTable[734])(v, (nint)noname1);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static double TransformForward_SymLog(double v, void* noname1)
		{
			double ret = TransformForward_SymLogNative(v, noname1);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static double TransformForward_SymLog(double v, nint noname1)
		{
			double ret = TransformForward_SymLogNative(v, (void*)noname1);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static double TransformInverse_SymLogNative(double v, void* noname1)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<double, void*, double>)funcTable[735])(v, noname1);
			#else
			return (double)((delegate* unmanaged[Cdecl]<double, nint, double>)funcTable[735])(v, (nint)noname1);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static double TransformInverse_SymLog(double v, void* noname1)
		{
			double ret = TransformInverse_SymLogNative(v, noname1);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static double TransformInverse_SymLog(double v, nint noname1)
		{
			double ret = TransformInverse_SymLogNative(v, (void*)noname1);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static double TransformForward_LogitNative(double v, void* noname1)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<double, void*, double>)funcTable[736])(v, noname1);
			#else
			return (double)((delegate* unmanaged[Cdecl]<double, nint, double>)funcTable[736])(v, (nint)noname1);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static double TransformForward_Logit(double v, void* noname1)
		{
			double ret = TransformForward_LogitNative(v, noname1);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static double TransformForward_Logit(double v, nint noname1)
		{
			double ret = TransformForward_LogitNative(v, (void*)noname1);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static double TransformInverse_LogitNative(double v, void* noname1)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<double, void*, double>)funcTable[737])(v, noname1);
			#else
			return (double)((delegate* unmanaged[Cdecl]<double, nint, double>)funcTable[737])(v, (nint)noname1);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static double TransformInverse_Logit(double v, void* noname1)
		{
			double ret = TransformInverse_LogitNative(v, noname1);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static double TransformInverse_Logit(double v, nint noname1)
		{
			double ret = TransformInverse_LogitNative(v, (void*)noname1);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int Formatter_DefaultNative(double value, byte* buff, int size, void* data)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<double, byte*, int, void*, int>)funcTable[738])(value, buff, size, data);
			#else
			return (int)((delegate* unmanaged[Cdecl]<double, nint, int, nint, int>)funcTable[738])(value, (nint)buff, size, (nint)data);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static int Formatter_Default(double value, byte* buff, int size, void* data)
		{
			int ret = Formatter_DefaultNative(value, buff, size, data);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static int Formatter_Default(double value, ref byte buff, int size, void* data)
		{
			fixed (byte* pbuff = &buff)
			{
				int ret = Formatter_DefaultNative(value, (byte*)pbuff, size, data);
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static int Formatter_Default(double value, ref string buff, int size, void* data)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (buff != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(buff);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(buff, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			int ret = Formatter_DefaultNative(value, pStr0, size, data);
			buff = Utils.DecodeStringUTF8(pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static int Formatter_Default(double value, byte* buff, int size, nint data)
		{
			int ret = Formatter_DefaultNative(value, buff, size, (void*)data);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static int Formatter_Default(double value, ref byte buff, int size, nint data)
		{
			fixed (byte* pbuff = &buff)
			{
				int ret = Formatter_DefaultNative(value, (byte*)pbuff, size, (void*)data);
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static int Formatter_Default(double value, ref string buff, int size, nint data)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (buff != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(buff);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(buff, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			int ret = Formatter_DefaultNative(value, pStr0, size, (void*)data);
			buff = Utils.DecodeStringUTF8(pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int Formatter_LogitNative(double value, byte* buff, int size, void* noname1)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<double, byte*, int, void*, int>)funcTable[739])(value, buff, size, noname1);
			#else
			return (int)((delegate* unmanaged[Cdecl]<double, nint, int, nint, int>)funcTable[739])(value, (nint)buff, size, (nint)noname1);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static int Formatter_Logit(double value, byte* buff, int size, void* noname1)
		{
			int ret = Formatter_LogitNative(value, buff, size, noname1);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static int Formatter_Logit(double value, ref byte buff, int size, void* noname1)
		{
			fixed (byte* pbuff = &buff)
			{
				int ret = Formatter_LogitNative(value, (byte*)pbuff, size, noname1);
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static int Formatter_Logit(double value, ref string buff, int size, void* noname1)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (buff != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(buff);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(buff, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			int ret = Formatter_LogitNative(value, pStr0, size, noname1);
			buff = Utils.DecodeStringUTF8(pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static int Formatter_Logit(double value, byte* buff, int size, nint noname1)
		{
			int ret = Formatter_LogitNative(value, buff, size, (void*)noname1);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static int Formatter_Logit(double value, ref byte buff, int size, nint noname1)
		{
			fixed (byte* pbuff = &buff)
			{
				int ret = Formatter_LogitNative(value, (byte*)pbuff, size, (void*)noname1);
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static int Formatter_Logit(double value, ref string buff, int size, nint noname1)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (buff != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(buff);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(buff, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			int ret = Formatter_LogitNative(value, pStr0, size, (void*)noname1);
			buff = Utils.DecodeStringUTF8(pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int Formatter_TimeNative(double noname1, byte* buff, int size, void* data)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<double, byte*, int, void*, int>)funcTable[740])(noname1, buff, size, data);
			#else
			return (int)((delegate* unmanaged[Cdecl]<double, nint, int, nint, int>)funcTable[740])(noname1, (nint)buff, size, (nint)data);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static int Formatter_Time(double noname1, byte* buff, int size, void* data)
		{
			int ret = Formatter_TimeNative(noname1, buff, size, data);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static int Formatter_Time(double noname1, ref byte buff, int size, void* data)
		{
			fixed (byte* pbuff = &buff)
			{
				int ret = Formatter_TimeNative(noname1, (byte*)pbuff, size, data);
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static int Formatter_Time(double noname1, ref string buff, int size, void* data)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (buff != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(buff);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(buff, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			int ret = Formatter_TimeNative(noname1, pStr0, size, data);
			buff = Utils.DecodeStringUTF8(pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static int Formatter_Time(double noname1, byte* buff, int size, nint data)
		{
			int ret = Formatter_TimeNative(noname1, buff, size, (void*)data);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static int Formatter_Time(double noname1, ref byte buff, int size, nint data)
		{
			fixed (byte* pbuff = &buff)
			{
				int ret = Formatter_TimeNative(noname1, (byte*)pbuff, size, (void*)data);
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static int Formatter_Time(double noname1, ref string buff, int size, nint data)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (buff != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(buff);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(buff, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			int ret = Formatter_TimeNative(noname1, pStr0, size, (void*)data);
			buff = Utils.DecodeStringUTF8(pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void Locator_DefaultNative(ImPlotTicker* ticker, ImPlotRange range, float pixels, byte vertical, delegate*<double, byte*, int, void*, int> formatter, void* formatterData)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<ImPlotTicker*, ImPlotRange, float, byte, delegate*<double, byte*, int, void*, int>, void*, void>)funcTable[741])(ticker, range, pixels, vertical, formatter, formatterData);
			#else
			((delegate* unmanaged[Cdecl]<nint, ImPlotRange, float, byte, nint, nint, void>)funcTable[741])((nint)ticker, range, pixels, vertical, (nint)formatter, (nint)formatterData);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void Locator_Default(ImPlotTickerPtr ticker, ImPlotRange range, float pixels, bool vertical, delegate*<double, byte*, int, void*, int> formatter, void* formatterData)
		{
			Locator_DefaultNative((ImPlotTicker*)ticker, range, pixels, vertical ? (byte)1 : (byte)0, formatter, formatterData);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void Locator_Default(ref ImPlotTicker ticker, ImPlotRange range, float pixels, bool vertical, delegate*<double, byte*, int, void*, int> formatter, void* formatterData)
		{
			fixed (ImPlotTicker* pticker = &ticker)
			{
				Locator_DefaultNative((ImPlotTicker*)pticker, range, pixels, vertical ? (byte)1 : (byte)0, formatter, formatterData);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void Locator_Default(ImPlotTickerPtr ticker, ImPlotRange range, float pixels, bool vertical, ImPlotFormatter formatter, void* formatterData)
		{
			Locator_DefaultNative((ImPlotTicker*)ticker, range, pixels, vertical ? (byte)1 : (byte)0, (delegate*<double, byte*, int, void*, int>)Utils.GetFunctionPointerForDelegate(formatter), formatterData);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void Locator_Default(ref ImPlotTicker ticker, ImPlotRange range, float pixels, bool vertical, ImPlotFormatter formatter, void* formatterData)
		{
			fixed (ImPlotTicker* pticker = &ticker)
			{
				Locator_DefaultNative((ImPlotTicker*)pticker, range, pixels, vertical ? (byte)1 : (byte)0, (delegate*<double, byte*, int, void*, int>)Utils.GetFunctionPointerForDelegate(formatter), formatterData);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void Locator_Default(ImPlotTickerPtr ticker, ImPlotRange range, float pixels, bool vertical, delegate*<double, byte*, int, void*, int> formatter, nint formatterData)
		{
			Locator_DefaultNative((ImPlotTicker*)ticker, range, pixels, vertical ? (byte)1 : (byte)0, formatter, (void*)formatterData);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void Locator_Default(ref ImPlotTicker ticker, ImPlotRange range, float pixels, bool vertical, delegate*<double, byte*, int, void*, int> formatter, nint formatterData)
		{
			fixed (ImPlotTicker* pticker = &ticker)
			{
				Locator_DefaultNative((ImPlotTicker*)pticker, range, pixels, vertical ? (byte)1 : (byte)0, formatter, (void*)formatterData);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void Locator_Default(ImPlotTickerPtr ticker, ImPlotRange range, float pixels, bool vertical, ImPlotFormatter formatter, nint formatterData)
		{
			Locator_DefaultNative((ImPlotTicker*)ticker, range, pixels, vertical ? (byte)1 : (byte)0, (delegate*<double, byte*, int, void*, int>)Utils.GetFunctionPointerForDelegate(formatter), (void*)formatterData);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void Locator_Default(ref ImPlotTicker ticker, ImPlotRange range, float pixels, bool vertical, ImPlotFormatter formatter, nint formatterData)
		{
			fixed (ImPlotTicker* pticker = &ticker)
			{
				Locator_DefaultNative((ImPlotTicker*)pticker, range, pixels, vertical ? (byte)1 : (byte)0, (delegate*<double, byte*, int, void*, int>)Utils.GetFunctionPointerForDelegate(formatter), (void*)formatterData);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void Locator_TimeNative(ImPlotTicker* ticker, ImPlotRange range, float pixels, byte vertical, delegate*<double, byte*, int, void*, int> formatter, void* formatterData)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<ImPlotTicker*, ImPlotRange, float, byte, delegate*<double, byte*, int, void*, int>, void*, void>)funcTable[742])(ticker, range, pixels, vertical, formatter, formatterData);
			#else
			((delegate* unmanaged[Cdecl]<nint, ImPlotRange, float, byte, nint, nint, void>)funcTable[742])((nint)ticker, range, pixels, vertical, (nint)formatter, (nint)formatterData);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void Locator_Time(ImPlotTickerPtr ticker, ImPlotRange range, float pixels, bool vertical, delegate*<double, byte*, int, void*, int> formatter, void* formatterData)
		{
			Locator_TimeNative((ImPlotTicker*)ticker, range, pixels, vertical ? (byte)1 : (byte)0, formatter, formatterData);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void Locator_Time(ref ImPlotTicker ticker, ImPlotRange range, float pixels, bool vertical, delegate*<double, byte*, int, void*, int> formatter, void* formatterData)
		{
			fixed (ImPlotTicker* pticker = &ticker)
			{
				Locator_TimeNative((ImPlotTicker*)pticker, range, pixels, vertical ? (byte)1 : (byte)0, formatter, formatterData);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void Locator_Time(ImPlotTickerPtr ticker, ImPlotRange range, float pixels, bool vertical, ImPlotFormatter formatter, void* formatterData)
		{
			Locator_TimeNative((ImPlotTicker*)ticker, range, pixels, vertical ? (byte)1 : (byte)0, (delegate*<double, byte*, int, void*, int>)Utils.GetFunctionPointerForDelegate(formatter), formatterData);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void Locator_Time(ref ImPlotTicker ticker, ImPlotRange range, float pixels, bool vertical, ImPlotFormatter formatter, void* formatterData)
		{
			fixed (ImPlotTicker* pticker = &ticker)
			{
				Locator_TimeNative((ImPlotTicker*)pticker, range, pixels, vertical ? (byte)1 : (byte)0, (delegate*<double, byte*, int, void*, int>)Utils.GetFunctionPointerForDelegate(formatter), formatterData);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void Locator_Time(ImPlotTickerPtr ticker, ImPlotRange range, float pixels, bool vertical, delegate*<double, byte*, int, void*, int> formatter, nint formatterData)
		{
			Locator_TimeNative((ImPlotTicker*)ticker, range, pixels, vertical ? (byte)1 : (byte)0, formatter, (void*)formatterData);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void Locator_Time(ref ImPlotTicker ticker, ImPlotRange range, float pixels, bool vertical, delegate*<double, byte*, int, void*, int> formatter, nint formatterData)
		{
			fixed (ImPlotTicker* pticker = &ticker)
			{
				Locator_TimeNative((ImPlotTicker*)pticker, range, pixels, vertical ? (byte)1 : (byte)0, formatter, (void*)formatterData);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void Locator_Time(ImPlotTickerPtr ticker, ImPlotRange range, float pixels, bool vertical, ImPlotFormatter formatter, nint formatterData)
		{
			Locator_TimeNative((ImPlotTicker*)ticker, range, pixels, vertical ? (byte)1 : (byte)0, (delegate*<double, byte*, int, void*, int>)Utils.GetFunctionPointerForDelegate(formatter), (void*)formatterData);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void Locator_Time(ref ImPlotTicker ticker, ImPlotRange range, float pixels, bool vertical, ImPlotFormatter formatter, nint formatterData)
		{
			fixed (ImPlotTicker* pticker = &ticker)
			{
				Locator_TimeNative((ImPlotTicker*)pticker, range, pixels, vertical ? (byte)1 : (byte)0, (delegate*<double, byte*, int, void*, int>)Utils.GetFunctionPointerForDelegate(formatter), (void*)formatterData);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void Locator_Log10Native(ImPlotTicker* ticker, ImPlotRange range, float pixels, byte vertical, delegate*<double, byte*, int, void*, int> formatter, void* formatterData)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<ImPlotTicker*, ImPlotRange, float, byte, delegate*<double, byte*, int, void*, int>, void*, void>)funcTable[743])(ticker, range, pixels, vertical, formatter, formatterData);
			#else
			((delegate* unmanaged[Cdecl]<nint, ImPlotRange, float, byte, nint, nint, void>)funcTable[743])((nint)ticker, range, pixels, vertical, (nint)formatter, (nint)formatterData);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void Locator_Log10(ImPlotTickerPtr ticker, ImPlotRange range, float pixels, bool vertical, delegate*<double, byte*, int, void*, int> formatter, void* formatterData)
		{
			Locator_Log10Native((ImPlotTicker*)ticker, range, pixels, vertical ? (byte)1 : (byte)0, formatter, formatterData);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void Locator_Log10(ref ImPlotTicker ticker, ImPlotRange range, float pixels, bool vertical, delegate*<double, byte*, int, void*, int> formatter, void* formatterData)
		{
			fixed (ImPlotTicker* pticker = &ticker)
			{
				Locator_Log10Native((ImPlotTicker*)pticker, range, pixels, vertical ? (byte)1 : (byte)0, formatter, formatterData);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void Locator_Log10(ImPlotTickerPtr ticker, ImPlotRange range, float pixels, bool vertical, ImPlotFormatter formatter, void* formatterData)
		{
			Locator_Log10Native((ImPlotTicker*)ticker, range, pixels, vertical ? (byte)1 : (byte)0, (delegate*<double, byte*, int, void*, int>)Utils.GetFunctionPointerForDelegate(formatter), formatterData);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void Locator_Log10(ref ImPlotTicker ticker, ImPlotRange range, float pixels, bool vertical, ImPlotFormatter formatter, void* formatterData)
		{
			fixed (ImPlotTicker* pticker = &ticker)
			{
				Locator_Log10Native((ImPlotTicker*)pticker, range, pixels, vertical ? (byte)1 : (byte)0, (delegate*<double, byte*, int, void*, int>)Utils.GetFunctionPointerForDelegate(formatter), formatterData);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void Locator_Log10(ImPlotTickerPtr ticker, ImPlotRange range, float pixels, bool vertical, delegate*<double, byte*, int, void*, int> formatter, nint formatterData)
		{
			Locator_Log10Native((ImPlotTicker*)ticker, range, pixels, vertical ? (byte)1 : (byte)0, formatter, (void*)formatterData);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void Locator_Log10(ref ImPlotTicker ticker, ImPlotRange range, float pixels, bool vertical, delegate*<double, byte*, int, void*, int> formatter, nint formatterData)
		{
			fixed (ImPlotTicker* pticker = &ticker)
			{
				Locator_Log10Native((ImPlotTicker*)pticker, range, pixels, vertical ? (byte)1 : (byte)0, formatter, (void*)formatterData);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void Locator_Log10(ImPlotTickerPtr ticker, ImPlotRange range, float pixels, bool vertical, ImPlotFormatter formatter, nint formatterData)
		{
			Locator_Log10Native((ImPlotTicker*)ticker, range, pixels, vertical ? (byte)1 : (byte)0, (delegate*<double, byte*, int, void*, int>)Utils.GetFunctionPointerForDelegate(formatter), (void*)formatterData);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void Locator_Log10(ref ImPlotTicker ticker, ImPlotRange range, float pixels, bool vertical, ImPlotFormatter formatter, nint formatterData)
		{
			fixed (ImPlotTicker* pticker = &ticker)
			{
				Locator_Log10Native((ImPlotTicker*)pticker, range, pixels, vertical ? (byte)1 : (byte)0, (delegate*<double, byte*, int, void*, int>)Utils.GetFunctionPointerForDelegate(formatter), (void*)formatterData);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void Locator_SymLogNative(ImPlotTicker* ticker, ImPlotRange range, float pixels, byte vertical, delegate*<double, byte*, int, void*, int> formatter, void* formatterData)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<ImPlotTicker*, ImPlotRange, float, byte, delegate*<double, byte*, int, void*, int>, void*, void>)funcTable[744])(ticker, range, pixels, vertical, formatter, formatterData);
			#else
			((delegate* unmanaged[Cdecl]<nint, ImPlotRange, float, byte, nint, nint, void>)funcTable[744])((nint)ticker, range, pixels, vertical, (nint)formatter, (nint)formatterData);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void Locator_SymLog(ImPlotTickerPtr ticker, ImPlotRange range, float pixels, bool vertical, delegate*<double, byte*, int, void*, int> formatter, void* formatterData)
		{
			Locator_SymLogNative((ImPlotTicker*)ticker, range, pixels, vertical ? (byte)1 : (byte)0, formatter, formatterData);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void Locator_SymLog(ref ImPlotTicker ticker, ImPlotRange range, float pixels, bool vertical, delegate*<double, byte*, int, void*, int> formatter, void* formatterData)
		{
			fixed (ImPlotTicker* pticker = &ticker)
			{
				Locator_SymLogNative((ImPlotTicker*)pticker, range, pixels, vertical ? (byte)1 : (byte)0, formatter, formatterData);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void Locator_SymLog(ImPlotTickerPtr ticker, ImPlotRange range, float pixels, bool vertical, ImPlotFormatter formatter, void* formatterData)
		{
			Locator_SymLogNative((ImPlotTicker*)ticker, range, pixels, vertical ? (byte)1 : (byte)0, (delegate*<double, byte*, int, void*, int>)Utils.GetFunctionPointerForDelegate(formatter), formatterData);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void Locator_SymLog(ref ImPlotTicker ticker, ImPlotRange range, float pixels, bool vertical, ImPlotFormatter formatter, void* formatterData)
		{
			fixed (ImPlotTicker* pticker = &ticker)
			{
				Locator_SymLogNative((ImPlotTicker*)pticker, range, pixels, vertical ? (byte)1 : (byte)0, (delegate*<double, byte*, int, void*, int>)Utils.GetFunctionPointerForDelegate(formatter), formatterData);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void Locator_SymLog(ImPlotTickerPtr ticker, ImPlotRange range, float pixels, bool vertical, delegate*<double, byte*, int, void*, int> formatter, nint formatterData)
		{
			Locator_SymLogNative((ImPlotTicker*)ticker, range, pixels, vertical ? (byte)1 : (byte)0, formatter, (void*)formatterData);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void Locator_SymLog(ref ImPlotTicker ticker, ImPlotRange range, float pixels, bool vertical, delegate*<double, byte*, int, void*, int> formatter, nint formatterData)
		{
			fixed (ImPlotTicker* pticker = &ticker)
			{
				Locator_SymLogNative((ImPlotTicker*)pticker, range, pixels, vertical ? (byte)1 : (byte)0, formatter, (void*)formatterData);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void Locator_SymLog(ImPlotTickerPtr ticker, ImPlotRange range, float pixels, bool vertical, ImPlotFormatter formatter, nint formatterData)
		{
			Locator_SymLogNative((ImPlotTicker*)ticker, range, pixels, vertical ? (byte)1 : (byte)0, (delegate*<double, byte*, int, void*, int>)Utils.GetFunctionPointerForDelegate(formatter), (void*)formatterData);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void Locator_SymLog(ref ImPlotTicker ticker, ImPlotRange range, float pixels, bool vertical, ImPlotFormatter formatter, nint formatterData)
		{
			fixed (ImPlotTicker* pticker = &ticker)
			{
				Locator_SymLogNative((ImPlotTicker*)pticker, range, pixels, vertical ? (byte)1 : (byte)0, (delegate*<double, byte*, int, void*, int>)Utils.GetFunctionPointerForDelegate(formatter), (void*)formatterData);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void SetAllocatorFunctionsNative(delegate*<nuint, void*, void*> allocFunc, delegate*<void*, void*, void> freeFunc, void* userData)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<delegate*<nuint, void*, void*>, delegate*<void*, void*, void>, void*, void>)funcTable[745])(allocFunc, freeFunc, userData);
			#else
			((delegate* unmanaged[Cdecl]<nint, nint, nint, void>)funcTable[745])((nint)allocFunc, (nint)freeFunc, (nint)userData);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void SetAllocatorFunctions(delegate*<nuint, void*, void*> allocFunc, delegate*<void*, void*, void> freeFunc, void* userData)
		{
			SetAllocatorFunctionsNative(allocFunc, freeFunc, userData);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void SetAllocatorFunctions(ImGuiMemAllocFunc allocFunc, delegate*<void*, void*, void> freeFunc, void* userData)
		{
			SetAllocatorFunctionsNative((delegate*<nuint, void*, void*>)Utils.GetFunctionPointerForDelegate(allocFunc), freeFunc, userData);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void SetAllocatorFunctions(delegate*<nuint, void*, void*> allocFunc, ImGuiMemFreeFunc freeFunc, void* userData)
		{
			SetAllocatorFunctionsNative(allocFunc, (delegate*<void*, void*, void>)Utils.GetFunctionPointerForDelegate(freeFunc), userData);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void SetAllocatorFunctions(ImGuiMemAllocFunc allocFunc, ImGuiMemFreeFunc freeFunc, void* userData)
		{
			SetAllocatorFunctionsNative((delegate*<nuint, void*, void*>)Utils.GetFunctionPointerForDelegate(allocFunc), (delegate*<void*, void*, void>)Utils.GetFunctionPointerForDelegate(freeFunc), userData);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void SetAllocatorFunctions(delegate*<nuint, void*, void*> allocFunc, delegate*<void*, void*, void> freeFunc, nint userData)
		{
			SetAllocatorFunctionsNative(allocFunc, freeFunc, (void*)userData);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void SetAllocatorFunctions(ImGuiMemAllocFunc allocFunc, delegate*<void*, void*, void> freeFunc, nint userData)
		{
			SetAllocatorFunctionsNative((delegate*<nuint, void*, void*>)Utils.GetFunctionPointerForDelegate(allocFunc), freeFunc, (void*)userData);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void SetAllocatorFunctions(delegate*<nuint, void*, void*> allocFunc, ImGuiMemFreeFunc freeFunc, nint userData)
		{
			SetAllocatorFunctionsNative(allocFunc, (delegate*<void*, void*, void>)Utils.GetFunctionPointerForDelegate(freeFunc), (void*)userData);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void SetAllocatorFunctions(ImGuiMemAllocFunc allocFunc, ImGuiMemFreeFunc freeFunc, nint userData)
		{
			SetAllocatorFunctionsNative((delegate*<nuint, void*, void*>)Utils.GetFunctionPointerForDelegate(allocFunc), (delegate*<void*, void*, void>)Utils.GetFunctionPointerForDelegate(freeFunc), (void*)userData);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetAllocatorFunctionsNative(delegate*<nuint, void*, void*>* pAllocFunc, delegate*<void*, void*, void>* pFreeFunc, void** pUserData)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<delegate*<nuint, void*, void*>*, delegate*<void*, void*, void>*, void**, void>)funcTable[746])(pAllocFunc, pFreeFunc, pUserData);
			#else
			((delegate* unmanaged[Cdecl]<nint, nint, nint, void>)funcTable[746])((nint)pAllocFunc, (nint)pFreeFunc, (nint)pUserData);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void GetAllocatorFunctions(delegate*<nuint, void*, void*>* pAllocFunc, delegate*<void*, void*, void>* pFreeFunc, void** pUserData)
		{
			GetAllocatorFunctionsNative(pAllocFunc, pFreeFunc, pUserData);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void GetAllocatorFunctions(delegate*<nuint, void*, void*>* pAllocFunc, delegate*<void*, void*, void>* pFreeFunc, ref nint pUserData)
		{
			fixed (nint* ppUserData = &pUserData)
			{
				GetAllocatorFunctionsNative(pAllocFunc, pFreeFunc, (void**)ppUserData);
			}
		}

	}
}
