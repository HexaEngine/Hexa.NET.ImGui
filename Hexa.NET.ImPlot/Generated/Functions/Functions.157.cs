// ------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
// ------------------------------------------------------------------------------

using System;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;
using HexaGen.Runtime;
using System.Numerics;
using Hexa.NET.ImGui;

namespace Hexa.NET.ImPlot
{
	public unsafe partial class ImPlot
	{

		/// <summary>
		/// To be documented.
		/// </summary>
		public static long ImMaxArray(long* values, int count)
		{
			long ret = ImMaxArrayNative(values, count);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static long ImMaxArray(in long values, int count)
		{
			fixed (long* pvalues = &values)
			{
				long ret = ImMaxArrayNative((long*)pvalues, count);
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static ulong ImMaxArrayNative(ulong* values, int count)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<ulong*, int, ulong>)funcTable[440])(values, count);
			#else
			return (ulong)((delegate* unmanaged[Cdecl]<nint, int, ulong>)funcTable[440])((nint)values, count);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static ulong ImMaxArray(ulong* values, int count)
		{
			ulong ret = ImMaxArrayNative(values, count);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static ulong ImMaxArray(in ulong values, int count)
		{
			fixed (ulong* pvalues = &values)
			{
				ulong ret = ImMaxArrayNative((ulong*)pvalues, count);
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void ImMinMaxArrayNative(float* values, int count, float* minOut, float* maxOut)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<float*, int, float*, float*, void>)funcTable[441])(values, count, minOut, maxOut);
			#else
			((delegate* unmanaged[Cdecl]<nint, int, nint, nint, void>)funcTable[441])((nint)values, count, (nint)minOut, (nint)maxOut);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void ImMinMaxArray(float* values, int count, float* minOut, float* maxOut)
		{
			ImMinMaxArrayNative(values, count, minOut, maxOut);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void ImMinMaxArray(in float values, int count, float* minOut, float* maxOut)
		{
			fixed (float* pvalues = &values)
			{
				ImMinMaxArrayNative((float*)pvalues, count, minOut, maxOut);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void ImMinMaxArray(float* values, int count, ref float minOut, float* maxOut)
		{
			fixed (float* pminOut = &minOut)
			{
				ImMinMaxArrayNative(values, count, (float*)pminOut, maxOut);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void ImMinMaxArray(in float values, int count, ref float minOut, float* maxOut)
		{
			fixed (float* pvalues = &values)
			{
				fixed (float* pminOut = &minOut)
				{
					ImMinMaxArrayNative((float*)pvalues, count, (float*)pminOut, maxOut);
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void ImMinMaxArray(float* values, int count, float* minOut, ref float maxOut)
		{
			fixed (float* pmaxOut = &maxOut)
			{
				ImMinMaxArrayNative(values, count, minOut, (float*)pmaxOut);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void ImMinMaxArray(in float values, int count, float* minOut, ref float maxOut)
		{
			fixed (float* pvalues = &values)
			{
				fixed (float* pmaxOut = &maxOut)
				{
					ImMinMaxArrayNative((float*)pvalues, count, minOut, (float*)pmaxOut);
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void ImMinMaxArray(float* values, int count, ref float minOut, ref float maxOut)
		{
			fixed (float* pminOut = &minOut)
			{
				fixed (float* pmaxOut = &maxOut)
				{
					ImMinMaxArrayNative(values, count, (float*)pminOut, (float*)pmaxOut);
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void ImMinMaxArray(in float values, int count, ref float minOut, ref float maxOut)
		{
			fixed (float* pvalues = &values)
			{
				fixed (float* pminOut = &minOut)
				{
					fixed (float* pmaxOut = &maxOut)
					{
						ImMinMaxArrayNative((float*)pvalues, count, (float*)pminOut, (float*)pmaxOut);
					}
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void ImMinMaxArrayNative(double* values, int count, double* minOut, double* maxOut)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<double*, int, double*, double*, void>)funcTable[442])(values, count, minOut, maxOut);
			#else
			((delegate* unmanaged[Cdecl]<nint, int, nint, nint, void>)funcTable[442])((nint)values, count, (nint)minOut, (nint)maxOut);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void ImMinMaxArray(double* values, int count, double* minOut, double* maxOut)
		{
			ImMinMaxArrayNative(values, count, minOut, maxOut);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void ImMinMaxArray(in double values, int count, double* minOut, double* maxOut)
		{
			fixed (double* pvalues = &values)
			{
				ImMinMaxArrayNative((double*)pvalues, count, minOut, maxOut);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void ImMinMaxArray(double* values, int count, ref double minOut, double* maxOut)
		{
			fixed (double* pminOut = &minOut)
			{
				ImMinMaxArrayNative(values, count, (double*)pminOut, maxOut);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void ImMinMaxArray(in double values, int count, ref double minOut, double* maxOut)
		{
			fixed (double* pvalues = &values)
			{
				fixed (double* pminOut = &minOut)
				{
					ImMinMaxArrayNative((double*)pvalues, count, (double*)pminOut, maxOut);
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void ImMinMaxArray(double* values, int count, double* minOut, ref double maxOut)
		{
			fixed (double* pmaxOut = &maxOut)
			{
				ImMinMaxArrayNative(values, count, minOut, (double*)pmaxOut);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void ImMinMaxArray(in double values, int count, double* minOut, ref double maxOut)
		{
			fixed (double* pvalues = &values)
			{
				fixed (double* pmaxOut = &maxOut)
				{
					ImMinMaxArrayNative((double*)pvalues, count, minOut, (double*)pmaxOut);
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void ImMinMaxArray(double* values, int count, ref double minOut, ref double maxOut)
		{
			fixed (double* pminOut = &minOut)
			{
				fixed (double* pmaxOut = &maxOut)
				{
					ImMinMaxArrayNative(values, count, (double*)pminOut, (double*)pmaxOut);
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void ImMinMaxArray(in double values, int count, ref double minOut, ref double maxOut)
		{
			fixed (double* pvalues = &values)
			{
				fixed (double* pminOut = &minOut)
				{
					fixed (double* pmaxOut = &maxOut)
					{
						ImMinMaxArrayNative((double*)pvalues, count, (double*)pminOut, (double*)pmaxOut);
					}
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void ImMinMaxArrayNative(sbyte* values, int count, sbyte* minOut, sbyte* maxOut)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<sbyte*, int, sbyte*, sbyte*, void>)funcTable[443])(values, count, minOut, maxOut);
			#else
			((delegate* unmanaged[Cdecl]<nint, int, nint, nint, void>)funcTable[443])((nint)values, count, (nint)minOut, (nint)maxOut);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void ImMinMaxArray(sbyte* values, int count, sbyte* minOut, sbyte* maxOut)
		{
			ImMinMaxArrayNative(values, count, minOut, maxOut);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void ImMinMaxArray(in sbyte values, int count, sbyte* minOut, sbyte* maxOut)
		{
			fixed (sbyte* pvalues = &values)
			{
				ImMinMaxArrayNative((sbyte*)pvalues, count, minOut, maxOut);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void ImMinMaxArray(sbyte* values, int count, ref sbyte minOut, sbyte* maxOut)
		{
			fixed (sbyte* pminOut = &minOut)
			{
				ImMinMaxArrayNative(values, count, (sbyte*)pminOut, maxOut);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void ImMinMaxArray(in sbyte values, int count, ref sbyte minOut, sbyte* maxOut)
		{
			fixed (sbyte* pvalues = &values)
			{
				fixed (sbyte* pminOut = &minOut)
				{
					ImMinMaxArrayNative((sbyte*)pvalues, count, (sbyte*)pminOut, maxOut);
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void ImMinMaxArray(sbyte* values, int count, sbyte* minOut, ref sbyte maxOut)
		{
			fixed (sbyte* pmaxOut = &maxOut)
			{
				ImMinMaxArrayNative(values, count, minOut, (sbyte*)pmaxOut);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void ImMinMaxArray(in sbyte values, int count, sbyte* minOut, ref sbyte maxOut)
		{
			fixed (sbyte* pvalues = &values)
			{
				fixed (sbyte* pmaxOut = &maxOut)
				{
					ImMinMaxArrayNative((sbyte*)pvalues, count, minOut, (sbyte*)pmaxOut);
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void ImMinMaxArray(sbyte* values, int count, ref sbyte minOut, ref sbyte maxOut)
		{
			fixed (sbyte* pminOut = &minOut)
			{
				fixed (sbyte* pmaxOut = &maxOut)
				{
					ImMinMaxArrayNative(values, count, (sbyte*)pminOut, (sbyte*)pmaxOut);
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void ImMinMaxArray(in sbyte values, int count, ref sbyte minOut, ref sbyte maxOut)
		{
			fixed (sbyte* pvalues = &values)
			{
				fixed (sbyte* pminOut = &minOut)
				{
					fixed (sbyte* pmaxOut = &maxOut)
					{
						ImMinMaxArrayNative((sbyte*)pvalues, count, (sbyte*)pminOut, (sbyte*)pmaxOut);
					}
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void ImMinMaxArrayNative(byte* values, int count, byte* minOut, byte* maxOut)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<byte*, int, byte*, byte*, void>)funcTable[444])(values, count, minOut, maxOut);
			#else
			((delegate* unmanaged[Cdecl]<nint, int, nint, nint, void>)funcTable[444])((nint)values, count, (nint)minOut, (nint)maxOut);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void ImMinMaxArray(byte* values, int count, byte* minOut, byte* maxOut)
		{
			ImMinMaxArrayNative(values, count, minOut, maxOut);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void ImMinMaxArray(in byte values, int count, byte* minOut, byte* maxOut)
		{
			fixed (byte* pvalues = &values)
			{
				ImMinMaxArrayNative((byte*)pvalues, count, minOut, maxOut);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void ImMinMaxArray(byte* values, int count, ref byte minOut, byte* maxOut)
		{
			fixed (byte* pminOut = &minOut)
			{
				ImMinMaxArrayNative(values, count, (byte*)pminOut, maxOut);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void ImMinMaxArray(in byte values, int count, ref byte minOut, byte* maxOut)
		{
			fixed (byte* pvalues = &values)
			{
				fixed (byte* pminOut = &minOut)
				{
					ImMinMaxArrayNative((byte*)pvalues, count, (byte*)pminOut, maxOut);
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void ImMinMaxArray(byte* values, int count, byte* minOut, ref byte maxOut)
		{
			fixed (byte* pmaxOut = &maxOut)
			{
				ImMinMaxArrayNative(values, count, minOut, (byte*)pmaxOut);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void ImMinMaxArray(in byte values, int count, byte* minOut, ref byte maxOut)
		{
			fixed (byte* pvalues = &values)
			{
				fixed (byte* pmaxOut = &maxOut)
				{
					ImMinMaxArrayNative((byte*)pvalues, count, minOut, (byte*)pmaxOut);
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void ImMinMaxArray(byte* values, int count, ref byte minOut, ref byte maxOut)
		{
			fixed (byte* pminOut = &minOut)
			{
				fixed (byte* pmaxOut = &maxOut)
				{
					ImMinMaxArrayNative(values, count, (byte*)pminOut, (byte*)pmaxOut);
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void ImMinMaxArray(in byte values, int count, ref byte minOut, ref byte maxOut)
		{
			fixed (byte* pvalues = &values)
			{
				fixed (byte* pminOut = &minOut)
				{
					fixed (byte* pmaxOut = &maxOut)
					{
						ImMinMaxArrayNative((byte*)pvalues, count, (byte*)pminOut, (byte*)pmaxOut);
					}
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void ImMinMaxArrayNative(short* values, int count, short* minOut, short* maxOut)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<short*, int, short*, short*, void>)funcTable[445])(values, count, minOut, maxOut);
			#else
			((delegate* unmanaged[Cdecl]<nint, int, nint, nint, void>)funcTable[445])((nint)values, count, (nint)minOut, (nint)maxOut);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void ImMinMaxArray(short* values, int count, short* minOut, short* maxOut)
		{
			ImMinMaxArrayNative(values, count, minOut, maxOut);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void ImMinMaxArray(in short values, int count, short* minOut, short* maxOut)
		{
			fixed (short* pvalues = &values)
			{
				ImMinMaxArrayNative((short*)pvalues, count, minOut, maxOut);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void ImMinMaxArray(short* values, int count, ref short minOut, short* maxOut)
		{
			fixed (short* pminOut = &minOut)
			{
				ImMinMaxArrayNative(values, count, (short*)pminOut, maxOut);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void ImMinMaxArray(in short values, int count, ref short minOut, short* maxOut)
		{
			fixed (short* pvalues = &values)
			{
				fixed (short* pminOut = &minOut)
				{
					ImMinMaxArrayNative((short*)pvalues, count, (short*)pminOut, maxOut);
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void ImMinMaxArray(short* values, int count, short* minOut, ref short maxOut)
		{
			fixed (short* pmaxOut = &maxOut)
			{
				ImMinMaxArrayNative(values, count, minOut, (short*)pmaxOut);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void ImMinMaxArray(in short values, int count, short* minOut, ref short maxOut)
		{
			fixed (short* pvalues = &values)
			{
				fixed (short* pmaxOut = &maxOut)
				{
					ImMinMaxArrayNative((short*)pvalues, count, minOut, (short*)pmaxOut);
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void ImMinMaxArray(short* values, int count, ref short minOut, ref short maxOut)
		{
			fixed (short* pminOut = &minOut)
			{
				fixed (short* pmaxOut = &maxOut)
				{
					ImMinMaxArrayNative(values, count, (short*)pminOut, (short*)pmaxOut);
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void ImMinMaxArray(in short values, int count, ref short minOut, ref short maxOut)
		{
			fixed (short* pvalues = &values)
			{
				fixed (short* pminOut = &minOut)
				{
					fixed (short* pmaxOut = &maxOut)
					{
						ImMinMaxArrayNative((short*)pvalues, count, (short*)pminOut, (short*)pmaxOut);
					}
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void ImMinMaxArrayNative(ushort* values, int count, ushort* minOut, ushort* maxOut)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<ushort*, int, ushort*, ushort*, void>)funcTable[446])(values, count, minOut, maxOut);
			#else
			((delegate* unmanaged[Cdecl]<nint, int, nint, nint, void>)funcTable[446])((nint)values, count, (nint)minOut, (nint)maxOut);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void ImMinMaxArray(ushort* values, int count, ushort* minOut, ushort* maxOut)
		{
			ImMinMaxArrayNative(values, count, minOut, maxOut);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void ImMinMaxArray(in ushort values, int count, ushort* minOut, ushort* maxOut)
		{
			fixed (ushort* pvalues = &values)
			{
				ImMinMaxArrayNative((ushort*)pvalues, count, minOut, maxOut);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void ImMinMaxArray(ushort* values, int count, ref ushort minOut, ushort* maxOut)
		{
			fixed (ushort* pminOut = &minOut)
			{
				ImMinMaxArrayNative(values, count, (ushort*)pminOut, maxOut);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void ImMinMaxArray(in ushort values, int count, ref ushort minOut, ushort* maxOut)
		{
			fixed (ushort* pvalues = &values)
			{
				fixed (ushort* pminOut = &minOut)
				{
					ImMinMaxArrayNative((ushort*)pvalues, count, (ushort*)pminOut, maxOut);
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void ImMinMaxArray(ushort* values, int count, ushort* minOut, ref ushort maxOut)
		{
			fixed (ushort* pmaxOut = &maxOut)
			{
				ImMinMaxArrayNative(values, count, minOut, (ushort*)pmaxOut);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void ImMinMaxArray(in ushort values, int count, ushort* minOut, ref ushort maxOut)
		{
			fixed (ushort* pvalues = &values)
			{
				fixed (ushort* pmaxOut = &maxOut)
				{
					ImMinMaxArrayNative((ushort*)pvalues, count, minOut, (ushort*)pmaxOut);
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void ImMinMaxArray(ushort* values, int count, ref ushort minOut, ref ushort maxOut)
		{
			fixed (ushort* pminOut = &minOut)
			{
				fixed (ushort* pmaxOut = &maxOut)
				{
					ImMinMaxArrayNative(values, count, (ushort*)pminOut, (ushort*)pmaxOut);
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void ImMinMaxArray(in ushort values, int count, ref ushort minOut, ref ushort maxOut)
		{
			fixed (ushort* pvalues = &values)
			{
				fixed (ushort* pminOut = &minOut)
				{
					fixed (ushort* pmaxOut = &maxOut)
					{
						ImMinMaxArrayNative((ushort*)pvalues, count, (ushort*)pminOut, (ushort*)pmaxOut);
					}
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void ImMinMaxArrayNative(int* values, int count, int* minOut, int* maxOut)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<int*, int, int*, int*, void>)funcTable[447])(values, count, minOut, maxOut);
			#else
			((delegate* unmanaged[Cdecl]<nint, int, nint, nint, void>)funcTable[447])((nint)values, count, (nint)minOut, (nint)maxOut);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void ImMinMaxArray(int* values, int count, int* minOut, int* maxOut)
		{
			ImMinMaxArrayNative(values, count, minOut, maxOut);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void ImMinMaxArray(in int values, int count, int* minOut, int* maxOut)
		{
			fixed (int* pvalues = &values)
			{
				ImMinMaxArrayNative((int*)pvalues, count, minOut, maxOut);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void ImMinMaxArray(int* values, int count, ref int minOut, int* maxOut)
		{
			fixed (int* pminOut = &minOut)
			{
				ImMinMaxArrayNative(values, count, (int*)pminOut, maxOut);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void ImMinMaxArray(in int values, int count, ref int minOut, int* maxOut)
		{
			fixed (int* pvalues = &values)
			{
				fixed (int* pminOut = &minOut)
				{
					ImMinMaxArrayNative((int*)pvalues, count, (int*)pminOut, maxOut);
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void ImMinMaxArray(int* values, int count, int* minOut, ref int maxOut)
		{
			fixed (int* pmaxOut = &maxOut)
			{
				ImMinMaxArrayNative(values, count, minOut, (int*)pmaxOut);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void ImMinMaxArray(in int values, int count, int* minOut, ref int maxOut)
		{
			fixed (int* pvalues = &values)
			{
				fixed (int* pmaxOut = &maxOut)
				{
					ImMinMaxArrayNative((int*)pvalues, count, minOut, (int*)pmaxOut);
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void ImMinMaxArray(int* values, int count, ref int minOut, ref int maxOut)
		{
			fixed (int* pminOut = &minOut)
			{
				fixed (int* pmaxOut = &maxOut)
				{
					ImMinMaxArrayNative(values, count, (int*)pminOut, (int*)pmaxOut);
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void ImMinMaxArray(in int values, int count, ref int minOut, ref int maxOut)
		{
			fixed (int* pvalues = &values)
			{
				fixed (int* pminOut = &minOut)
				{
					fixed (int* pmaxOut = &maxOut)
					{
						ImMinMaxArrayNative((int*)pvalues, count, (int*)pminOut, (int*)pmaxOut);
					}
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void ImMinMaxArrayNative(uint* values, int count, uint* minOut, uint* maxOut)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint*, int, uint*, uint*, void>)funcTable[448])(values, count, minOut, maxOut);
			#else
			((delegate* unmanaged[Cdecl]<nint, int, nint, nint, void>)funcTable[448])((nint)values, count, (nint)minOut, (nint)maxOut);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void ImMinMaxArray(uint* values, int count, uint* minOut, uint* maxOut)
		{
			ImMinMaxArrayNative(values, count, minOut, maxOut);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void ImMinMaxArray(in uint values, int count, uint* minOut, uint* maxOut)
		{
			fixed (uint* pvalues = &values)
			{
				ImMinMaxArrayNative((uint*)pvalues, count, minOut, maxOut);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void ImMinMaxArray(uint* values, int count, ref uint minOut, uint* maxOut)
		{
			fixed (uint* pminOut = &minOut)
			{
				ImMinMaxArrayNative(values, count, (uint*)pminOut, maxOut);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void ImMinMaxArray(in uint values, int count, ref uint minOut, uint* maxOut)
		{
			fixed (uint* pvalues = &values)
			{
				fixed (uint* pminOut = &minOut)
				{
					ImMinMaxArrayNative((uint*)pvalues, count, (uint*)pminOut, maxOut);
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void ImMinMaxArray(uint* values, int count, uint* minOut, ref uint maxOut)
		{
			fixed (uint* pmaxOut = &maxOut)
			{
				ImMinMaxArrayNative(values, count, minOut, (uint*)pmaxOut);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void ImMinMaxArray(in uint values, int count, uint* minOut, ref uint maxOut)
		{
			fixed (uint* pvalues = &values)
			{
				fixed (uint* pmaxOut = &maxOut)
				{
					ImMinMaxArrayNative((uint*)pvalues, count, minOut, (uint*)pmaxOut);
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void ImMinMaxArray(uint* values, int count, ref uint minOut, ref uint maxOut)
		{
			fixed (uint* pminOut = &minOut)
			{
				fixed (uint* pmaxOut = &maxOut)
				{
					ImMinMaxArrayNative(values, count, (uint*)pminOut, (uint*)pmaxOut);
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void ImMinMaxArray(in uint values, int count, ref uint minOut, ref uint maxOut)
		{
			fixed (uint* pvalues = &values)
			{
				fixed (uint* pminOut = &minOut)
				{
					fixed (uint* pmaxOut = &maxOut)
					{
						ImMinMaxArrayNative((uint*)pvalues, count, (uint*)pminOut, (uint*)pmaxOut);
					}
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void ImMinMaxArrayNative(long* values, int count, long* minOut, long* maxOut)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<long*, int, long*, long*, void>)funcTable[449])(values, count, minOut, maxOut);
			#else
			((delegate* unmanaged[Cdecl]<nint, int, nint, nint, void>)funcTable[449])((nint)values, count, (nint)minOut, (nint)maxOut);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void ImMinMaxArray(long* values, int count, long* minOut, long* maxOut)
		{
			ImMinMaxArrayNative(values, count, minOut, maxOut);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void ImMinMaxArray(in long values, int count, long* minOut, long* maxOut)
		{
			fixed (long* pvalues = &values)
			{
				ImMinMaxArrayNative((long*)pvalues, count, minOut, maxOut);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void ImMinMaxArray(long* values, int count, ref long minOut, long* maxOut)
		{
			fixed (long* pminOut = &minOut)
			{
				ImMinMaxArrayNative(values, count, (long*)pminOut, maxOut);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void ImMinMaxArray(in long values, int count, ref long minOut, long* maxOut)
		{
			fixed (long* pvalues = &values)
			{
				fixed (long* pminOut = &minOut)
				{
					ImMinMaxArrayNative((long*)pvalues, count, (long*)pminOut, maxOut);
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void ImMinMaxArray(long* values, int count, long* minOut, ref long maxOut)
		{
			fixed (long* pmaxOut = &maxOut)
			{
				ImMinMaxArrayNative(values, count, minOut, (long*)pmaxOut);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void ImMinMaxArray(in long values, int count, long* minOut, ref long maxOut)
		{
			fixed (long* pvalues = &values)
			{
				fixed (long* pmaxOut = &maxOut)
				{
					ImMinMaxArrayNative((long*)pvalues, count, minOut, (long*)pmaxOut);
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void ImMinMaxArray(long* values, int count, ref long minOut, ref long maxOut)
		{
			fixed (long* pminOut = &minOut)
			{
				fixed (long* pmaxOut = &maxOut)
				{
					ImMinMaxArrayNative(values, count, (long*)pminOut, (long*)pmaxOut);
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void ImMinMaxArray(in long values, int count, ref long minOut, ref long maxOut)
		{
			fixed (long* pvalues = &values)
			{
				fixed (long* pminOut = &minOut)
				{
					fixed (long* pmaxOut = &maxOut)
					{
						ImMinMaxArrayNative((long*)pvalues, count, (long*)pminOut, (long*)pmaxOut);
					}
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void ImMinMaxArrayNative(ulong* values, int count, ulong* minOut, ulong* maxOut)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<ulong*, int, ulong*, ulong*, void>)funcTable[450])(values, count, minOut, maxOut);
			#else
			((delegate* unmanaged[Cdecl]<nint, int, nint, nint, void>)funcTable[450])((nint)values, count, (nint)minOut, (nint)maxOut);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void ImMinMaxArray(ulong* values, int count, ulong* minOut, ulong* maxOut)
		{
			ImMinMaxArrayNative(values, count, minOut, maxOut);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void ImMinMaxArray(in ulong values, int count, ulong* minOut, ulong* maxOut)
		{
			fixed (ulong* pvalues = &values)
			{
				ImMinMaxArrayNative((ulong*)pvalues, count, minOut, maxOut);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void ImMinMaxArray(ulong* values, int count, ref ulong minOut, ulong* maxOut)
		{
			fixed (ulong* pminOut = &minOut)
			{
				ImMinMaxArrayNative(values, count, (ulong*)pminOut, maxOut);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void ImMinMaxArray(in ulong values, int count, ref ulong minOut, ulong* maxOut)
		{
			fixed (ulong* pvalues = &values)
			{
				fixed (ulong* pminOut = &minOut)
				{
					ImMinMaxArrayNative((ulong*)pvalues, count, (ulong*)pminOut, maxOut);
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void ImMinMaxArray(ulong* values, int count, ulong* minOut, ref ulong maxOut)
		{
			fixed (ulong* pmaxOut = &maxOut)
			{
				ImMinMaxArrayNative(values, count, minOut, (ulong*)pmaxOut);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void ImMinMaxArray(in ulong values, int count, ulong* minOut, ref ulong maxOut)
		{
			fixed (ulong* pvalues = &values)
			{
				fixed (ulong* pmaxOut = &maxOut)
				{
					ImMinMaxArrayNative((ulong*)pvalues, count, minOut, (ulong*)pmaxOut);
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void ImMinMaxArray(ulong* values, int count, ref ulong minOut, ref ulong maxOut)
		{
			fixed (ulong* pminOut = &minOut)
			{
				fixed (ulong* pmaxOut = &maxOut)
				{
					ImMinMaxArrayNative(values, count, (ulong*)pminOut, (ulong*)pmaxOut);
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void ImMinMaxArray(in ulong values, int count, ref ulong minOut, ref ulong maxOut)
		{
			fixed (ulong* pvalues = &values)
			{
				fixed (ulong* pminOut = &minOut)
				{
					fixed (ulong* pmaxOut = &maxOut)
					{
						ImMinMaxArrayNative((ulong*)pvalues, count, (ulong*)pminOut, (ulong*)pmaxOut);
					}
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static float ImSumNative(float* values, int count)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<float*, int, float>)funcTable[451])(values, count);
			#else
			return (float)((delegate* unmanaged[Cdecl]<nint, int, float>)funcTable[451])((nint)values, count);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static float ImSum(float* values, int count)
		{
			float ret = ImSumNative(values, count);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static float ImSum(in float values, int count)
		{
			fixed (float* pvalues = &values)
			{
				float ret = ImSumNative((float*)pvalues, count);
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static double ImSumNative(double* values, int count)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<double*, int, double>)funcTable[452])(values, count);
			#else
			return (double)((delegate* unmanaged[Cdecl]<nint, int, double>)funcTable[452])((nint)values, count);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static double ImSum(double* values, int count)
		{
			double ret = ImSumNative(values, count);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static double ImSum(in double values, int count)
		{
			fixed (double* pvalues = &values)
			{
				double ret = ImSumNative((double*)pvalues, count);
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static sbyte ImSumNative(sbyte* values, int count)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<sbyte*, int, sbyte>)funcTable[453])(values, count);
			#else
			return (sbyte)((delegate* unmanaged[Cdecl]<nint, int, sbyte>)funcTable[453])((nint)values, count);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static sbyte ImSum(sbyte* values, int count)
		{
			sbyte ret = ImSumNative(values, count);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static sbyte ImSum(in sbyte values, int count)
		{
			fixed (sbyte* pvalues = &values)
			{
				sbyte ret = ImSumNative((sbyte*)pvalues, count);
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte ImSumNative(byte* values, int count)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<byte*, int, byte>)funcTable[454])(values, count);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<nint, int, byte>)funcTable[454])((nint)values, count);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static byte ImSum(byte* values, int count)
		{
			byte ret = ImSumNative(values, count);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static byte ImSum(in byte values, int count)
		{
			fixed (byte* pvalues = &values)
			{
				byte ret = ImSumNative((byte*)pvalues, count);
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static short ImSumNative(short* values, int count)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<short*, int, short>)funcTable[455])(values, count);
			#else
			return (short)((delegate* unmanaged[Cdecl]<nint, int, short>)funcTable[455])((nint)values, count);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static short ImSum(short* values, int count)
		{
			short ret = ImSumNative(values, count);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static short ImSum(in short values, int count)
		{
			fixed (short* pvalues = &values)
			{
				short ret = ImSumNative((short*)pvalues, count);
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static ushort ImSumNative(ushort* values, int count)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<ushort*, int, ushort>)funcTable[456])(values, count);
			#else
			return (ushort)((delegate* unmanaged[Cdecl]<nint, int, ushort>)funcTable[456])((nint)values, count);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static ushort ImSum(ushort* values, int count)
		{
			ushort ret = ImSumNative(values, count);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static ushort ImSum(in ushort values, int count)
		{
			fixed (ushort* pvalues = &values)
			{
				ushort ret = ImSumNative((ushort*)pvalues, count);
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int ImSumNative(int* values, int count)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<int*, int, int>)funcTable[457])(values, count);
			#else
			return (int)((delegate* unmanaged[Cdecl]<nint, int, int>)funcTable[457])((nint)values, count);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static int ImSum(int* values, int count)
		{
			int ret = ImSumNative(values, count);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static int ImSum(in int values, int count)
		{
			fixed (int* pvalues = &values)
			{
				int ret = ImSumNative((int*)pvalues, count);
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static uint ImSumNative(uint* values, int count)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<uint*, int, uint>)funcTable[458])(values, count);
			#else
			return (uint)((delegate* unmanaged[Cdecl]<nint, int, uint>)funcTable[458])((nint)values, count);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static uint ImSum(uint* values, int count)
		{
			uint ret = ImSumNative(values, count);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static uint ImSum(in uint values, int count)
		{
			fixed (uint* pvalues = &values)
			{
				uint ret = ImSumNative((uint*)pvalues, count);
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static long ImSumNative(long* values, int count)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<long*, int, long>)funcTable[459])(values, count);
			#else
			return (long)((delegate* unmanaged[Cdecl]<nint, int, long>)funcTable[459])((nint)values, count);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static long ImSum(long* values, int count)
		{
			long ret = ImSumNative(values, count);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static long ImSum(in long values, int count)
		{
			fixed (long* pvalues = &values)
			{
				long ret = ImSumNative((long*)pvalues, count);
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static ulong ImSumNative(ulong* values, int count)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<ulong*, int, ulong>)funcTable[460])(values, count);
			#else
			return (ulong)((delegate* unmanaged[Cdecl]<nint, int, ulong>)funcTable[460])((nint)values, count);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static ulong ImSum(ulong* values, int count)
		{
			ulong ret = ImSumNative(values, count);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static ulong ImSum(in ulong values, int count)
		{
			fixed (ulong* pvalues = &values)
			{
				ulong ret = ImSumNative((ulong*)pvalues, count);
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static double ImMeanNative(float* values, int count)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<float*, int, double>)funcTable[461])(values, count);
			#else
			return (double)((delegate* unmanaged[Cdecl]<nint, int, double>)funcTable[461])((nint)values, count);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static double ImMean(float* values, int count)
		{
			double ret = ImMeanNative(values, count);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static double ImMean(in float values, int count)
		{
			fixed (float* pvalues = &values)
			{
				double ret = ImMeanNative((float*)pvalues, count);
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static double ImMeanNative(double* values, int count)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<double*, int, double>)funcTable[462])(values, count);
			#else
			return (double)((delegate* unmanaged[Cdecl]<nint, int, double>)funcTable[462])((nint)values, count);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static double ImMean(double* values, int count)
		{
			double ret = ImMeanNative(values, count);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static double ImMean(in double values, int count)
		{
			fixed (double* pvalues = &values)
			{
				double ret = ImMeanNative((double*)pvalues, count);
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static double ImMeanNative(sbyte* values, int count)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<sbyte*, int, double>)funcTable[463])(values, count);
			#else
			return (double)((delegate* unmanaged[Cdecl]<nint, int, double>)funcTable[463])((nint)values, count);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static double ImMean(sbyte* values, int count)
		{
			double ret = ImMeanNative(values, count);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static double ImMean(in sbyte values, int count)
		{
			fixed (sbyte* pvalues = &values)
			{
				double ret = ImMeanNative((sbyte*)pvalues, count);
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static double ImMeanNative(byte* values, int count)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<byte*, int, double>)funcTable[464])(values, count);
			#else
			return (double)((delegate* unmanaged[Cdecl]<nint, int, double>)funcTable[464])((nint)values, count);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static double ImMean(byte* values, int count)
		{
			double ret = ImMeanNative(values, count);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static double ImMean(in byte values, int count)
		{
			fixed (byte* pvalues = &values)
			{
				double ret = ImMeanNative((byte*)pvalues, count);
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static double ImMeanNative(short* values, int count)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<short*, int, double>)funcTable[465])(values, count);
			#else
			return (double)((delegate* unmanaged[Cdecl]<nint, int, double>)funcTable[465])((nint)values, count);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static double ImMean(short* values, int count)
		{
			double ret = ImMeanNative(values, count);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static double ImMean(in short values, int count)
		{
			fixed (short* pvalues = &values)
			{
				double ret = ImMeanNative((short*)pvalues, count);
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static double ImMeanNative(ushort* values, int count)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<ushort*, int, double>)funcTable[466])(values, count);
			#else
			return (double)((delegate* unmanaged[Cdecl]<nint, int, double>)funcTable[466])((nint)values, count);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static double ImMean(ushort* values, int count)
		{
			double ret = ImMeanNative(values, count);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static double ImMean(in ushort values, int count)
		{
			fixed (ushort* pvalues = &values)
			{
				double ret = ImMeanNative((ushort*)pvalues, count);
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static double ImMeanNative(int* values, int count)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<int*, int, double>)funcTable[467])(values, count);
			#else
			return (double)((delegate* unmanaged[Cdecl]<nint, int, double>)funcTable[467])((nint)values, count);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static double ImMean(int* values, int count)
		{
			double ret = ImMeanNative(values, count);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static double ImMean(in int values, int count)
		{
			fixed (int* pvalues = &values)
			{
				double ret = ImMeanNative((int*)pvalues, count);
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static double ImMeanNative(uint* values, int count)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<uint*, int, double>)funcTable[468])(values, count);
			#else
			return (double)((delegate* unmanaged[Cdecl]<nint, int, double>)funcTable[468])((nint)values, count);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static double ImMean(uint* values, int count)
		{
			double ret = ImMeanNative(values, count);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static double ImMean(in uint values, int count)
		{
			fixed (uint* pvalues = &values)
			{
				double ret = ImMeanNative((uint*)pvalues, count);
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static double ImMeanNative(long* values, int count)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<long*, int, double>)funcTable[469])(values, count);
			#else
			return (double)((delegate* unmanaged[Cdecl]<nint, int, double>)funcTable[469])((nint)values, count);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static double ImMean(long* values, int count)
		{
			double ret = ImMeanNative(values, count);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static double ImMean(in long values, int count)
		{
			fixed (long* pvalues = &values)
			{
				double ret = ImMeanNative((long*)pvalues, count);
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static double ImMeanNative(ulong* values, int count)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<ulong*, int, double>)funcTable[470])(values, count);
			#else
			return (double)((delegate* unmanaged[Cdecl]<nint, int, double>)funcTable[470])((nint)values, count);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static double ImMean(ulong* values, int count)
		{
			double ret = ImMeanNative(values, count);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static double ImMean(in ulong values, int count)
		{
			fixed (ulong* pvalues = &values)
			{
				double ret = ImMeanNative((ulong*)pvalues, count);
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static double ImStdDevNative(float* values, int count)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<float*, int, double>)funcTable[471])(values, count);
			#else
			return (double)((delegate* unmanaged[Cdecl]<nint, int, double>)funcTable[471])((nint)values, count);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static double ImStdDev(float* values, int count)
		{
			double ret = ImStdDevNative(values, count);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static double ImStdDev(in float values, int count)
		{
			fixed (float* pvalues = &values)
			{
				double ret = ImStdDevNative((float*)pvalues, count);
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static double ImStdDevNative(double* values, int count)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<double*, int, double>)funcTable[472])(values, count);
			#else
			return (double)((delegate* unmanaged[Cdecl]<nint, int, double>)funcTable[472])((nint)values, count);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static double ImStdDev(double* values, int count)
		{
			double ret = ImStdDevNative(values, count);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static double ImStdDev(in double values, int count)
		{
			fixed (double* pvalues = &values)
			{
				double ret = ImStdDevNative((double*)pvalues, count);
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static double ImStdDevNative(sbyte* values, int count)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<sbyte*, int, double>)funcTable[473])(values, count);
			#else
			return (double)((delegate* unmanaged[Cdecl]<nint, int, double>)funcTable[473])((nint)values, count);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static double ImStdDev(sbyte* values, int count)
		{
			double ret = ImStdDevNative(values, count);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static double ImStdDev(in sbyte values, int count)
		{
			fixed (sbyte* pvalues = &values)
			{
				double ret = ImStdDevNative((sbyte*)pvalues, count);
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static double ImStdDevNative(byte* values, int count)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<byte*, int, double>)funcTable[474])(values, count);
			#else
			return (double)((delegate* unmanaged[Cdecl]<nint, int, double>)funcTable[474])((nint)values, count);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static double ImStdDev(byte* values, int count)
		{
			double ret = ImStdDevNative(values, count);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static double ImStdDev(in byte values, int count)
		{
			fixed (byte* pvalues = &values)
			{
				double ret = ImStdDevNative((byte*)pvalues, count);
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static double ImStdDevNative(short* values, int count)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<short*, int, double>)funcTable[475])(values, count);
			#else
			return (double)((delegate* unmanaged[Cdecl]<nint, int, double>)funcTable[475])((nint)values, count);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static double ImStdDev(short* values, int count)
		{
			double ret = ImStdDevNative(values, count);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static double ImStdDev(in short values, int count)
		{
			fixed (short* pvalues = &values)
			{
				double ret = ImStdDevNative((short*)pvalues, count);
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static double ImStdDevNative(ushort* values, int count)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<ushort*, int, double>)funcTable[476])(values, count);
			#else
			return (double)((delegate* unmanaged[Cdecl]<nint, int, double>)funcTable[476])((nint)values, count);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static double ImStdDev(ushort* values, int count)
		{
			double ret = ImStdDevNative(values, count);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static double ImStdDev(in ushort values, int count)
		{
			fixed (ushort* pvalues = &values)
			{
				double ret = ImStdDevNative((ushort*)pvalues, count);
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static double ImStdDevNative(int* values, int count)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<int*, int, double>)funcTable[477])(values, count);
			#else
			return (double)((delegate* unmanaged[Cdecl]<nint, int, double>)funcTable[477])((nint)values, count);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static double ImStdDev(int* values, int count)
		{
			double ret = ImStdDevNative(values, count);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static double ImStdDev(in int values, int count)
		{
			fixed (int* pvalues = &values)
			{
				double ret = ImStdDevNative((int*)pvalues, count);
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static double ImStdDevNative(uint* values, int count)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<uint*, int, double>)funcTable[478])(values, count);
			#else
			return (double)((delegate* unmanaged[Cdecl]<nint, int, double>)funcTable[478])((nint)values, count);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static double ImStdDev(uint* values, int count)
		{
			double ret = ImStdDevNative(values, count);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static double ImStdDev(in uint values, int count)
		{
			fixed (uint* pvalues = &values)
			{
				double ret = ImStdDevNative((uint*)pvalues, count);
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static double ImStdDevNative(long* values, int count)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<long*, int, double>)funcTable[479])(values, count);
			#else
			return (double)((delegate* unmanaged[Cdecl]<nint, int, double>)funcTable[479])((nint)values, count);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static double ImStdDev(long* values, int count)
		{
			double ret = ImStdDevNative(values, count);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static double ImStdDev(in long values, int count)
		{
			fixed (long* pvalues = &values)
			{
				double ret = ImStdDevNative((long*)pvalues, count);
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static double ImStdDevNative(ulong* values, int count)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<ulong*, int, double>)funcTable[480])(values, count);
			#else
			return (double)((delegate* unmanaged[Cdecl]<nint, int, double>)funcTable[480])((nint)values, count);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static double ImStdDev(ulong* values, int count)
		{
			double ret = ImStdDevNative(values, count);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static double ImStdDev(in ulong values, int count)
		{
			fixed (ulong* pvalues = &values)
			{
				double ret = ImStdDevNative((ulong*)pvalues, count);
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static uint ImMixU32Native(uint a, uint b, uint s)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<uint, uint, uint, uint>)funcTable[481])(a, b, s);
			#else
			return (uint)((delegate* unmanaged[Cdecl]<uint, uint, uint, uint>)funcTable[481])(a, b, s);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static uint ImMixU32(uint a, uint b, uint s)
		{
			uint ret = ImMixU32Native(a, b, s);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static uint ImLerpU32Native(uint* colors, int size, float t)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<uint*, int, float, uint>)funcTable[482])(colors, size, t);
			#else
			return (uint)((delegate* unmanaged[Cdecl]<nint, int, float, uint>)funcTable[482])((nint)colors, size, t);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static uint ImLerpU32(uint* colors, int size, float t)
		{
			uint ret = ImLerpU32Native(colors, size, t);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static uint ImLerpU32(in uint colors, int size, float t)
		{
			fixed (uint* pcolors = &colors)
			{
				uint ret = ImLerpU32Native((uint*)pcolors, size, t);
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static uint ImAlphaU32Native(uint col, float alpha)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<uint, float, uint>)funcTable[483])(col, alpha);
			#else
			return (uint)((delegate* unmanaged[Cdecl]<uint, float, uint>)funcTable[483])(col, alpha);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static uint ImAlphaU32(uint col, float alpha)
		{
			uint ret = ImAlphaU32Native(col, alpha);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte ImOverlapsNative(float minA, float maxA, float minB, float maxB)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<float, float, float, float, byte>)funcTable[484])(minA, maxA, minB, maxB);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<float, float, float, float, byte>)funcTable[484])(minA, maxA, minB, maxB);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool ImOverlaps(float minA, float maxA, float minB, float maxB)
		{
			byte ret = ImOverlapsNative(minA, maxA, minB, maxB);
			return ret != 0;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte ImOverlapsNative(double minA, double maxA, double minB, double maxB)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<double, double, double, double, byte>)funcTable[485])(minA, maxA, minB, maxB);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<double, double, double, double, byte>)funcTable[485])(minA, maxA, minB, maxB);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool ImOverlaps(double minA, double maxA, double minB, double maxB)
		{
			byte ret = ImOverlapsNative(minA, maxA, minB, maxB);
			return ret != 0;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte ImOverlapsNative(sbyte minA, sbyte maxA, sbyte minB, sbyte maxB)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<sbyte, sbyte, sbyte, sbyte, byte>)funcTable[486])(minA, maxA, minB, maxB);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<sbyte, sbyte, sbyte, sbyte, byte>)funcTable[486])(minA, maxA, minB, maxB);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool ImOverlaps(sbyte minA, sbyte maxA, sbyte minB, sbyte maxB)
		{
			byte ret = ImOverlapsNative(minA, maxA, minB, maxB);
			return ret != 0;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte ImOverlapsNative(byte minA, byte maxA, byte minB, byte maxB)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<byte, byte, byte, byte, byte>)funcTable[487])(minA, maxA, minB, maxB);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<byte, byte, byte, byte, byte>)funcTable[487])(minA, maxA, minB, maxB);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool ImOverlaps(byte minA, byte maxA, byte minB, byte maxB)
		{
			byte ret = ImOverlapsNative(minA, maxA, minB, maxB);
			return ret != 0;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte ImOverlapsNative(short minA, short maxA, short minB, short maxB)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<short, short, short, short, byte>)funcTable[488])(minA, maxA, minB, maxB);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<short, short, short, short, byte>)funcTable[488])(minA, maxA, minB, maxB);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool ImOverlaps(short minA, short maxA, short minB, short maxB)
		{
			byte ret = ImOverlapsNative(minA, maxA, minB, maxB);
			return ret != 0;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte ImOverlapsNative(ushort minA, ushort maxA, ushort minB, ushort maxB)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<ushort, ushort, ushort, ushort, byte>)funcTable[489])(minA, maxA, minB, maxB);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<ushort, ushort, ushort, ushort, byte>)funcTable[489])(minA, maxA, minB, maxB);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool ImOverlaps(ushort minA, ushort maxA, ushort minB, ushort maxB)
		{
			byte ret = ImOverlapsNative(minA, maxA, minB, maxB);
			return ret != 0;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte ImOverlapsNative(int minA, int maxA, int minB, int maxB)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<int, int, int, int, byte>)funcTable[490])(minA, maxA, minB, maxB);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<int, int, int, int, byte>)funcTable[490])(minA, maxA, minB, maxB);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool ImOverlaps(int minA, int maxA, int minB, int maxB)
		{
			byte ret = ImOverlapsNative(minA, maxA, minB, maxB);
			return ret != 0;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte ImOverlapsNative(uint minA, uint maxA, uint minB, uint maxB)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<uint, uint, uint, uint, byte>)funcTable[491])(minA, maxA, minB, maxB);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<uint, uint, uint, uint, byte>)funcTable[491])(minA, maxA, minB, maxB);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool ImOverlaps(uint minA, uint maxA, uint minB, uint maxB)
		{
			byte ret = ImOverlapsNative(minA, maxA, minB, maxB);
			return ret != 0;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte ImOverlapsNative(long minA, long maxA, long minB, long maxB)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<long, long, long, long, byte>)funcTable[492])(minA, maxA, minB, maxB);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<long, long, long, long, byte>)funcTable[492])(minA, maxA, minB, maxB);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool ImOverlaps(long minA, long maxA, long minB, long maxB)
		{
			byte ret = ImOverlapsNative(minA, maxA, minB, maxB);
			return ret != 0;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte ImOverlapsNative(ulong minA, ulong maxA, ulong minB, ulong maxB)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<ulong, ulong, ulong, ulong, byte>)funcTable[493])(minA, maxA, minB, maxB);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<ulong, ulong, ulong, ulong, byte>)funcTable[493])(minA, maxA, minB, maxB);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool ImOverlaps(ulong minA, ulong maxA, ulong minB, ulong maxB)
		{
			byte ret = ImOverlapsNative(minA, maxA, minB, maxB);
			return ret != 0;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static ImPlotDateTimeSpec* ImPlotDateTimeSpecNative()
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<ImPlotDateTimeSpec*>)funcTable[494])();
			#else
			return (ImPlotDateTimeSpec*)((delegate* unmanaged[Cdecl]<nint>)funcTable[494])();
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static ImPlotDateTimeSpecPtr ImPlotDateTimeSpec()
		{
			ImPlotDateTimeSpecPtr ret = ImPlotDateTimeSpecNative();
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void DestroyNative(ImPlotDateTimeSpec* self)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<ImPlotDateTimeSpec*, void>)funcTable[495])(self);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)funcTable[495])((nint)self);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void Destroy(ImPlotDateTimeSpecPtr self)
		{
			DestroyNative((ImPlotDateTimeSpec*)self);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void Destroy(ref ImPlotDateTimeSpec self)
		{
			fixed (ImPlotDateTimeSpec* pself = &self)
			{
				DestroyNative((ImPlotDateTimeSpec*)pself);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static ImPlotDateTimeSpec* ImPlotDateTimeSpecNative(ImPlotDateFmt dateFmt, ImPlotTimeFmt timeFmt, byte use24HrClk, byte useIso8601)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<ImPlotDateFmt, ImPlotTimeFmt, byte, byte, ImPlotDateTimeSpec*>)funcTable[496])(dateFmt, timeFmt, use24HrClk, useIso8601);
			#else
			return (ImPlotDateTimeSpec*)((delegate* unmanaged[Cdecl]<ImPlotDateFmt, ImPlotTimeFmt, byte, byte, nint>)funcTable[496])(dateFmt, timeFmt, use24HrClk, useIso8601);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static ImPlotDateTimeSpecPtr ImPlotDateTimeSpec(ImPlotDateFmt dateFmt, ImPlotTimeFmt timeFmt, bool use24HrClk, bool useIso8601)
		{
			ImPlotDateTimeSpecPtr ret = ImPlotDateTimeSpecNative(dateFmt, timeFmt, use24HrClk ? (byte)1 : (byte)0, useIso8601 ? (byte)1 : (byte)0);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static ImPlotDateTimeSpecPtr ImPlotDateTimeSpec(ImPlotDateFmt dateFmt, ImPlotTimeFmt timeFmt, bool use24HrClk)
		{
			ImPlotDateTimeSpecPtr ret = ImPlotDateTimeSpecNative(dateFmt, timeFmt, use24HrClk ? (byte)1 : (byte)0, (byte)(0));
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static ImPlotDateTimeSpecPtr ImPlotDateTimeSpec(ImPlotDateFmt dateFmt, ImPlotTimeFmt timeFmt)
		{
			ImPlotDateTimeSpecPtr ret = ImPlotDateTimeSpecNative(dateFmt, timeFmt, (byte)(0), (byte)(0));
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static ImPlotTime* ImPlotTimeNative()
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<ImPlotTime*>)funcTable[497])();
			#else
			return (ImPlotTime*)((delegate* unmanaged[Cdecl]<nint>)funcTable[497])();
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static ImPlotTimePtr ImPlotTime()
		{
			ImPlotTimePtr ret = ImPlotTimeNative();
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void DestroyNative(ImPlotTime* self)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<ImPlotTime*, void>)funcTable[498])(self);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)funcTable[498])((nint)self);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void Destroy(ImPlotTimePtr self)
		{
			DestroyNative((ImPlotTime*)self);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void Destroy(ref ImPlotTime self)
		{
			fixed (ImPlotTime* pself = &self)
			{
				DestroyNative((ImPlotTime*)pself);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static ImPlotTime* ImPlotTimeNative(long s, int us)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<long, int, ImPlotTime*>)funcTable[499])(s, us);
			#else
			return (ImPlotTime*)((delegate* unmanaged[Cdecl]<long, int, nint>)funcTable[499])(s, us);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static ImPlotTimePtr ImPlotTime(long s, int us)
		{
			ImPlotTimePtr ret = ImPlotTimeNative(s, us);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static ImPlotTimePtr ImPlotTime(long s)
		{
			ImPlotTimePtr ret = ImPlotTimeNative(s, (int)(0));
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void RollOverNative(ImPlotTime* self)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<ImPlotTime*, void>)funcTable[500])(self);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)funcTable[500])((nint)self);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void RollOver(ImPlotTimePtr self)
		{
			RollOverNative((ImPlotTime*)self);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void RollOver(ref ImPlotTime self)
		{
			fixed (ImPlotTime* pself = &self)
			{
				RollOverNative((ImPlotTime*)pself);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static double ToDoubleNative(ImPlotTime* self)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<ImPlotTime*, double>)funcTable[501])(self);
			#else
			return (double)((delegate* unmanaged[Cdecl]<nint, double>)funcTable[501])((nint)self);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static double ToDouble(ImPlotTimePtr self)
		{
			double ret = ToDoubleNative((ImPlotTime*)self);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static double ToDouble(ref ImPlotTime self)
		{
			fixed (ImPlotTime* pself = &self)
			{
				double ret = ToDoubleNative((ImPlotTime*)pself);
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void FromDoubleNative(ImPlotTime* pOut, double t)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<ImPlotTime*, double, void>)funcTable[502])(pOut, t);
			#else
			((delegate* unmanaged[Cdecl]<nint, double, void>)funcTable[502])((nint)pOut, t);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static ImPlotTime FromDouble(double t)
		{
			ImPlotTime ret;
			FromDoubleNative(&ret, t);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void FromDouble(ImPlotTimePtr pOut, double t)
		{
			FromDoubleNative((ImPlotTime*)pOut, t);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void FromDouble(ref ImPlotTime pOut, double t)
		{
			fixed (ImPlotTime* ppOut = &pOut)
			{
				FromDoubleNative((ImPlotTime*)ppOut, t);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static ImPlotColormapData* ImPlotColormapDataNative()
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<ImPlotColormapData*>)funcTable[503])();
			#else
			return (ImPlotColormapData*)((delegate* unmanaged[Cdecl]<nint>)funcTable[503])();
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static ImPlotColormapDataPtr ImPlotColormapData()
		{
			ImPlotColormapDataPtr ret = ImPlotColormapDataNative();
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void DestroyNative(ImPlotColormapData* self)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<ImPlotColormapData*, void>)funcTable[504])(self);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)funcTable[504])((nint)self);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void Destroy(ImPlotColormapDataPtr self)
		{
			DestroyNative((ImPlotColormapData*)self);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void Destroy(ref ImPlotColormapData self)
		{
			fixed (ImPlotColormapData* pself = &self)
			{
				DestroyNative((ImPlotColormapData*)pself);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int AppendNative(ImPlotColormapData* self, byte* name, uint* keys, int count, byte qual)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<ImPlotColormapData*, byte*, uint*, int, byte, int>)funcTable[505])(self, name, keys, count, qual);
			#else
			return (int)((delegate* unmanaged[Cdecl]<nint, nint, nint, int, byte, int>)funcTable[505])((nint)self, (nint)name, (nint)keys, count, qual);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static int Append(ImPlotColormapDataPtr self, byte* name, uint* keys, int count, bool qual)
		{
			int ret = AppendNative((ImPlotColormapData*)self, name, keys, count, qual ? (byte)1 : (byte)0);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static int Append(ref ImPlotColormapData self, byte* name, uint* keys, int count, bool qual)
		{
			fixed (ImPlotColormapData* pself = &self)
			{
				int ret = AppendNative((ImPlotColormapData*)pself, name, keys, count, qual ? (byte)1 : (byte)0);
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static int Append(ImPlotColormapDataPtr self, in byte name, uint* keys, int count, bool qual)
		{
			fixed (byte* pname = &name)
			{
				int ret = AppendNative((ImPlotColormapData*)self, (byte*)pname, keys, count, qual ? (byte)1 : (byte)0);
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static int Append(ImPlotColormapDataPtr self, ReadOnlySpan<byte> name, uint* keys, int count, bool qual)
		{
			fixed (byte* pname = name)
			{
				int ret = AppendNative((ImPlotColormapData*)self, (byte*)pname, keys, count, qual ? (byte)1 : (byte)0);
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static int Append(ImPlotColormapDataPtr self, string name, uint* keys, int count, bool qual)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (name != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(name);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(name, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			int ret = AppendNative((ImPlotColormapData*)self, pStr0, keys, count, qual ? (byte)1 : (byte)0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static int Append(ref ImPlotColormapData self, in byte name, uint* keys, int count, bool qual)
		{
			fixed (ImPlotColormapData* pself = &self)
			{
				fixed (byte* pname = &name)
				{
					int ret = AppendNative((ImPlotColormapData*)pself, (byte*)pname, keys, count, qual ? (byte)1 : (byte)0);
					return ret;
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static int Append(ref ImPlotColormapData self, ReadOnlySpan<byte> name, uint* keys, int count, bool qual)
		{
			fixed (ImPlotColormapData* pself = &self)
			{
				fixed (byte* pname = name)
				{
					int ret = AppendNative((ImPlotColormapData*)pself, (byte*)pname, keys, count, qual ? (byte)1 : (byte)0);
					return ret;
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static int Append(ref ImPlotColormapData self, string name, uint* keys, int count, bool qual)
		{
			fixed (ImPlotColormapData* pself = &self)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (name != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(name);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(name, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				int ret = AppendNative((ImPlotColormapData*)pself, pStr0, keys, count, qual ? (byte)1 : (byte)0);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static int Append(ImPlotColormapDataPtr self, byte* name, in uint keys, int count, bool qual)
		{
			fixed (uint* pkeys = &keys)
			{
				int ret = AppendNative((ImPlotColormapData*)self, name, (uint*)pkeys, count, qual ? (byte)1 : (byte)0);
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static int Append(ref ImPlotColormapData self, byte* name, in uint keys, int count, bool qual)
		{
			fixed (ImPlotColormapData* pself = &self)
			{
				fixed (uint* pkeys = &keys)
				{
					int ret = AppendNative((ImPlotColormapData*)pself, name, (uint*)pkeys, count, qual ? (byte)1 : (byte)0);
					return ret;
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static int Append(ImPlotColormapDataPtr self, in byte name, in uint keys, int count, bool qual)
		{
			fixed (byte* pname = &name)
			{
				fixed (uint* pkeys = &keys)
				{
					int ret = AppendNative((ImPlotColormapData*)self, (byte*)pname, (uint*)pkeys, count, qual ? (byte)1 : (byte)0);
					return ret;
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static int Append(ImPlotColormapDataPtr self, ReadOnlySpan<byte> name, in uint keys, int count, bool qual)
		{
			fixed (byte* pname = name)
			{
				fixed (uint* pkeys = &keys)
				{
					int ret = AppendNative((ImPlotColormapData*)self, (byte*)pname, (uint*)pkeys, count, qual ? (byte)1 : (byte)0);
					return ret;
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static int Append(ImPlotColormapDataPtr self, string name, in uint keys, int count, bool qual)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (name != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(name);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(name, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (uint* pkeys = &keys)
			{
				int ret = AppendNative((ImPlotColormapData*)self, pStr0, (uint*)pkeys, count, qual ? (byte)1 : (byte)0);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static int Append(ref ImPlotColormapData self, in byte name, in uint keys, int count, bool qual)
		{
			fixed (ImPlotColormapData* pself = &self)
			{
				fixed (byte* pname = &name)
				{
					fixed (uint* pkeys = &keys)
					{
						int ret = AppendNative((ImPlotColormapData*)pself, (byte*)pname, (uint*)pkeys, count, qual ? (byte)1 : (byte)0);
						return ret;
					}
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static int Append(ref ImPlotColormapData self, ReadOnlySpan<byte> name, in uint keys, int count, bool qual)
		{
			fixed (ImPlotColormapData* pself = &self)
			{
				fixed (byte* pname = name)
				{
					fixed (uint* pkeys = &keys)
					{
						int ret = AppendNative((ImPlotColormapData*)pself, (byte*)pname, (uint*)pkeys, count, qual ? (byte)1 : (byte)0);
						return ret;
					}
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static int Append(ref ImPlotColormapData self, string name, in uint keys, int count, bool qual)
		{
			fixed (ImPlotColormapData* pself = &self)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (name != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(name);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(name, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				fixed (uint* pkeys = &keys)
				{
					int ret = AppendNative((ImPlotColormapData*)pself, pStr0, (uint*)pkeys, count, qual ? (byte)1 : (byte)0);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
					return ret;
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void _AppendTableNative(ImPlotColormapData* self, ImPlotColormap cmap)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<ImPlotColormapData*, ImPlotColormap, void>)funcTable[506])(self, cmap);
			#else
			((delegate* unmanaged[Cdecl]<nint, ImPlotColormap, void>)funcTable[506])((nint)self, cmap);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void _AppendTable(ImPlotColormapDataPtr self, ImPlotColormap cmap)
		{
			_AppendTableNative((ImPlotColormapData*)self, cmap);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void _AppendTable(ref ImPlotColormapData self, ImPlotColormap cmap)
		{
			fixed (ImPlotColormapData* pself = &self)
			{
				_AppendTableNative((ImPlotColormapData*)pself, cmap);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void RebuildTablesNative(ImPlotColormapData* self)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<ImPlotColormapData*, void>)funcTable[507])(self);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)funcTable[507])((nint)self);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void RebuildTables(ImPlotColormapDataPtr self)
		{
			RebuildTablesNative((ImPlotColormapData*)self);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void RebuildTables(ref ImPlotColormapData self)
		{
			fixed (ImPlotColormapData* pself = &self)
			{
				RebuildTablesNative((ImPlotColormapData*)pself);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte IsQualNative(ImPlotColormapData* self, ImPlotColormap cmap)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<ImPlotColormapData*, ImPlotColormap, byte>)funcTable[508])(self, cmap);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<nint, ImPlotColormap, byte>)funcTable[508])((nint)self, cmap);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool IsQual(ImPlotColormapDataPtr self, ImPlotColormap cmap)
		{
			byte ret = IsQualNative((ImPlotColormapData*)self, cmap);
			return ret != 0;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool IsQual(ref ImPlotColormapData self, ImPlotColormap cmap)
		{
			fixed (ImPlotColormapData* pself = &self)
			{
				byte ret = IsQualNative((ImPlotColormapData*)pself, cmap);
				return ret != 0;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte* GetNameNative(ImPlotColormapData* self, ImPlotColormap cmap)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<ImPlotColormapData*, ImPlotColormap, byte*>)funcTable[509])(self, cmap);
			#else
			return (byte*)((delegate* unmanaged[Cdecl]<nint, ImPlotColormap, nint>)funcTable[509])((nint)self, cmap);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static byte* GetName(ImPlotColormapDataPtr self, ImPlotColormap cmap)
		{
			byte* ret = GetNameNative((ImPlotColormapData*)self, cmap);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static string GetNameS(ImPlotColormapDataPtr self, ImPlotColormap cmap)
		{
			string ret = Utils.DecodeStringUTF8(GetNameNative((ImPlotColormapData*)self, cmap));
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static byte* GetName(ref ImPlotColormapData self, ImPlotColormap cmap)
		{
			fixed (ImPlotColormapData* pself = &self)
			{
				byte* ret = GetNameNative((ImPlotColormapData*)pself, cmap);
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static string GetNameS(ref ImPlotColormapData self, ImPlotColormap cmap)
		{
			fixed (ImPlotColormapData* pself = &self)
			{
				string ret = Utils.DecodeStringUTF8(GetNameNative((ImPlotColormapData*)pself, cmap));
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static ImPlotColormap GetIndexNative(ImPlotColormapData* self, byte* name)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<ImPlotColormapData*, byte*, ImPlotColormap>)funcTable[510])(self, name);
			#else
			return (ImPlotColormap)((delegate* unmanaged[Cdecl]<nint, nint, ImPlotColormap>)funcTable[510])((nint)self, (nint)name);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static ImPlotColormap GetIndex(ImPlotColormapDataPtr self, byte* name)
		{
			ImPlotColormap ret = GetIndexNative((ImPlotColormapData*)self, name);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static ImPlotColormap GetIndex(ref ImPlotColormapData self, byte* name)
		{
			fixed (ImPlotColormapData* pself = &self)
			{
				ImPlotColormap ret = GetIndexNative((ImPlotColormapData*)pself, name);
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static ImPlotColormap GetIndex(ImPlotColormapDataPtr self, in byte name)
		{
			fixed (byte* pname = &name)
			{
				ImPlotColormap ret = GetIndexNative((ImPlotColormapData*)self, (byte*)pname);
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static ImPlotColormap GetIndex(ImPlotColormapDataPtr self, ReadOnlySpan<byte> name)
		{
			fixed (byte* pname = name)
			{
				ImPlotColormap ret = GetIndexNative((ImPlotColormapData*)self, (byte*)pname);
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static ImPlotColormap GetIndex(ImPlotColormapDataPtr self, string name)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (name != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(name);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(name, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			ImPlotColormap ret = GetIndexNative((ImPlotColormapData*)self, pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static ImPlotColormap GetIndex(ref ImPlotColormapData self, in byte name)
		{
			fixed (ImPlotColormapData* pself = &self)
			{
				fixed (byte* pname = &name)
				{
					ImPlotColormap ret = GetIndexNative((ImPlotColormapData*)pself, (byte*)pname);
					return ret;
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static ImPlotColormap GetIndex(ref ImPlotColormapData self, ReadOnlySpan<byte> name)
		{
			fixed (ImPlotColormapData* pself = &self)
			{
				fixed (byte* pname = name)
				{
					ImPlotColormap ret = GetIndexNative((ImPlotColormapData*)pself, (byte*)pname);
					return ret;
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static ImPlotColormap GetIndex(ref ImPlotColormapData self, string name)
		{
			fixed (ImPlotColormapData* pself = &self)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (name != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(name);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(name, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				ImPlotColormap ret = GetIndexNative((ImPlotColormapData*)pself, pStr0);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static uint* GetKeysNative(ImPlotColormapData* self, ImPlotColormap cmap)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<ImPlotColormapData*, ImPlotColormap, uint*>)funcTable[511])(self, cmap);
			#else
			return (uint*)((delegate* unmanaged[Cdecl]<nint, ImPlotColormap, nint>)funcTable[511])((nint)self, cmap);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static uint* GetKeys(ImPlotColormapDataPtr self, ImPlotColormap cmap)
		{
			uint* ret = GetKeysNative((ImPlotColormapData*)self, cmap);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static uint* GetKeys(ref ImPlotColormapData self, ImPlotColormap cmap)
		{
			fixed (ImPlotColormapData* pself = &self)
			{
				uint* ret = GetKeysNative((ImPlotColormapData*)pself, cmap);
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int GetKeyCountNative(ImPlotColormapData* self, ImPlotColormap cmap)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<ImPlotColormapData*, ImPlotColormap, int>)funcTable[512])(self, cmap);
			#else
			return (int)((delegate* unmanaged[Cdecl]<nint, ImPlotColormap, int>)funcTable[512])((nint)self, cmap);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static int GetKeyCount(ImPlotColormapDataPtr self, ImPlotColormap cmap)
		{
			int ret = GetKeyCountNative((ImPlotColormapData*)self, cmap);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static int GetKeyCount(ref ImPlotColormapData self, ImPlotColormap cmap)
		{
			fixed (ImPlotColormapData* pself = &self)
			{
				int ret = GetKeyCountNative((ImPlotColormapData*)pself, cmap);
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static uint GetKeyColorNative(ImPlotColormapData* self, ImPlotColormap cmap, int idx)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<ImPlotColormapData*, ImPlotColormap, int, uint>)funcTable[513])(self, cmap, idx);
			#else
			return (uint)((delegate* unmanaged[Cdecl]<nint, ImPlotColormap, int, uint>)funcTable[513])((nint)self, cmap, idx);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static uint GetKeyColor(ImPlotColormapDataPtr self, ImPlotColormap cmap, int idx)
		{
			uint ret = GetKeyColorNative((ImPlotColormapData*)self, cmap, idx);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static uint GetKeyColor(ref ImPlotColormapData self, ImPlotColormap cmap, int idx)
		{
			fixed (ImPlotColormapData* pself = &self)
			{
				uint ret = GetKeyColorNative((ImPlotColormapData*)pself, cmap, idx);
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void SetKeyColorNative(ImPlotColormapData* self, ImPlotColormap cmap, int idx, uint value)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<ImPlotColormapData*, ImPlotColormap, int, uint, void>)funcTable[514])(self, cmap, idx, value);
			#else
			((delegate* unmanaged[Cdecl]<nint, ImPlotColormap, int, uint, void>)funcTable[514])((nint)self, cmap, idx, value);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void SetKeyColor(ImPlotColormapDataPtr self, ImPlotColormap cmap, int idx, uint value)
		{
			SetKeyColorNative((ImPlotColormapData*)self, cmap, idx, value);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void SetKeyColor(ref ImPlotColormapData self, ImPlotColormap cmap, int idx, uint value)
		{
			fixed (ImPlotColormapData* pself = &self)
			{
				SetKeyColorNative((ImPlotColormapData*)pself, cmap, idx, value);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static uint* GetTableNative(ImPlotColormapData* self, ImPlotColormap cmap)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<ImPlotColormapData*, ImPlotColormap, uint*>)funcTable[515])(self, cmap);
			#else
			return (uint*)((delegate* unmanaged[Cdecl]<nint, ImPlotColormap, nint>)funcTable[515])((nint)self, cmap);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static uint* GetTable(ImPlotColormapDataPtr self, ImPlotColormap cmap)
		{
			uint* ret = GetTableNative((ImPlotColormapData*)self, cmap);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static uint* GetTable(ref ImPlotColormapData self, ImPlotColormap cmap)
		{
			fixed (ImPlotColormapData* pself = &self)
			{
				uint* ret = GetTableNative((ImPlotColormapData*)pself, cmap);
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int GetTableSizeNative(ImPlotColormapData* self, ImPlotColormap cmap)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<ImPlotColormapData*, ImPlotColormap, int>)funcTable[516])(self, cmap);
			#else
			return (int)((delegate* unmanaged[Cdecl]<nint, ImPlotColormap, int>)funcTable[516])((nint)self, cmap);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static int GetTableSize(ImPlotColormapDataPtr self, ImPlotColormap cmap)
		{
			int ret = GetTableSizeNative((ImPlotColormapData*)self, cmap);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static int GetTableSize(ref ImPlotColormapData self, ImPlotColormap cmap)
		{
			fixed (ImPlotColormapData* pself = &self)
			{
				int ret = GetTableSizeNative((ImPlotColormapData*)pself, cmap);
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static uint GetTableColorNative(ImPlotColormapData* self, ImPlotColormap cmap, int idx)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<ImPlotColormapData*, ImPlotColormap, int, uint>)funcTable[517])(self, cmap, idx);
			#else
			return (uint)((delegate* unmanaged[Cdecl]<nint, ImPlotColormap, int, uint>)funcTable[517])((nint)self, cmap, idx);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static uint GetTableColor(ImPlotColormapDataPtr self, ImPlotColormap cmap, int idx)
		{
			uint ret = GetTableColorNative((ImPlotColormapData*)self, cmap, idx);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static uint GetTableColor(ref ImPlotColormapData self, ImPlotColormap cmap, int idx)
		{
			fixed (ImPlotColormapData* pself = &self)
			{
				uint ret = GetTableColorNative((ImPlotColormapData*)pself, cmap, idx);
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static uint LerpTableNative(ImPlotColormapData* self, ImPlotColormap cmap, float t)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<ImPlotColormapData*, ImPlotColormap, float, uint>)funcTable[518])(self, cmap, t);
			#else
			return (uint)((delegate* unmanaged[Cdecl]<nint, ImPlotColormap, float, uint>)funcTable[518])((nint)self, cmap, t);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static uint LerpTable(ImPlotColormapDataPtr self, ImPlotColormap cmap, float t)
		{
			uint ret = LerpTableNative((ImPlotColormapData*)self, cmap, t);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static uint LerpTable(ref ImPlotColormapData self, ImPlotColormap cmap, float t)
		{
			fixed (ImPlotColormapData* pself = &self)
			{
				uint ret = LerpTableNative((ImPlotColormapData*)pself, cmap, t);
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static ImPlotPointError* ImPlotPointErrorNative(double x, double y, double neg, double pos)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<double, double, double, double, ImPlotPointError*>)funcTable[519])(x, y, neg, pos);
			#else
			return (ImPlotPointError*)((delegate* unmanaged[Cdecl]<double, double, double, double, nint>)funcTable[519])(x, y, neg, pos);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static ImPlotPointErrorPtr ImPlotPointError(double x, double y, double neg, double pos)
		{
			ImPlotPointErrorPtr ret = ImPlotPointErrorNative(x, y, neg, pos);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void DestroyNative(ImPlotPointError* self)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<ImPlotPointError*, void>)funcTable[520])(self);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)funcTable[520])((nint)self);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void Destroy(ImPlotPointErrorPtr self)
		{
			DestroyNative((ImPlotPointError*)self);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void Destroy(ref ImPlotPointError self)
		{
			fixed (ImPlotPointError* pself = &self)
			{
				DestroyNative((ImPlotPointError*)pself);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static ImPlotAnnotation* ImPlotAnnotationNative()
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<ImPlotAnnotation*>)funcTable[521])();
			#else
			return (ImPlotAnnotation*)((delegate* unmanaged[Cdecl]<nint>)funcTable[521])();
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static ImPlotAnnotationPtr ImPlotAnnotation()
		{
			ImPlotAnnotationPtr ret = ImPlotAnnotationNative();
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void DestroyNative(ImPlotAnnotation* self)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<ImPlotAnnotation*, void>)funcTable[522])(self);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)funcTable[522])((nint)self);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void Destroy(ImPlotAnnotationPtr self)
		{
			DestroyNative((ImPlotAnnotation*)self);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void Destroy(ref ImPlotAnnotation self)
		{
			fixed (ImPlotAnnotation* pself = &self)
			{
				DestroyNative((ImPlotAnnotation*)pself);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static ImPlotAnnotationCollection* ImPlotAnnotationCollectionNative()
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<ImPlotAnnotationCollection*>)funcTable[523])();
			#else
			return (ImPlotAnnotationCollection*)((delegate* unmanaged[Cdecl]<nint>)funcTable[523])();
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static ImPlotAnnotationCollectionPtr ImPlotAnnotationCollection()
		{
			ImPlotAnnotationCollectionPtr ret = ImPlotAnnotationCollectionNative();
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void DestroyNative(ImPlotAnnotationCollection* self)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<ImPlotAnnotationCollection*, void>)funcTable[524])(self);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)funcTable[524])((nint)self);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void Destroy(ImPlotAnnotationCollectionPtr self)
		{
			DestroyNative((ImPlotAnnotationCollection*)self);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void Destroy(ref ImPlotAnnotationCollection self)
		{
			fixed (ImPlotAnnotationCollection* pself = &self)
			{
				DestroyNative((ImPlotAnnotationCollection*)pself);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void AppendVNative(ImPlotAnnotationCollection* self, Vector2 pos, Vector2 off, uint bg, uint fg, byte clamp, byte* fmt, nuint args)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<ImPlotAnnotationCollection*, Vector2, Vector2, uint, uint, byte, byte*, nuint, void>)funcTable[525])(self, pos, off, bg, fg, clamp, fmt, args);
			#else
			((delegate* unmanaged[Cdecl]<nint, Vector2, Vector2, uint, uint, byte, nint, nuint, void>)funcTable[525])((nint)self, pos, off, bg, fg, clamp, (nint)fmt, args);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void AppendV(ImPlotAnnotationCollectionPtr self, Vector2 pos, Vector2 off, uint bg, uint fg, bool clamp, byte* fmt, nuint args)
		{
			AppendVNative((ImPlotAnnotationCollection*)self, pos, off, bg, fg, clamp ? (byte)1 : (byte)0, fmt, args);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void AppendV(ref ImPlotAnnotationCollection self, Vector2 pos, Vector2 off, uint bg, uint fg, bool clamp, byte* fmt, nuint args)
		{
			fixed (ImPlotAnnotationCollection* pself = &self)
			{
				AppendVNative((ImPlotAnnotationCollection*)pself, pos, off, bg, fg, clamp ? (byte)1 : (byte)0, fmt, args);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void AppendV(ImPlotAnnotationCollectionPtr self, Vector2 pos, Vector2 off, uint bg, uint fg, bool clamp, in byte fmt, nuint args)
		{
			fixed (byte* pfmt = &fmt)
			{
				AppendVNative((ImPlotAnnotationCollection*)self, pos, off, bg, fg, clamp ? (byte)1 : (byte)0, (byte*)pfmt, args);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void AppendV(ImPlotAnnotationCollectionPtr self, Vector2 pos, Vector2 off, uint bg, uint fg, bool clamp, ReadOnlySpan<byte> fmt, nuint args)
		{
			fixed (byte* pfmt = fmt)
			{
				AppendVNative((ImPlotAnnotationCollection*)self, pos, off, bg, fg, clamp ? (byte)1 : (byte)0, (byte*)pfmt, args);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void AppendV(ImPlotAnnotationCollectionPtr self, Vector2 pos, Vector2 off, uint bg, uint fg, bool clamp, string fmt, nuint args)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (fmt != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(fmt);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(fmt, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			AppendVNative((ImPlotAnnotationCollection*)self, pos, off, bg, fg, clamp ? (byte)1 : (byte)0, pStr0, args);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void AppendV(ref ImPlotAnnotationCollection self, Vector2 pos, Vector2 off, uint bg, uint fg, bool clamp, in byte fmt, nuint args)
		{
			fixed (ImPlotAnnotationCollection* pself = &self)
			{
				fixed (byte* pfmt = &fmt)
				{
					AppendVNative((ImPlotAnnotationCollection*)pself, pos, off, bg, fg, clamp ? (byte)1 : (byte)0, (byte*)pfmt, args);
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void AppendV(ref ImPlotAnnotationCollection self, Vector2 pos, Vector2 off, uint bg, uint fg, bool clamp, ReadOnlySpan<byte> fmt, nuint args)
		{
			fixed (ImPlotAnnotationCollection* pself = &self)
			{
				fixed (byte* pfmt = fmt)
				{
					AppendVNative((ImPlotAnnotationCollection*)pself, pos, off, bg, fg, clamp ? (byte)1 : (byte)0, (byte*)pfmt, args);
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void AppendV(ref ImPlotAnnotationCollection self, Vector2 pos, Vector2 off, uint bg, uint fg, bool clamp, string fmt, nuint args)
		{
			fixed (ImPlotAnnotationCollection* pself = &self)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (fmt != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(fmt);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(fmt, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				AppendVNative((ImPlotAnnotationCollection*)pself, pos, off, bg, fg, clamp ? (byte)1 : (byte)0, pStr0, args);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void AppendNative(ImPlotAnnotationCollection* self, Vector2 pos, Vector2 off, uint bg, uint fg, byte clamp, byte* fmt)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<ImPlotAnnotationCollection*, Vector2, Vector2, uint, uint, byte, byte*, void>)funcTable[526])(self, pos, off, bg, fg, clamp, fmt);
			#else
			((delegate* unmanaged[Cdecl]<nint, Vector2, Vector2, uint, uint, byte, nint, void>)funcTable[526])((nint)self, pos, off, bg, fg, clamp, (nint)fmt);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void Append(ImPlotAnnotationCollectionPtr self, Vector2 pos, Vector2 off, uint bg, uint fg, bool clamp, byte* fmt)
		{
			AppendNative((ImPlotAnnotationCollection*)self, pos, off, bg, fg, clamp ? (byte)1 : (byte)0, fmt);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void Append(ref ImPlotAnnotationCollection self, Vector2 pos, Vector2 off, uint bg, uint fg, bool clamp, byte* fmt)
		{
			fixed (ImPlotAnnotationCollection* pself = &self)
			{
				AppendNative((ImPlotAnnotationCollection*)pself, pos, off, bg, fg, clamp ? (byte)1 : (byte)0, fmt);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void Append(ImPlotAnnotationCollectionPtr self, Vector2 pos, Vector2 off, uint bg, uint fg, bool clamp, in byte fmt)
		{
			fixed (byte* pfmt = &fmt)
			{
				AppendNative((ImPlotAnnotationCollection*)self, pos, off, bg, fg, clamp ? (byte)1 : (byte)0, (byte*)pfmt);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void Append(ImPlotAnnotationCollectionPtr self, Vector2 pos, Vector2 off, uint bg, uint fg, bool clamp, ReadOnlySpan<byte> fmt)
		{
			fixed (byte* pfmt = fmt)
			{
				AppendNative((ImPlotAnnotationCollection*)self, pos, off, bg, fg, clamp ? (byte)1 : (byte)0, (byte*)pfmt);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void Append(ImPlotAnnotationCollectionPtr self, Vector2 pos, Vector2 off, uint bg, uint fg, bool clamp, string fmt)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (fmt != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(fmt);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(fmt, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			AppendNative((ImPlotAnnotationCollection*)self, pos, off, bg, fg, clamp ? (byte)1 : (byte)0, pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void Append(ref ImPlotAnnotationCollection self, Vector2 pos, Vector2 off, uint bg, uint fg, bool clamp, in byte fmt)
		{
			fixed (ImPlotAnnotationCollection* pself = &self)
			{
				fixed (byte* pfmt = &fmt)
				{
					AppendNative((ImPlotAnnotationCollection*)pself, pos, off, bg, fg, clamp ? (byte)1 : (byte)0, (byte*)pfmt);
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void Append(ref ImPlotAnnotationCollection self, Vector2 pos, Vector2 off, uint bg, uint fg, bool clamp, ReadOnlySpan<byte> fmt)
		{
			fixed (ImPlotAnnotationCollection* pself = &self)
			{
				fixed (byte* pfmt = fmt)
				{
					AppendNative((ImPlotAnnotationCollection*)pself, pos, off, bg, fg, clamp ? (byte)1 : (byte)0, (byte*)pfmt);
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void Append(ref ImPlotAnnotationCollection self, Vector2 pos, Vector2 off, uint bg, uint fg, bool clamp, string fmt)
		{
			fixed (ImPlotAnnotationCollection* pself = &self)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (fmt != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(fmt);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(fmt, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				AppendNative((ImPlotAnnotationCollection*)pself, pos, off, bg, fg, clamp ? (byte)1 : (byte)0, pStr0);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte* GetTextNative(ImPlotAnnotationCollection* self, int idx)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<ImPlotAnnotationCollection*, int, byte*>)funcTable[527])(self, idx);
			#else
			return (byte*)((delegate* unmanaged[Cdecl]<nint, int, nint>)funcTable[527])((nint)self, idx);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static byte* GetText(ImPlotAnnotationCollectionPtr self, int idx)
		{
			byte* ret = GetTextNative((ImPlotAnnotationCollection*)self, idx);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static string GetTextS(ImPlotAnnotationCollectionPtr self, int idx)
		{
			string ret = Utils.DecodeStringUTF8(GetTextNative((ImPlotAnnotationCollection*)self, idx));
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static byte* GetText(ref ImPlotAnnotationCollection self, int idx)
		{
			fixed (ImPlotAnnotationCollection* pself = &self)
			{
				byte* ret = GetTextNative((ImPlotAnnotationCollection*)pself, idx);
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static string GetTextS(ref ImPlotAnnotationCollection self, int idx)
		{
			fixed (ImPlotAnnotationCollection* pself = &self)
			{
				string ret = Utils.DecodeStringUTF8(GetTextNative((ImPlotAnnotationCollection*)pself, idx));
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void ResetNative(ImPlotAnnotationCollection* self)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<ImPlotAnnotationCollection*, void>)funcTable[528])(self);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)funcTable[528])((nint)self);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void Reset(ImPlotAnnotationCollectionPtr self)
		{
			ResetNative((ImPlotAnnotationCollection*)self);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void Reset(ref ImPlotAnnotationCollection self)
		{
			fixed (ImPlotAnnotationCollection* pself = &self)
			{
				ResetNative((ImPlotAnnotationCollection*)pself);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static ImPlotTagCollection* ImPlotTagCollectionNative()
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<ImPlotTagCollection*>)funcTable[529])();
			#else
			return (ImPlotTagCollection*)((delegate* unmanaged[Cdecl]<nint>)funcTable[529])();
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static ImPlotTagCollectionPtr ImPlotTagCollection()
		{
			ImPlotTagCollectionPtr ret = ImPlotTagCollectionNative();
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void DestroyNative(ImPlotTagCollection* self)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<ImPlotTagCollection*, void>)funcTable[530])(self);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)funcTable[530])((nint)self);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void Destroy(ImPlotTagCollectionPtr self)
		{
			DestroyNative((ImPlotTagCollection*)self);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void Destroy(ref ImPlotTagCollection self)
		{
			fixed (ImPlotTagCollection* pself = &self)
			{
				DestroyNative((ImPlotTagCollection*)pself);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void AppendVNative(ImPlotTagCollection* self, ImAxis axis, double value, uint bg, uint fg, byte* fmt, nuint args)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<ImPlotTagCollection*, ImAxis, double, uint, uint, byte*, nuint, void>)funcTable[531])(self, axis, value, bg, fg, fmt, args);
			#else
			((delegate* unmanaged[Cdecl]<nint, ImAxis, double, uint, uint, nint, nuint, void>)funcTable[531])((nint)self, axis, value, bg, fg, (nint)fmt, args);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void AppendV(ImPlotTagCollectionPtr self, ImAxis axis, double value, uint bg, uint fg, byte* fmt, nuint args)
		{
			AppendVNative((ImPlotTagCollection*)self, axis, value, bg, fg, fmt, args);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void AppendV(ref ImPlotTagCollection self, ImAxis axis, double value, uint bg, uint fg, byte* fmt, nuint args)
		{
			fixed (ImPlotTagCollection* pself = &self)
			{
				AppendVNative((ImPlotTagCollection*)pself, axis, value, bg, fg, fmt, args);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void AppendV(ImPlotTagCollectionPtr self, ImAxis axis, double value, uint bg, uint fg, in byte fmt, nuint args)
		{
			fixed (byte* pfmt = &fmt)
			{
				AppendVNative((ImPlotTagCollection*)self, axis, value, bg, fg, (byte*)pfmt, args);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void AppendV(ImPlotTagCollectionPtr self, ImAxis axis, double value, uint bg, uint fg, ReadOnlySpan<byte> fmt, nuint args)
		{
			fixed (byte* pfmt = fmt)
			{
				AppendVNative((ImPlotTagCollection*)self, axis, value, bg, fg, (byte*)pfmt, args);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void AppendV(ImPlotTagCollectionPtr self, ImAxis axis, double value, uint bg, uint fg, string fmt, nuint args)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (fmt != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(fmt);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(fmt, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			AppendVNative((ImPlotTagCollection*)self, axis, value, bg, fg, pStr0, args);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void AppendV(ref ImPlotTagCollection self, ImAxis axis, double value, uint bg, uint fg, in byte fmt, nuint args)
		{
			fixed (ImPlotTagCollection* pself = &self)
			{
				fixed (byte* pfmt = &fmt)
				{
					AppendVNative((ImPlotTagCollection*)pself, axis, value, bg, fg, (byte*)pfmt, args);
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void AppendV(ref ImPlotTagCollection self, ImAxis axis, double value, uint bg, uint fg, ReadOnlySpan<byte> fmt, nuint args)
		{
			fixed (ImPlotTagCollection* pself = &self)
			{
				fixed (byte* pfmt = fmt)
				{
					AppendVNative((ImPlotTagCollection*)pself, axis, value, bg, fg, (byte*)pfmt, args);
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void AppendV(ref ImPlotTagCollection self, ImAxis axis, double value, uint bg, uint fg, string fmt, nuint args)
		{
			fixed (ImPlotTagCollection* pself = &self)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (fmt != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(fmt);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(fmt, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				AppendVNative((ImPlotTagCollection*)pself, axis, value, bg, fg, pStr0, args);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void AppendNative(ImPlotTagCollection* self, ImAxis axis, double value, uint bg, uint fg, byte* fmt)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<ImPlotTagCollection*, ImAxis, double, uint, uint, byte*, void>)funcTable[532])(self, axis, value, bg, fg, fmt);
			#else
			((delegate* unmanaged[Cdecl]<nint, ImAxis, double, uint, uint, nint, void>)funcTable[532])((nint)self, axis, value, bg, fg, (nint)fmt);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void Append(ImPlotTagCollectionPtr self, ImAxis axis, double value, uint bg, uint fg, byte* fmt)
		{
			AppendNative((ImPlotTagCollection*)self, axis, value, bg, fg, fmt);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void Append(ref ImPlotTagCollection self, ImAxis axis, double value, uint bg, uint fg, byte* fmt)
		{
			fixed (ImPlotTagCollection* pself = &self)
			{
				AppendNative((ImPlotTagCollection*)pself, axis, value, bg, fg, fmt);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void Append(ImPlotTagCollectionPtr self, ImAxis axis, double value, uint bg, uint fg, in byte fmt)
		{
			fixed (byte* pfmt = &fmt)
			{
				AppendNative((ImPlotTagCollection*)self, axis, value, bg, fg, (byte*)pfmt);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void Append(ImPlotTagCollectionPtr self, ImAxis axis, double value, uint bg, uint fg, ReadOnlySpan<byte> fmt)
		{
			fixed (byte* pfmt = fmt)
			{
				AppendNative((ImPlotTagCollection*)self, axis, value, bg, fg, (byte*)pfmt);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void Append(ImPlotTagCollectionPtr self, ImAxis axis, double value, uint bg, uint fg, string fmt)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (fmt != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(fmt);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(fmt, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			AppendNative((ImPlotTagCollection*)self, axis, value, bg, fg, pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void Append(ref ImPlotTagCollection self, ImAxis axis, double value, uint bg, uint fg, in byte fmt)
		{
			fixed (ImPlotTagCollection* pself = &self)
			{
				fixed (byte* pfmt = &fmt)
				{
					AppendNative((ImPlotTagCollection*)pself, axis, value, bg, fg, (byte*)pfmt);
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void Append(ref ImPlotTagCollection self, ImAxis axis, double value, uint bg, uint fg, ReadOnlySpan<byte> fmt)
		{
			fixed (ImPlotTagCollection* pself = &self)
			{
				fixed (byte* pfmt = fmt)
				{
					AppendNative((ImPlotTagCollection*)pself, axis, value, bg, fg, (byte*)pfmt);
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void Append(ref ImPlotTagCollection self, ImAxis axis, double value, uint bg, uint fg, string fmt)
		{
			fixed (ImPlotTagCollection* pself = &self)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (fmt != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(fmt);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(fmt, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				AppendNative((ImPlotTagCollection*)pself, axis, value, bg, fg, pStr0);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte* GetTextNative(ImPlotTagCollection* self, int idx)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<ImPlotTagCollection*, int, byte*>)funcTable[533])(self, idx);
			#else
			return (byte*)((delegate* unmanaged[Cdecl]<nint, int, nint>)funcTable[533])((nint)self, idx);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static byte* GetText(ImPlotTagCollectionPtr self, int idx)
		{
			byte* ret = GetTextNative((ImPlotTagCollection*)self, idx);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static string GetTextS(ImPlotTagCollectionPtr self, int idx)
		{
			string ret = Utils.DecodeStringUTF8(GetTextNative((ImPlotTagCollection*)self, idx));
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static byte* GetText(ref ImPlotTagCollection self, int idx)
		{
			fixed (ImPlotTagCollection* pself = &self)
			{
				byte* ret = GetTextNative((ImPlotTagCollection*)pself, idx);
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static string GetTextS(ref ImPlotTagCollection self, int idx)
		{
			fixed (ImPlotTagCollection* pself = &self)
			{
				string ret = Utils.DecodeStringUTF8(GetTextNative((ImPlotTagCollection*)pself, idx));
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void ResetNative(ImPlotTagCollection* self)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<ImPlotTagCollection*, void>)funcTable[534])(self);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)funcTable[534])((nint)self);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void Reset(ImPlotTagCollectionPtr self)
		{
			ResetNative((ImPlotTagCollection*)self);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void Reset(ref ImPlotTagCollection self)
		{
			fixed (ImPlotTagCollection* pself = &self)
			{
				ResetNative((ImPlotTagCollection*)pself);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static ImPlotTick* ImPlotTickNative(double value, byte major, int level, byte showLabel)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<double, byte, int, byte, ImPlotTick*>)funcTable[535])(value, major, level, showLabel);
			#else
			return (ImPlotTick*)((delegate* unmanaged[Cdecl]<double, byte, int, byte, nint>)funcTable[535])(value, major, level, showLabel);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static ImPlotTickPtr ImPlotTick(double value, bool major, int level, bool showLabel)
		{
			ImPlotTickPtr ret = ImPlotTickNative(value, major ? (byte)1 : (byte)0, level, showLabel ? (byte)1 : (byte)0);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void DestroyNative(ImPlotTick* self)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<ImPlotTick*, void>)funcTable[536])(self);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)funcTable[536])((nint)self);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void Destroy(ImPlotTickPtr self)
		{
			DestroyNative((ImPlotTick*)self);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void Destroy(ref ImPlotTick self)
		{
			fixed (ImPlotTick* pself = &self)
			{
				DestroyNative((ImPlotTick*)pself);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static ImPlotTicker* ImPlotTickerNative()
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<ImPlotTicker*>)funcTable[537])();
			#else
			return (ImPlotTicker*)((delegate* unmanaged[Cdecl]<nint>)funcTable[537])();
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static ImPlotTickerPtr ImPlotTicker()
		{
			ImPlotTickerPtr ret = ImPlotTickerNative();
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void DestroyNative(ImPlotTicker* self)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<ImPlotTicker*, void>)funcTable[538])(self);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)funcTable[538])((nint)self);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void Destroy(ImPlotTickerPtr self)
		{
			DestroyNative((ImPlotTicker*)self);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void Destroy(ref ImPlotTicker self)
		{
			fixed (ImPlotTicker* pself = &self)
			{
				DestroyNative((ImPlotTicker*)pself);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static ImPlotTick* AddTickNative(ImPlotTicker* self, double value, byte major, int level, byte showLabel, byte* label)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<ImPlotTicker*, double, byte, int, byte, byte*, ImPlotTick*>)funcTable[539])(self, value, major, level, showLabel, label);
			#else
			return (ImPlotTick*)((delegate* unmanaged[Cdecl]<nint, double, byte, int, byte, nint, nint>)funcTable[539])((nint)self, value, major, level, showLabel, (nint)label);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static ImPlotTickPtr AddTick(ImPlotTickerPtr self, double value, bool major, int level, bool showLabel, byte* label)
		{
			ImPlotTickPtr ret = AddTickNative((ImPlotTicker*)self, value, major ? (byte)1 : (byte)0, level, showLabel ? (byte)1 : (byte)0, label);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static ImPlotTickPtr AddTick(ref ImPlotTicker self, double value, bool major, int level, bool showLabel, byte* label)
		{
			fixed (ImPlotTicker* pself = &self)
			{
				ImPlotTickPtr ret = AddTickNative((ImPlotTicker*)pself, value, major ? (byte)1 : (byte)0, level, showLabel ? (byte)1 : (byte)0, label);
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static ImPlotTickPtr AddTick(ImPlotTickerPtr self, double value, bool major, int level, bool showLabel, in byte label)
		{
			fixed (byte* plabel = &label)
			{
				ImPlotTickPtr ret = AddTickNative((ImPlotTicker*)self, value, major ? (byte)1 : (byte)0, level, showLabel ? (byte)1 : (byte)0, (byte*)plabel);
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static ImPlotTickPtr AddTick(ImPlotTickerPtr self, double value, bool major, int level, bool showLabel, ReadOnlySpan<byte> label)
		{
			fixed (byte* plabel = label)
			{
				ImPlotTickPtr ret = AddTickNative((ImPlotTicker*)self, value, major ? (byte)1 : (byte)0, level, showLabel ? (byte)1 : (byte)0, (byte*)plabel);
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static ImPlotTickPtr AddTick(ImPlotTickerPtr self, double value, bool major, int level, bool showLabel, string label)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			ImPlotTickPtr ret = AddTickNative((ImPlotTicker*)self, value, major ? (byte)1 : (byte)0, level, showLabel ? (byte)1 : (byte)0, pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static ImPlotTickPtr AddTick(ref ImPlotTicker self, double value, bool major, int level, bool showLabel, in byte label)
		{
			fixed (ImPlotTicker* pself = &self)
			{
				fixed (byte* plabel = &label)
				{
					ImPlotTickPtr ret = AddTickNative((ImPlotTicker*)pself, value, major ? (byte)1 : (byte)0, level, showLabel ? (byte)1 : (byte)0, (byte*)plabel);
					return ret;
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static ImPlotTickPtr AddTick(ref ImPlotTicker self, double value, bool major, int level, bool showLabel, ReadOnlySpan<byte> label)
		{
			fixed (ImPlotTicker* pself = &self)
			{
				fixed (byte* plabel = label)
				{
					ImPlotTickPtr ret = AddTickNative((ImPlotTicker*)pself, value, major ? (byte)1 : (byte)0, level, showLabel ? (byte)1 : (byte)0, (byte*)plabel);
					return ret;
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static ImPlotTickPtr AddTick(ref ImPlotTicker self, double value, bool major, int level, bool showLabel, string label)
		{
			fixed (ImPlotTicker* pself = &self)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (label != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(label);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				ImPlotTickPtr ret = AddTickNative((ImPlotTicker*)pself, value, major ? (byte)1 : (byte)0, level, showLabel ? (byte)1 : (byte)0, pStr0);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static ImPlotTick* AddTickNative(ImPlotTicker* self, double value, byte major, int level, byte showLabel, delegate*<double, byte*, int, void*, int> formatter, void* data)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<ImPlotTicker*, double, byte, int, byte, delegate*<double, byte*, int, void*, int>, void*, ImPlotTick*>)funcTable[540])(self, value, major, level, showLabel, formatter, data);
			#else
			return (ImPlotTick*)((delegate* unmanaged[Cdecl]<nint, double, byte, int, byte, nint, nint, nint>)funcTable[540])((nint)self, value, major, level, showLabel, (nint)formatter, (nint)data);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static ImPlotTickPtr AddTick(ImPlotTickerPtr self, double value, bool major, int level, bool showLabel, delegate*<double, byte*, int, void*, int> formatter, void* data)
		{
			ImPlotTickPtr ret = AddTickNative((ImPlotTicker*)self, value, major ? (byte)1 : (byte)0, level, showLabel ? (byte)1 : (byte)0, formatter, data);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static ImPlotTickPtr AddTick(ref ImPlotTicker self, double value, bool major, int level, bool showLabel, delegate*<double, byte*, int, void*, int> formatter, void* data)
		{
			fixed (ImPlotTicker* pself = &self)
			{
				ImPlotTickPtr ret = AddTickNative((ImPlotTicker*)pself, value, major ? (byte)1 : (byte)0, level, showLabel ? (byte)1 : (byte)0, formatter, data);
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static ImPlotTickPtr AddTick(ImPlotTickerPtr self, double value, bool major, int level, bool showLabel, ImPlotFormatter formatter, void* data)
		{
			ImPlotTickPtr ret = AddTickNative((ImPlotTicker*)self, value, major ? (byte)1 : (byte)0, level, showLabel ? (byte)1 : (byte)0, (delegate*<double, byte*, int, void*, int>)Utils.GetFunctionPointerForDelegate(formatter), data);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static ImPlotTickPtr AddTick(ref ImPlotTicker self, double value, bool major, int level, bool showLabel, ImPlotFormatter formatter, void* data)
		{
			fixed (ImPlotTicker* pself = &self)
			{
				ImPlotTickPtr ret = AddTickNative((ImPlotTicker*)pself, value, major ? (byte)1 : (byte)0, level, showLabel ? (byte)1 : (byte)0, (delegate*<double, byte*, int, void*, int>)Utils.GetFunctionPointerForDelegate(formatter), data);
				return ret;
			}
		}
	}
}
