// ------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
// ------------------------------------------------------------------------------

using System;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;
using HexaGen.Runtime;
using System.Numerics;
using Hexa.NET.ImGui;

namespace Hexa.NET.ImPlot
{
	public unsafe partial class ImPlot
	{

		/// <summary>
		/// To be documented.
		/// </summary>
		public static ImPlotTickPtr AddTick(ImPlotTickerPtr self, double value, bool major, int level, bool showLabel, delegate*<double, byte*, int, void*, int> formatter, nint data)
		{
			ImPlotTickPtr ret = AddTickNative((ImPlotTicker*)self, value, major ? (byte)1 : (byte)0, level, showLabel ? (byte)1 : (byte)0, formatter, (void*)data);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static ImPlotTickPtr AddTick(ref ImPlotTicker self, double value, bool major, int level, bool showLabel, delegate*<double, byte*, int, void*, int> formatter, nint data)
		{
			fixed (ImPlotTicker* pself = &self)
			{
				ImPlotTickPtr ret = AddTickNative((ImPlotTicker*)pself, value, major ? (byte)1 : (byte)0, level, showLabel ? (byte)1 : (byte)0, formatter, (void*)data);
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static ImPlotTickPtr AddTick(ImPlotTickerPtr self, double value, bool major, int level, bool showLabel, ImPlotFormatter formatter, nint data)
		{
			ImPlotTickPtr ret = AddTickNative((ImPlotTicker*)self, value, major ? (byte)1 : (byte)0, level, showLabel ? (byte)1 : (byte)0, (delegate*<double, byte*, int, void*, int>)Utils.GetFunctionPointerForDelegate(formatter), (void*)data);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static ImPlotTickPtr AddTick(ref ImPlotTicker self, double value, bool major, int level, bool showLabel, ImPlotFormatter formatter, nint data)
		{
			fixed (ImPlotTicker* pself = &self)
			{
				ImPlotTickPtr ret = AddTickNative((ImPlotTicker*)pself, value, major ? (byte)1 : (byte)0, level, showLabel ? (byte)1 : (byte)0, (delegate*<double, byte*, int, void*, int>)Utils.GetFunctionPointerForDelegate(formatter), (void*)data);
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static ImPlotTick* AddTickNative(ImPlotTicker* self, ImPlotTick tick)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<ImPlotTicker*, ImPlotTick, ImPlotTick*>)funcTable[541])(self, tick);
			#else
			return (ImPlotTick*)((delegate* unmanaged[Cdecl]<nint, ImPlotTick, nint>)funcTable[541])((nint)self, tick);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static ImPlotTickPtr AddTick(ImPlotTickerPtr self, ImPlotTick tick)
		{
			ImPlotTickPtr ret = AddTickNative((ImPlotTicker*)self, tick);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static ImPlotTickPtr AddTick(ref ImPlotTicker self, ImPlotTick tick)
		{
			fixed (ImPlotTicker* pself = &self)
			{
				ImPlotTickPtr ret = AddTickNative((ImPlotTicker*)pself, tick);
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte* GetTextNative(ImPlotTicker* self, int idx)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<ImPlotTicker*, int, byte*>)funcTable[542])(self, idx);
			#else
			return (byte*)((delegate* unmanaged[Cdecl]<nint, int, nint>)funcTable[542])((nint)self, idx);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static byte* GetText(ImPlotTickerPtr self, int idx)
		{
			byte* ret = GetTextNative((ImPlotTicker*)self, idx);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static string GetTextS(ImPlotTickerPtr self, int idx)
		{
			string ret = Utils.DecodeStringUTF8(GetTextNative((ImPlotTicker*)self, idx));
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static byte* GetText(ref ImPlotTicker self, int idx)
		{
			fixed (ImPlotTicker* pself = &self)
			{
				byte* ret = GetTextNative((ImPlotTicker*)pself, idx);
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static string GetTextS(ref ImPlotTicker self, int idx)
		{
			fixed (ImPlotTicker* pself = &self)
			{
				string ret = Utils.DecodeStringUTF8(GetTextNative((ImPlotTicker*)pself, idx));
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte* GetTextNative(ImPlotTicker* self, ImPlotTick tick)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<ImPlotTicker*, ImPlotTick, byte*>)funcTable[543])(self, tick);
			#else
			return (byte*)((delegate* unmanaged[Cdecl]<nint, ImPlotTick, nint>)funcTable[543])((nint)self, tick);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static byte* GetText(ImPlotTickerPtr self, ImPlotTick tick)
		{
			byte* ret = GetTextNative((ImPlotTicker*)self, tick);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static string GetTextS(ImPlotTickerPtr self, ImPlotTick tick)
		{
			string ret = Utils.DecodeStringUTF8(GetTextNative((ImPlotTicker*)self, tick));
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static byte* GetText(ref ImPlotTicker self, ImPlotTick tick)
		{
			fixed (ImPlotTicker* pself = &self)
			{
				byte* ret = GetTextNative((ImPlotTicker*)pself, tick);
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static string GetTextS(ref ImPlotTicker self, ImPlotTick tick)
		{
			fixed (ImPlotTicker* pself = &self)
			{
				string ret = Utils.DecodeStringUTF8(GetTextNative((ImPlotTicker*)pself, tick));
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void OverrideSizeLateNative(ImPlotTicker* self, Vector2 size)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<ImPlotTicker*, Vector2, void>)funcTable[544])(self, size);
			#else
			((delegate* unmanaged[Cdecl]<nint, Vector2, void>)funcTable[544])((nint)self, size);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void OverrideSizeLate(ImPlotTickerPtr self, Vector2 size)
		{
			OverrideSizeLateNative((ImPlotTicker*)self, size);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void OverrideSizeLate(ref ImPlotTicker self, Vector2 size)
		{
			fixed (ImPlotTicker* pself = &self)
			{
				OverrideSizeLateNative((ImPlotTicker*)pself, size);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void ResetNative(ImPlotTicker* self)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<ImPlotTicker*, void>)funcTable[545])(self);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)funcTable[545])((nint)self);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void Reset(ImPlotTickerPtr self)
		{
			ResetNative((ImPlotTicker*)self);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void Reset(ref ImPlotTicker self)
		{
			fixed (ImPlotTicker* pself = &self)
			{
				ResetNative((ImPlotTicker*)pself);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int TickCountNative(ImPlotTicker* self)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<ImPlotTicker*, int>)funcTable[546])(self);
			#else
			return (int)((delegate* unmanaged[Cdecl]<nint, int>)funcTable[546])((nint)self);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static int TickCount(ImPlotTickerPtr self)
		{
			int ret = TickCountNative((ImPlotTicker*)self);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static int TickCount(ref ImPlotTicker self)
		{
			fixed (ImPlotTicker* pself = &self)
			{
				int ret = TickCountNative((ImPlotTicker*)pself);
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static ImPlotAxis* ImPlotAxisNative()
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<ImPlotAxis*>)funcTable[547])();
			#else
			return (ImPlotAxis*)((delegate* unmanaged[Cdecl]<nint>)funcTable[547])();
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static ImPlotAxisPtr ImPlotAxis()
		{
			ImPlotAxisPtr ret = ImPlotAxisNative();
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void DestroyNative(ImPlotAxis* self)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<ImPlotAxis*, void>)funcTable[548])(self);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)funcTable[548])((nint)self);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void Destroy(ImPlotAxisPtr self)
		{
			DestroyNative((ImPlotAxis*)self);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void Destroy(ref ImPlotAxis self)
		{
			fixed (ImPlotAxis* pself = &self)
			{
				DestroyNative((ImPlotAxis*)pself);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void ResetNative(ImPlotAxis* self)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<ImPlotAxis*, void>)funcTable[549])(self);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)funcTable[549])((nint)self);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void Reset(ImPlotAxisPtr self)
		{
			ResetNative((ImPlotAxis*)self);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void Reset(ref ImPlotAxis self)
		{
			fixed (ImPlotAxis* pself = &self)
			{
				ResetNative((ImPlotAxis*)pself);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte SetMinNative(ImPlotAxis* self, double min, byte force)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<ImPlotAxis*, double, byte, byte>)funcTable[550])(self, min, force);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<nint, double, byte, byte>)funcTable[550])((nint)self, min, force);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool SetMin(ImPlotAxisPtr self, double min, bool force)
		{
			byte ret = SetMinNative((ImPlotAxis*)self, min, force ? (byte)1 : (byte)0);
			return ret != 0;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool SetMin(ImPlotAxisPtr self, double min)
		{
			byte ret = SetMinNative((ImPlotAxis*)self, min, (byte)(0));
			return ret != 0;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool SetMin(ref ImPlotAxis self, double min, bool force)
		{
			fixed (ImPlotAxis* pself = &self)
			{
				byte ret = SetMinNative((ImPlotAxis*)pself, min, force ? (byte)1 : (byte)0);
				return ret != 0;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool SetMin(ref ImPlotAxis self, double min)
		{
			fixed (ImPlotAxis* pself = &self)
			{
				byte ret = SetMinNative((ImPlotAxis*)pself, min, (byte)(0));
				return ret != 0;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte SetMaxNative(ImPlotAxis* self, double max, byte force)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<ImPlotAxis*, double, byte, byte>)funcTable[551])(self, max, force);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<nint, double, byte, byte>)funcTable[551])((nint)self, max, force);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool SetMax(ImPlotAxisPtr self, double max, bool force)
		{
			byte ret = SetMaxNative((ImPlotAxis*)self, max, force ? (byte)1 : (byte)0);
			return ret != 0;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool SetMax(ImPlotAxisPtr self, double max)
		{
			byte ret = SetMaxNative((ImPlotAxis*)self, max, (byte)(0));
			return ret != 0;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool SetMax(ref ImPlotAxis self, double max, bool force)
		{
			fixed (ImPlotAxis* pself = &self)
			{
				byte ret = SetMaxNative((ImPlotAxis*)pself, max, force ? (byte)1 : (byte)0);
				return ret != 0;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool SetMax(ref ImPlotAxis self, double max)
		{
			fixed (ImPlotAxis* pself = &self)
			{
				byte ret = SetMaxNative((ImPlotAxis*)pself, max, (byte)(0));
				return ret != 0;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void SetRangeNative(ImPlotAxis* self, double v1, double v2)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<ImPlotAxis*, double, double, void>)funcTable[552])(self, v1, v2);
			#else
			((delegate* unmanaged[Cdecl]<nint, double, double, void>)funcTable[552])((nint)self, v1, v2);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void SetRange(ImPlotAxisPtr self, double v1, double v2)
		{
			SetRangeNative((ImPlotAxis*)self, v1, v2);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void SetRange(ref ImPlotAxis self, double v1, double v2)
		{
			fixed (ImPlotAxis* pself = &self)
			{
				SetRangeNative((ImPlotAxis*)pself, v1, v2);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void SetRangeNative(ImPlotAxis* self, ImPlotRange range)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<ImPlotAxis*, ImPlotRange, void>)funcTable[553])(self, range);
			#else
			((delegate* unmanaged[Cdecl]<nint, ImPlotRange, void>)funcTable[553])((nint)self, range);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void SetRange(ImPlotAxisPtr self, ImPlotRange range)
		{
			SetRangeNative((ImPlotAxis*)self, range);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void SetRange(ref ImPlotAxis self, ImPlotRange range)
		{
			fixed (ImPlotAxis* pself = &self)
			{
				SetRangeNative((ImPlotAxis*)pself, range);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void SetAspectNative(ImPlotAxis* self, double unitPerPix)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<ImPlotAxis*, double, void>)funcTable[554])(self, unitPerPix);
			#else
			((delegate* unmanaged[Cdecl]<nint, double, void>)funcTable[554])((nint)self, unitPerPix);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void SetAspect(ImPlotAxisPtr self, double unitPerPix)
		{
			SetAspectNative((ImPlotAxis*)self, unitPerPix);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void SetAspect(ref ImPlotAxis self, double unitPerPix)
		{
			fixed (ImPlotAxis* pself = &self)
			{
				SetAspectNative((ImPlotAxis*)pself, unitPerPix);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static float PixelSizeNative(ImPlotAxis* self)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<ImPlotAxis*, float>)funcTable[555])(self);
			#else
			return (float)((delegate* unmanaged[Cdecl]<nint, float>)funcTable[555])((nint)self);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static float PixelSize(ImPlotAxisPtr self)
		{
			float ret = PixelSizeNative((ImPlotAxis*)self);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static float PixelSize(ref ImPlotAxis self)
		{
			fixed (ImPlotAxis* pself = &self)
			{
				float ret = PixelSizeNative((ImPlotAxis*)pself);
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static double GetAspectNative(ImPlotAxis* self)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<ImPlotAxis*, double>)funcTable[556])(self);
			#else
			return (double)((delegate* unmanaged[Cdecl]<nint, double>)funcTable[556])((nint)self);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static double GetAspect(ImPlotAxisPtr self)
		{
			double ret = GetAspectNative((ImPlotAxis*)self);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static double GetAspect(ref ImPlotAxis self)
		{
			fixed (ImPlotAxis* pself = &self)
			{
				double ret = GetAspectNative((ImPlotAxis*)pself);
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void ConstrainNative(ImPlotAxis* self)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<ImPlotAxis*, void>)funcTable[557])(self);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)funcTable[557])((nint)self);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void Constrain(ImPlotAxisPtr self)
		{
			ConstrainNative((ImPlotAxis*)self);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void Constrain(ref ImPlotAxis self)
		{
			fixed (ImPlotAxis* pself = &self)
			{
				ConstrainNative((ImPlotAxis*)pself);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void UpdateTransformCacheNative(ImPlotAxis* self)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<ImPlotAxis*, void>)funcTable[558])(self);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)funcTable[558])((nint)self);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void UpdateTransformCache(ImPlotAxisPtr self)
		{
			UpdateTransformCacheNative((ImPlotAxis*)self);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void UpdateTransformCache(ref ImPlotAxis self)
		{
			fixed (ImPlotAxis* pself = &self)
			{
				UpdateTransformCacheNative((ImPlotAxis*)pself);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static float PlotToPixelsNative(ImPlotAxis* self, double plt)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<ImPlotAxis*, double, float>)funcTable[559])(self, plt);
			#else
			return (float)((delegate* unmanaged[Cdecl]<nint, double, float>)funcTable[559])((nint)self, plt);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static float PlotToPixels(ImPlotAxisPtr self, double plt)
		{
			float ret = PlotToPixelsNative((ImPlotAxis*)self, plt);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static float PlotToPixels(ref ImPlotAxis self, double plt)
		{
			fixed (ImPlotAxis* pself = &self)
			{
				float ret = PlotToPixelsNative((ImPlotAxis*)pself, plt);
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static double PixelsToPlotNative(ImPlotAxis* self, float pix)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<ImPlotAxis*, float, double>)funcTable[560])(self, pix);
			#else
			return (double)((delegate* unmanaged[Cdecl]<nint, float, double>)funcTable[560])((nint)self, pix);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static double PixelsToPlot(ImPlotAxisPtr self, float pix)
		{
			double ret = PixelsToPlotNative((ImPlotAxis*)self, pix);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static double PixelsToPlot(ref ImPlotAxis self, float pix)
		{
			fixed (ImPlotAxis* pself = &self)
			{
				double ret = PixelsToPlotNative((ImPlotAxis*)pself, pix);
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void ExtendFitNative(ImPlotAxis* self, double v)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<ImPlotAxis*, double, void>)funcTable[561])(self, v);
			#else
			((delegate* unmanaged[Cdecl]<nint, double, void>)funcTable[561])((nint)self, v);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void ExtendFit(ImPlotAxisPtr self, double v)
		{
			ExtendFitNative((ImPlotAxis*)self, v);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void ExtendFit(ref ImPlotAxis self, double v)
		{
			fixed (ImPlotAxis* pself = &self)
			{
				ExtendFitNative((ImPlotAxis*)pself, v);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void ExtendFitWithNative(ImPlotAxis* self, ImPlotAxis* alt, double v, double vAlt)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<ImPlotAxis*, ImPlotAxis*, double, double, void>)funcTable[562])(self, alt, v, vAlt);
			#else
			((delegate* unmanaged[Cdecl]<nint, nint, double, double, void>)funcTable[562])((nint)self, (nint)alt, v, vAlt);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void ExtendFitWith(ImPlotAxisPtr self, ImPlotAxisPtr alt, double v, double vAlt)
		{
			ExtendFitWithNative((ImPlotAxis*)self, (ImPlotAxis*)alt, v, vAlt);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void ExtendFitWith(ref ImPlotAxis self, ImPlotAxisPtr alt, double v, double vAlt)
		{
			fixed (ImPlotAxis* pself = &self)
			{
				ExtendFitWithNative((ImPlotAxis*)pself, (ImPlotAxis*)alt, v, vAlt);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void ExtendFitWith(ImPlotAxisPtr self, ref ImPlotAxis alt, double v, double vAlt)
		{
			fixed (ImPlotAxis* palt = &alt)
			{
				ExtendFitWithNative((ImPlotAxis*)self, (ImPlotAxis*)palt, v, vAlt);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void ExtendFitWith(ref ImPlotAxis self, ref ImPlotAxis alt, double v, double vAlt)
		{
			fixed (ImPlotAxis* pself = &self)
			{
				fixed (ImPlotAxis* palt = &alt)
				{
					ExtendFitWithNative((ImPlotAxis*)pself, (ImPlotAxis*)palt, v, vAlt);
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void ApplyFitNative(ImPlotAxis* self, float padding)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<ImPlotAxis*, float, void>)funcTable[563])(self, padding);
			#else
			((delegate* unmanaged[Cdecl]<nint, float, void>)funcTable[563])((nint)self, padding);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void ApplyFit(ImPlotAxisPtr self, float padding)
		{
			ApplyFitNative((ImPlotAxis*)self, padding);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void ApplyFit(ref ImPlotAxis self, float padding)
		{
			fixed (ImPlotAxis* pself = &self)
			{
				ApplyFitNative((ImPlotAxis*)pself, padding);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte HasLabelNative(ImPlotAxis* self)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<ImPlotAxis*, byte>)funcTable[564])(self);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<nint, byte>)funcTable[564])((nint)self);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool HasLabel(ImPlotAxisPtr self)
		{
			byte ret = HasLabelNative((ImPlotAxis*)self);
			return ret != 0;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool HasLabel(ref ImPlotAxis self)
		{
			fixed (ImPlotAxis* pself = &self)
			{
				byte ret = HasLabelNative((ImPlotAxis*)pself);
				return ret != 0;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte HasGridLinesNative(ImPlotAxis* self)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<ImPlotAxis*, byte>)funcTable[565])(self);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<nint, byte>)funcTable[565])((nint)self);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool HasGridLines(ImPlotAxisPtr self)
		{
			byte ret = HasGridLinesNative((ImPlotAxis*)self);
			return ret != 0;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool HasGridLines(ref ImPlotAxis self)
		{
			fixed (ImPlotAxis* pself = &self)
			{
				byte ret = HasGridLinesNative((ImPlotAxis*)pself);
				return ret != 0;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte HasTickLabelsNative(ImPlotAxis* self)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<ImPlotAxis*, byte>)funcTable[566])(self);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<nint, byte>)funcTable[566])((nint)self);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool HasTickLabels(ImPlotAxisPtr self)
		{
			byte ret = HasTickLabelsNative((ImPlotAxis*)self);
			return ret != 0;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool HasTickLabels(ref ImPlotAxis self)
		{
			fixed (ImPlotAxis* pself = &self)
			{
				byte ret = HasTickLabelsNative((ImPlotAxis*)pself);
				return ret != 0;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte HasTickMarksNative(ImPlotAxis* self)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<ImPlotAxis*, byte>)funcTable[567])(self);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<nint, byte>)funcTable[567])((nint)self);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool HasTickMarks(ImPlotAxisPtr self)
		{
			byte ret = HasTickMarksNative((ImPlotAxis*)self);
			return ret != 0;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool HasTickMarks(ref ImPlotAxis self)
		{
			fixed (ImPlotAxis* pself = &self)
			{
				byte ret = HasTickMarksNative((ImPlotAxis*)pself);
				return ret != 0;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte WillRenderNative(ImPlotAxis* self)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<ImPlotAxis*, byte>)funcTable[568])(self);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<nint, byte>)funcTable[568])((nint)self);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool WillRender(ImPlotAxisPtr self)
		{
			byte ret = WillRenderNative((ImPlotAxis*)self);
			return ret != 0;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool WillRender(ref ImPlotAxis self)
		{
			fixed (ImPlotAxis* pself = &self)
			{
				byte ret = WillRenderNative((ImPlotAxis*)pself);
				return ret != 0;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte IsOppositeNative(ImPlotAxis* self)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<ImPlotAxis*, byte>)funcTable[569])(self);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<nint, byte>)funcTable[569])((nint)self);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool IsOpposite(ImPlotAxisPtr self)
		{
			byte ret = IsOppositeNative((ImPlotAxis*)self);
			return ret != 0;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool IsOpposite(ref ImPlotAxis self)
		{
			fixed (ImPlotAxis* pself = &self)
			{
				byte ret = IsOppositeNative((ImPlotAxis*)pself);
				return ret != 0;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte IsInvertedNative(ImPlotAxis* self)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<ImPlotAxis*, byte>)funcTable[570])(self);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<nint, byte>)funcTable[570])((nint)self);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool IsInverted(ImPlotAxisPtr self)
		{
			byte ret = IsInvertedNative((ImPlotAxis*)self);
			return ret != 0;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool IsInverted(ref ImPlotAxis self)
		{
			fixed (ImPlotAxis* pself = &self)
			{
				byte ret = IsInvertedNative((ImPlotAxis*)pself);
				return ret != 0;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte IsForegroundNative(ImPlotAxis* self)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<ImPlotAxis*, byte>)funcTable[571])(self);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<nint, byte>)funcTable[571])((nint)self);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool IsForeground(ImPlotAxisPtr self)
		{
			byte ret = IsForegroundNative((ImPlotAxis*)self);
			return ret != 0;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool IsForeground(ref ImPlotAxis self)
		{
			fixed (ImPlotAxis* pself = &self)
			{
				byte ret = IsForegroundNative((ImPlotAxis*)pself);
				return ret != 0;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte IsAutoFittingNative(ImPlotAxis* self)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<ImPlotAxis*, byte>)funcTable[572])(self);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<nint, byte>)funcTable[572])((nint)self);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool IsAutoFitting(ImPlotAxisPtr self)
		{
			byte ret = IsAutoFittingNative((ImPlotAxis*)self);
			return ret != 0;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool IsAutoFitting(ref ImPlotAxis self)
		{
			fixed (ImPlotAxis* pself = &self)
			{
				byte ret = IsAutoFittingNative((ImPlotAxis*)pself);
				return ret != 0;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte CanInitFitNative(ImPlotAxis* self)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<ImPlotAxis*, byte>)funcTable[573])(self);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<nint, byte>)funcTable[573])((nint)self);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool CanInitFit(ImPlotAxisPtr self)
		{
			byte ret = CanInitFitNative((ImPlotAxis*)self);
			return ret != 0;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool CanInitFit(ref ImPlotAxis self)
		{
			fixed (ImPlotAxis* pself = &self)
			{
				byte ret = CanInitFitNative((ImPlotAxis*)pself);
				return ret != 0;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte IsRangeLockedNative(ImPlotAxis* self)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<ImPlotAxis*, byte>)funcTable[574])(self);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<nint, byte>)funcTable[574])((nint)self);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool IsRangeLocked(ImPlotAxisPtr self)
		{
			byte ret = IsRangeLockedNative((ImPlotAxis*)self);
			return ret != 0;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool IsRangeLocked(ref ImPlotAxis self)
		{
			fixed (ImPlotAxis* pself = &self)
			{
				byte ret = IsRangeLockedNative((ImPlotAxis*)pself);
				return ret != 0;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte IsLockedMinNative(ImPlotAxis* self)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<ImPlotAxis*, byte>)funcTable[575])(self);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<nint, byte>)funcTable[575])((nint)self);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool IsLockedMin(ImPlotAxisPtr self)
		{
			byte ret = IsLockedMinNative((ImPlotAxis*)self);
			return ret != 0;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool IsLockedMin(ref ImPlotAxis self)
		{
			fixed (ImPlotAxis* pself = &self)
			{
				byte ret = IsLockedMinNative((ImPlotAxis*)pself);
				return ret != 0;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte IsLockedMaxNative(ImPlotAxis* self)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<ImPlotAxis*, byte>)funcTable[576])(self);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<nint, byte>)funcTable[576])((nint)self);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool IsLockedMax(ImPlotAxisPtr self)
		{
			byte ret = IsLockedMaxNative((ImPlotAxis*)self);
			return ret != 0;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool IsLockedMax(ref ImPlotAxis self)
		{
			fixed (ImPlotAxis* pself = &self)
			{
				byte ret = IsLockedMaxNative((ImPlotAxis*)pself);
				return ret != 0;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte IsLockedNative(ImPlotAxis* self)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<ImPlotAxis*, byte>)funcTable[577])(self);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<nint, byte>)funcTable[577])((nint)self);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool IsLocked(ImPlotAxisPtr self)
		{
			byte ret = IsLockedNative((ImPlotAxis*)self);
			return ret != 0;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool IsLocked(ref ImPlotAxis self)
		{
			fixed (ImPlotAxis* pself = &self)
			{
				byte ret = IsLockedNative((ImPlotAxis*)pself);
				return ret != 0;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte IsInputLockedMinNative(ImPlotAxis* self)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<ImPlotAxis*, byte>)funcTable[578])(self);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<nint, byte>)funcTable[578])((nint)self);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool IsInputLockedMin(ImPlotAxisPtr self)
		{
			byte ret = IsInputLockedMinNative((ImPlotAxis*)self);
			return ret != 0;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool IsInputLockedMin(ref ImPlotAxis self)
		{
			fixed (ImPlotAxis* pself = &self)
			{
				byte ret = IsInputLockedMinNative((ImPlotAxis*)pself);
				return ret != 0;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte IsInputLockedMaxNative(ImPlotAxis* self)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<ImPlotAxis*, byte>)funcTable[579])(self);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<nint, byte>)funcTable[579])((nint)self);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool IsInputLockedMax(ImPlotAxisPtr self)
		{
			byte ret = IsInputLockedMaxNative((ImPlotAxis*)self);
			return ret != 0;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool IsInputLockedMax(ref ImPlotAxis self)
		{
			fixed (ImPlotAxis* pself = &self)
			{
				byte ret = IsInputLockedMaxNative((ImPlotAxis*)pself);
				return ret != 0;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte IsInputLockedNative(ImPlotAxis* self)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<ImPlotAxis*, byte>)funcTable[580])(self);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<nint, byte>)funcTable[580])((nint)self);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool IsInputLocked(ImPlotAxisPtr self)
		{
			byte ret = IsInputLockedNative((ImPlotAxis*)self);
			return ret != 0;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool IsInputLocked(ref ImPlotAxis self)
		{
			fixed (ImPlotAxis* pself = &self)
			{
				byte ret = IsInputLockedNative((ImPlotAxis*)pself);
				return ret != 0;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte HasMenusNative(ImPlotAxis* self)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<ImPlotAxis*, byte>)funcTable[581])(self);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<nint, byte>)funcTable[581])((nint)self);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool HasMenus(ImPlotAxisPtr self)
		{
			byte ret = HasMenusNative((ImPlotAxis*)self);
			return ret != 0;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool HasMenus(ref ImPlotAxis self)
		{
			fixed (ImPlotAxis* pself = &self)
			{
				byte ret = HasMenusNative((ImPlotAxis*)pself);
				return ret != 0;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte IsPanLockedNative(ImPlotAxis* self, byte increasing)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<ImPlotAxis*, byte, byte>)funcTable[582])(self, increasing);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<nint, byte, byte>)funcTable[582])((nint)self, increasing);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool IsPanLocked(ImPlotAxisPtr self, bool increasing)
		{
			byte ret = IsPanLockedNative((ImPlotAxis*)self, increasing ? (byte)1 : (byte)0);
			return ret != 0;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool IsPanLocked(ref ImPlotAxis self, bool increasing)
		{
			fixed (ImPlotAxis* pself = &self)
			{
				byte ret = IsPanLockedNative((ImPlotAxis*)pself, increasing ? (byte)1 : (byte)0);
				return ret != 0;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void PushLinksNative(ImPlotAxis* self)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<ImPlotAxis*, void>)funcTable[583])(self);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)funcTable[583])((nint)self);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void PushLinks(ImPlotAxisPtr self)
		{
			PushLinksNative((ImPlotAxis*)self);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void PushLinks(ref ImPlotAxis self)
		{
			fixed (ImPlotAxis* pself = &self)
			{
				PushLinksNative((ImPlotAxis*)pself);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void PullLinksNative(ImPlotAxis* self)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<ImPlotAxis*, void>)funcTable[584])(self);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)funcTable[584])((nint)self);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void PullLinks(ImPlotAxisPtr self)
		{
			PullLinksNative((ImPlotAxis*)self);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void PullLinks(ref ImPlotAxis self)
		{
			fixed (ImPlotAxis* pself = &self)
			{
				PullLinksNative((ImPlotAxis*)pself);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static ImPlotAlignmentData* ImPlotAlignmentDataNative()
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<ImPlotAlignmentData*>)funcTable[585])();
			#else
			return (ImPlotAlignmentData*)((delegate* unmanaged[Cdecl]<nint>)funcTable[585])();
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static ImPlotAlignmentDataPtr ImPlotAlignmentData()
		{
			ImPlotAlignmentDataPtr ret = ImPlotAlignmentDataNative();
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void DestroyNative(ImPlotAlignmentData* self)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<ImPlotAlignmentData*, void>)funcTable[586])(self);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)funcTable[586])((nint)self);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void Destroy(ImPlotAlignmentDataPtr self)
		{
			DestroyNative((ImPlotAlignmentData*)self);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void Destroy(ref ImPlotAlignmentData self)
		{
			fixed (ImPlotAlignmentData* pself = &self)
			{
				DestroyNative((ImPlotAlignmentData*)pself);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void BeginNative(ImPlotAlignmentData* self)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<ImPlotAlignmentData*, void>)funcTable[587])(self);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)funcTable[587])((nint)self);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void Begin(ImPlotAlignmentDataPtr self)
		{
			BeginNative((ImPlotAlignmentData*)self);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void Begin(ref ImPlotAlignmentData self)
		{
			fixed (ImPlotAlignmentData* pself = &self)
			{
				BeginNative((ImPlotAlignmentData*)pself);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void UpdateNative(ImPlotAlignmentData* self, float* padA, float* padB, float* deltaA, float* deltaB)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<ImPlotAlignmentData*, float*, float*, float*, float*, void>)funcTable[588])(self, padA, padB, deltaA, deltaB);
			#else
			((delegate* unmanaged[Cdecl]<nint, nint, nint, nint, nint, void>)funcTable[588])((nint)self, (nint)padA, (nint)padB, (nint)deltaA, (nint)deltaB);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void Update(ImPlotAlignmentDataPtr self, float* padA, float* padB, float* deltaA, float* deltaB)
		{
			UpdateNative((ImPlotAlignmentData*)self, padA, padB, deltaA, deltaB);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void Update(ref ImPlotAlignmentData self, float* padA, float* padB, float* deltaA, float* deltaB)
		{
			fixed (ImPlotAlignmentData* pself = &self)
			{
				UpdateNative((ImPlotAlignmentData*)pself, padA, padB, deltaA, deltaB);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void Update(ImPlotAlignmentDataPtr self, ref float padA, float* padB, float* deltaA, float* deltaB)
		{
			fixed (float* ppadA = &padA)
			{
				UpdateNative((ImPlotAlignmentData*)self, (float*)ppadA, padB, deltaA, deltaB);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void Update(ref ImPlotAlignmentData self, ref float padA, float* padB, float* deltaA, float* deltaB)
		{
			fixed (ImPlotAlignmentData* pself = &self)
			{
				fixed (float* ppadA = &padA)
				{
					UpdateNative((ImPlotAlignmentData*)pself, (float*)ppadA, padB, deltaA, deltaB);
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void Update(ImPlotAlignmentDataPtr self, float* padA, ref float padB, float* deltaA, float* deltaB)
		{
			fixed (float* ppadB = &padB)
			{
				UpdateNative((ImPlotAlignmentData*)self, padA, (float*)ppadB, deltaA, deltaB);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void Update(ref ImPlotAlignmentData self, float* padA, ref float padB, float* deltaA, float* deltaB)
		{
			fixed (ImPlotAlignmentData* pself = &self)
			{
				fixed (float* ppadB = &padB)
				{
					UpdateNative((ImPlotAlignmentData*)pself, padA, (float*)ppadB, deltaA, deltaB);
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void Update(ImPlotAlignmentDataPtr self, ref float padA, ref float padB, float* deltaA, float* deltaB)
		{
			fixed (float* ppadA = &padA)
			{
				fixed (float* ppadB = &padB)
				{
					UpdateNative((ImPlotAlignmentData*)self, (float*)ppadA, (float*)ppadB, deltaA, deltaB);
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void Update(ref ImPlotAlignmentData self, ref float padA, ref float padB, float* deltaA, float* deltaB)
		{
			fixed (ImPlotAlignmentData* pself = &self)
			{
				fixed (float* ppadA = &padA)
				{
					fixed (float* ppadB = &padB)
					{
						UpdateNative((ImPlotAlignmentData*)pself, (float*)ppadA, (float*)ppadB, deltaA, deltaB);
					}
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void Update(ImPlotAlignmentDataPtr self, float* padA, float* padB, ref float deltaA, float* deltaB)
		{
			fixed (float* pdeltaA = &deltaA)
			{
				UpdateNative((ImPlotAlignmentData*)self, padA, padB, (float*)pdeltaA, deltaB);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void Update(ref ImPlotAlignmentData self, float* padA, float* padB, ref float deltaA, float* deltaB)
		{
			fixed (ImPlotAlignmentData* pself = &self)
			{
				fixed (float* pdeltaA = &deltaA)
				{
					UpdateNative((ImPlotAlignmentData*)pself, padA, padB, (float*)pdeltaA, deltaB);
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void Update(ImPlotAlignmentDataPtr self, ref float padA, float* padB, ref float deltaA, float* deltaB)
		{
			fixed (float* ppadA = &padA)
			{
				fixed (float* pdeltaA = &deltaA)
				{
					UpdateNative((ImPlotAlignmentData*)self, (float*)ppadA, padB, (float*)pdeltaA, deltaB);
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void Update(ref ImPlotAlignmentData self, ref float padA, float* padB, ref float deltaA, float* deltaB)
		{
			fixed (ImPlotAlignmentData* pself = &self)
			{
				fixed (float* ppadA = &padA)
				{
					fixed (float* pdeltaA = &deltaA)
					{
						UpdateNative((ImPlotAlignmentData*)pself, (float*)ppadA, padB, (float*)pdeltaA, deltaB);
					}
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void Update(ImPlotAlignmentDataPtr self, float* padA, ref float padB, ref float deltaA, float* deltaB)
		{
			fixed (float* ppadB = &padB)
			{
				fixed (float* pdeltaA = &deltaA)
				{
					UpdateNative((ImPlotAlignmentData*)self, padA, (float*)ppadB, (float*)pdeltaA, deltaB);
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void Update(ref ImPlotAlignmentData self, float* padA, ref float padB, ref float deltaA, float* deltaB)
		{
			fixed (ImPlotAlignmentData* pself = &self)
			{
				fixed (float* ppadB = &padB)
				{
					fixed (float* pdeltaA = &deltaA)
					{
						UpdateNative((ImPlotAlignmentData*)pself, padA, (float*)ppadB, (float*)pdeltaA, deltaB);
					}
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void Update(ImPlotAlignmentDataPtr self, ref float padA, ref float padB, ref float deltaA, float* deltaB)
		{
			fixed (float* ppadA = &padA)
			{
				fixed (float* ppadB = &padB)
				{
					fixed (float* pdeltaA = &deltaA)
					{
						UpdateNative((ImPlotAlignmentData*)self, (float*)ppadA, (float*)ppadB, (float*)pdeltaA, deltaB);
					}
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void Update(ref ImPlotAlignmentData self, ref float padA, ref float padB, ref float deltaA, float* deltaB)
		{
			fixed (ImPlotAlignmentData* pself = &self)
			{
				fixed (float* ppadA = &padA)
				{
					fixed (float* ppadB = &padB)
					{
						fixed (float* pdeltaA = &deltaA)
						{
							UpdateNative((ImPlotAlignmentData*)pself, (float*)ppadA, (float*)ppadB, (float*)pdeltaA, deltaB);
						}
					}
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void Update(ImPlotAlignmentDataPtr self, float* padA, float* padB, float* deltaA, ref float deltaB)
		{
			fixed (float* pdeltaB = &deltaB)
			{
				UpdateNative((ImPlotAlignmentData*)self, padA, padB, deltaA, (float*)pdeltaB);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void Update(ref ImPlotAlignmentData self, float* padA, float* padB, float* deltaA, ref float deltaB)
		{
			fixed (ImPlotAlignmentData* pself = &self)
			{
				fixed (float* pdeltaB = &deltaB)
				{
					UpdateNative((ImPlotAlignmentData*)pself, padA, padB, deltaA, (float*)pdeltaB);
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void Update(ImPlotAlignmentDataPtr self, ref float padA, float* padB, float* deltaA, ref float deltaB)
		{
			fixed (float* ppadA = &padA)
			{
				fixed (float* pdeltaB = &deltaB)
				{
					UpdateNative((ImPlotAlignmentData*)self, (float*)ppadA, padB, deltaA, (float*)pdeltaB);
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void Update(ref ImPlotAlignmentData self, ref float padA, float* padB, float* deltaA, ref float deltaB)
		{
			fixed (ImPlotAlignmentData* pself = &self)
			{
				fixed (float* ppadA = &padA)
				{
					fixed (float* pdeltaB = &deltaB)
					{
						UpdateNative((ImPlotAlignmentData*)pself, (float*)ppadA, padB, deltaA, (float*)pdeltaB);
					}
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void Update(ImPlotAlignmentDataPtr self, float* padA, ref float padB, float* deltaA, ref float deltaB)
		{
			fixed (float* ppadB = &padB)
			{
				fixed (float* pdeltaB = &deltaB)
				{
					UpdateNative((ImPlotAlignmentData*)self, padA, (float*)ppadB, deltaA, (float*)pdeltaB);
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void Update(ref ImPlotAlignmentData self, float* padA, ref float padB, float* deltaA, ref float deltaB)
		{
			fixed (ImPlotAlignmentData* pself = &self)
			{
				fixed (float* ppadB = &padB)
				{
					fixed (float* pdeltaB = &deltaB)
					{
						UpdateNative((ImPlotAlignmentData*)pself, padA, (float*)ppadB, deltaA, (float*)pdeltaB);
					}
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void Update(ImPlotAlignmentDataPtr self, ref float padA, ref float padB, float* deltaA, ref float deltaB)
		{
			fixed (float* ppadA = &padA)
			{
				fixed (float* ppadB = &padB)
				{
					fixed (float* pdeltaB = &deltaB)
					{
						UpdateNative((ImPlotAlignmentData*)self, (float*)ppadA, (float*)ppadB, deltaA, (float*)pdeltaB);
					}
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void Update(ref ImPlotAlignmentData self, ref float padA, ref float padB, float* deltaA, ref float deltaB)
		{
			fixed (ImPlotAlignmentData* pself = &self)
			{
				fixed (float* ppadA = &padA)
				{
					fixed (float* ppadB = &padB)
					{
						fixed (float* pdeltaB = &deltaB)
						{
							UpdateNative((ImPlotAlignmentData*)pself, (float*)ppadA, (float*)ppadB, deltaA, (float*)pdeltaB);
						}
					}
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void Update(ImPlotAlignmentDataPtr self, float* padA, float* padB, ref float deltaA, ref float deltaB)
		{
			fixed (float* pdeltaA = &deltaA)
			{
				fixed (float* pdeltaB = &deltaB)
				{
					UpdateNative((ImPlotAlignmentData*)self, padA, padB, (float*)pdeltaA, (float*)pdeltaB);
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void Update(ref ImPlotAlignmentData self, float* padA, float* padB, ref float deltaA, ref float deltaB)
		{
			fixed (ImPlotAlignmentData* pself = &self)
			{
				fixed (float* pdeltaA = &deltaA)
				{
					fixed (float* pdeltaB = &deltaB)
					{
						UpdateNative((ImPlotAlignmentData*)pself, padA, padB, (float*)pdeltaA, (float*)pdeltaB);
					}
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void Update(ImPlotAlignmentDataPtr self, ref float padA, float* padB, ref float deltaA, ref float deltaB)
		{
			fixed (float* ppadA = &padA)
			{
				fixed (float* pdeltaA = &deltaA)
				{
					fixed (float* pdeltaB = &deltaB)
					{
						UpdateNative((ImPlotAlignmentData*)self, (float*)ppadA, padB, (float*)pdeltaA, (float*)pdeltaB);
					}
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void Update(ref ImPlotAlignmentData self, ref float padA, float* padB, ref float deltaA, ref float deltaB)
		{
			fixed (ImPlotAlignmentData* pself = &self)
			{
				fixed (float* ppadA = &padA)
				{
					fixed (float* pdeltaA = &deltaA)
					{
						fixed (float* pdeltaB = &deltaB)
						{
							UpdateNative((ImPlotAlignmentData*)pself, (float*)ppadA, padB, (float*)pdeltaA, (float*)pdeltaB);
						}
					}
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void Update(ImPlotAlignmentDataPtr self, float* padA, ref float padB, ref float deltaA, ref float deltaB)
		{
			fixed (float* ppadB = &padB)
			{
				fixed (float* pdeltaA = &deltaA)
				{
					fixed (float* pdeltaB = &deltaB)
					{
						UpdateNative((ImPlotAlignmentData*)self, padA, (float*)ppadB, (float*)pdeltaA, (float*)pdeltaB);
					}
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void Update(ref ImPlotAlignmentData self, float* padA, ref float padB, ref float deltaA, ref float deltaB)
		{
			fixed (ImPlotAlignmentData* pself = &self)
			{
				fixed (float* ppadB = &padB)
				{
					fixed (float* pdeltaA = &deltaA)
					{
						fixed (float* pdeltaB = &deltaB)
						{
							UpdateNative((ImPlotAlignmentData*)pself, padA, (float*)ppadB, (float*)pdeltaA, (float*)pdeltaB);
						}
					}
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void Update(ImPlotAlignmentDataPtr self, ref float padA, ref float padB, ref float deltaA, ref float deltaB)
		{
			fixed (float* ppadA = &padA)
			{
				fixed (float* ppadB = &padB)
				{
					fixed (float* pdeltaA = &deltaA)
					{
						fixed (float* pdeltaB = &deltaB)
						{
							UpdateNative((ImPlotAlignmentData*)self, (float*)ppadA, (float*)ppadB, (float*)pdeltaA, (float*)pdeltaB);
						}
					}
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void Update(ref ImPlotAlignmentData self, ref float padA, ref float padB, ref float deltaA, ref float deltaB)
		{
			fixed (ImPlotAlignmentData* pself = &self)
			{
				fixed (float* ppadA = &padA)
				{
					fixed (float* ppadB = &padB)
					{
						fixed (float* pdeltaA = &deltaA)
						{
							fixed (float* pdeltaB = &deltaB)
							{
								UpdateNative((ImPlotAlignmentData*)pself, (float*)ppadA, (float*)ppadB, (float*)pdeltaA, (float*)pdeltaB);
							}
						}
					}
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void EndNative(ImPlotAlignmentData* self)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<ImPlotAlignmentData*, void>)funcTable[589])(self);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)funcTable[589])((nint)self);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void End(ImPlotAlignmentDataPtr self)
		{
			EndNative((ImPlotAlignmentData*)self);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void End(ref ImPlotAlignmentData self)
		{
			fixed (ImPlotAlignmentData* pself = &self)
			{
				EndNative((ImPlotAlignmentData*)pself);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void ResetNative(ImPlotAlignmentData* self)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<ImPlotAlignmentData*, void>)funcTable[590])(self);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)funcTable[590])((nint)self);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void Reset(ImPlotAlignmentDataPtr self)
		{
			ResetNative((ImPlotAlignmentData*)self);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void Reset(ref ImPlotAlignmentData self)
		{
			fixed (ImPlotAlignmentData* pself = &self)
			{
				ResetNative((ImPlotAlignmentData*)pself);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static ImPlotItem* ImPlotItemNative()
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<ImPlotItem*>)funcTable[591])();
			#else
			return (ImPlotItem*)((delegate* unmanaged[Cdecl]<nint>)funcTable[591])();
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static ImPlotItemPtr ImPlotItem()
		{
			ImPlotItemPtr ret = ImPlotItemNative();
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void DestroyNative(ImPlotItem* self)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<ImPlotItem*, void>)funcTable[592])(self);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)funcTable[592])((nint)self);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void Destroy(ImPlotItemPtr self)
		{
			DestroyNative((ImPlotItem*)self);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void Destroy(ref ImPlotItem self)
		{
			fixed (ImPlotItem* pself = &self)
			{
				DestroyNative((ImPlotItem*)pself);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static ImPlotLegend* ImPlotLegendNative()
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<ImPlotLegend*>)funcTable[593])();
			#else
			return (ImPlotLegend*)((delegate* unmanaged[Cdecl]<nint>)funcTable[593])();
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static ImPlotLegendPtr ImPlotLegend()
		{
			ImPlotLegendPtr ret = ImPlotLegendNative();
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void DestroyNative(ImPlotLegend* self)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<ImPlotLegend*, void>)funcTable[594])(self);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)funcTable[594])((nint)self);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void Destroy(ImPlotLegendPtr self)
		{
			DestroyNative((ImPlotLegend*)self);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void Destroy(ref ImPlotLegend self)
		{
			fixed (ImPlotLegend* pself = &self)
			{
				DestroyNative((ImPlotLegend*)pself);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void ResetNative(ImPlotLegend* self)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<ImPlotLegend*, void>)funcTable[595])(self);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)funcTable[595])((nint)self);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void Reset(ImPlotLegendPtr self)
		{
			ResetNative((ImPlotLegend*)self);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void Reset(ref ImPlotLegend self)
		{
			fixed (ImPlotLegend* pself = &self)
			{
				ResetNative((ImPlotLegend*)pself);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static ImPlotItemGroup* ImPlotItemGroupNative()
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<ImPlotItemGroup*>)funcTable[596])();
			#else
			return (ImPlotItemGroup*)((delegate* unmanaged[Cdecl]<nint>)funcTable[596])();
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static ImPlotItemGroupPtr ImPlotItemGroup()
		{
			ImPlotItemGroupPtr ret = ImPlotItemGroupNative();
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void DestroyNative(ImPlotItemGroup* self)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<ImPlotItemGroup*, void>)funcTable[597])(self);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)funcTable[597])((nint)self);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void Destroy(ImPlotItemGroupPtr self)
		{
			DestroyNative((ImPlotItemGroup*)self);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void Destroy(ref ImPlotItemGroup self)
		{
			fixed (ImPlotItemGroup* pself = &self)
			{
				DestroyNative((ImPlotItemGroup*)pself);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int GetItemCountNative(ImPlotItemGroup* self)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<ImPlotItemGroup*, int>)funcTable[598])(self);
			#else
			return (int)((delegate* unmanaged[Cdecl]<nint, int>)funcTable[598])((nint)self);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static int GetItemCount(ImPlotItemGroupPtr self)
		{
			int ret = GetItemCountNative((ImPlotItemGroup*)self);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static int GetItemCount(ref ImPlotItemGroup self)
		{
			fixed (ImPlotItemGroup* pself = &self)
			{
				int ret = GetItemCountNative((ImPlotItemGroup*)pself);
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static uint GetItemIDNative(ImPlotItemGroup* self, byte* labelId)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<ImPlotItemGroup*, byte*, uint>)funcTable[599])(self, labelId);
			#else
			return (uint)((delegate* unmanaged[Cdecl]<nint, nint, uint>)funcTable[599])((nint)self, (nint)labelId);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static uint GetItemID(ImPlotItemGroupPtr self, byte* labelId)
		{
			uint ret = GetItemIDNative((ImPlotItemGroup*)self, labelId);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static uint GetItemID(ref ImPlotItemGroup self, byte* labelId)
		{
			fixed (ImPlotItemGroup* pself = &self)
			{
				uint ret = GetItemIDNative((ImPlotItemGroup*)pself, labelId);
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static uint GetItemID(ImPlotItemGroupPtr self, in byte labelId)
		{
			fixed (byte* plabelId = &labelId)
			{
				uint ret = GetItemIDNative((ImPlotItemGroup*)self, (byte*)plabelId);
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static uint GetItemID(ImPlotItemGroupPtr self, ReadOnlySpan<byte> labelId)
		{
			fixed (byte* plabelId = labelId)
			{
				uint ret = GetItemIDNative((ImPlotItemGroup*)self, (byte*)plabelId);
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static uint GetItemID(ImPlotItemGroupPtr self, string labelId)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (labelId != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(labelId);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(labelId, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			uint ret = GetItemIDNative((ImPlotItemGroup*)self, pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static uint GetItemID(ref ImPlotItemGroup self, in byte labelId)
		{
			fixed (ImPlotItemGroup* pself = &self)
			{
				fixed (byte* plabelId = &labelId)
				{
					uint ret = GetItemIDNative((ImPlotItemGroup*)pself, (byte*)plabelId);
					return ret;
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static uint GetItemID(ref ImPlotItemGroup self, ReadOnlySpan<byte> labelId)
		{
			fixed (ImPlotItemGroup* pself = &self)
			{
				fixed (byte* plabelId = labelId)
				{
					uint ret = GetItemIDNative((ImPlotItemGroup*)pself, (byte*)plabelId);
					return ret;
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static uint GetItemID(ref ImPlotItemGroup self, string labelId)
		{
			fixed (ImPlotItemGroup* pself = &self)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (labelId != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(labelId);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(labelId, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				uint ret = GetItemIDNative((ImPlotItemGroup*)pself, pStr0);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static ImPlotItem* GetItemNative(ImPlotItemGroup* self, uint id)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<ImPlotItemGroup*, uint, ImPlotItem*>)funcTable[600])(self, id);
			#else
			return (ImPlotItem*)((delegate* unmanaged[Cdecl]<nint, uint, nint>)funcTable[600])((nint)self, id);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static ImPlotItemPtr GetItem(ImPlotItemGroupPtr self, uint id)
		{
			ImPlotItemPtr ret = GetItemNative((ImPlotItemGroup*)self, id);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static ImPlotItemPtr GetItem(ref ImPlotItemGroup self, uint id)
		{
			fixed (ImPlotItemGroup* pself = &self)
			{
				ImPlotItemPtr ret = GetItemNative((ImPlotItemGroup*)pself, id);
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static ImPlotItem* GetItemNative(ImPlotItemGroup* self, byte* labelId)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<ImPlotItemGroup*, byte*, ImPlotItem*>)funcTable[601])(self, labelId);
			#else
			return (ImPlotItem*)((delegate* unmanaged[Cdecl]<nint, nint, nint>)funcTable[601])((nint)self, (nint)labelId);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static ImPlotItemPtr GetItem(ImPlotItemGroupPtr self, byte* labelId)
		{
			ImPlotItemPtr ret = GetItemNative((ImPlotItemGroup*)self, labelId);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static ImPlotItemPtr GetItem(ref ImPlotItemGroup self, byte* labelId)
		{
			fixed (ImPlotItemGroup* pself = &self)
			{
				ImPlotItemPtr ret = GetItemNative((ImPlotItemGroup*)pself, labelId);
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static ImPlotItemPtr GetItem(ImPlotItemGroupPtr self, in byte labelId)
		{
			fixed (byte* plabelId = &labelId)
			{
				ImPlotItemPtr ret = GetItemNative((ImPlotItemGroup*)self, (byte*)plabelId);
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static ImPlotItemPtr GetItem(ImPlotItemGroupPtr self, ReadOnlySpan<byte> labelId)
		{
			fixed (byte* plabelId = labelId)
			{
				ImPlotItemPtr ret = GetItemNative((ImPlotItemGroup*)self, (byte*)plabelId);
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static ImPlotItemPtr GetItem(ImPlotItemGroupPtr self, string labelId)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (labelId != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(labelId);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(labelId, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			ImPlotItemPtr ret = GetItemNative((ImPlotItemGroup*)self, pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static ImPlotItemPtr GetItem(ref ImPlotItemGroup self, in byte labelId)
		{
			fixed (ImPlotItemGroup* pself = &self)
			{
				fixed (byte* plabelId = &labelId)
				{
					ImPlotItemPtr ret = GetItemNative((ImPlotItemGroup*)pself, (byte*)plabelId);
					return ret;
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static ImPlotItemPtr GetItem(ref ImPlotItemGroup self, ReadOnlySpan<byte> labelId)
		{
			fixed (ImPlotItemGroup* pself = &self)
			{
				fixed (byte* plabelId = labelId)
				{
					ImPlotItemPtr ret = GetItemNative((ImPlotItemGroup*)pself, (byte*)plabelId);
					return ret;
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static ImPlotItemPtr GetItem(ref ImPlotItemGroup self, string labelId)
		{
			fixed (ImPlotItemGroup* pself = &self)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (labelId != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(labelId);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(labelId, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				ImPlotItemPtr ret = GetItemNative((ImPlotItemGroup*)pself, pStr0);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static ImPlotItem* GetOrAddItemNative(ImPlotItemGroup* self, uint id)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<ImPlotItemGroup*, uint, ImPlotItem*>)funcTable[602])(self, id);
			#else
			return (ImPlotItem*)((delegate* unmanaged[Cdecl]<nint, uint, nint>)funcTable[602])((nint)self, id);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static ImPlotItemPtr GetOrAddItem(ImPlotItemGroupPtr self, uint id)
		{
			ImPlotItemPtr ret = GetOrAddItemNative((ImPlotItemGroup*)self, id);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static ImPlotItemPtr GetOrAddItem(ref ImPlotItemGroup self, uint id)
		{
			fixed (ImPlotItemGroup* pself = &self)
			{
				ImPlotItemPtr ret = GetOrAddItemNative((ImPlotItemGroup*)pself, id);
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static ImPlotItem* GetItemByIndexNative(ImPlotItemGroup* self, int i)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<ImPlotItemGroup*, int, ImPlotItem*>)funcTable[603])(self, i);
			#else
			return (ImPlotItem*)((delegate* unmanaged[Cdecl]<nint, int, nint>)funcTable[603])((nint)self, i);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static ImPlotItemPtr GetItemByIndex(ImPlotItemGroupPtr self, int i)
		{
			ImPlotItemPtr ret = GetItemByIndexNative((ImPlotItemGroup*)self, i);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static ImPlotItemPtr GetItemByIndex(ref ImPlotItemGroup self, int i)
		{
			fixed (ImPlotItemGroup* pself = &self)
			{
				ImPlotItemPtr ret = GetItemByIndexNative((ImPlotItemGroup*)pself, i);
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int GetItemIndexNative(ImPlotItemGroup* self, ImPlotItem* item)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<ImPlotItemGroup*, ImPlotItem*, int>)funcTable[604])(self, item);
			#else
			return (int)((delegate* unmanaged[Cdecl]<nint, nint, int>)funcTable[604])((nint)self, (nint)item);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static int GetItemIndex(ImPlotItemGroupPtr self, ImPlotItemPtr item)
		{
			int ret = GetItemIndexNative((ImPlotItemGroup*)self, (ImPlotItem*)item);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static int GetItemIndex(ref ImPlotItemGroup self, ImPlotItemPtr item)
		{
			fixed (ImPlotItemGroup* pself = &self)
			{
				int ret = GetItemIndexNative((ImPlotItemGroup*)pself, (ImPlotItem*)item);
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static int GetItemIndex(ImPlotItemGroupPtr self, ref ImPlotItem item)
		{
			fixed (ImPlotItem* pitem = &item)
			{
				int ret = GetItemIndexNative((ImPlotItemGroup*)self, (ImPlotItem*)pitem);
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static int GetItemIndex(ref ImPlotItemGroup self, ref ImPlotItem item)
		{
			fixed (ImPlotItemGroup* pself = &self)
			{
				fixed (ImPlotItem* pitem = &item)
				{
					int ret = GetItemIndexNative((ImPlotItemGroup*)pself, (ImPlotItem*)pitem);
					return ret;
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int GetLegendCountNative(ImPlotItemGroup* self)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<ImPlotItemGroup*, int>)funcTable[605])(self);
			#else
			return (int)((delegate* unmanaged[Cdecl]<nint, int>)funcTable[605])((nint)self);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static int GetLegendCount(ImPlotItemGroupPtr self)
		{
			int ret = GetLegendCountNative((ImPlotItemGroup*)self);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static int GetLegendCount(ref ImPlotItemGroup self)
		{
			fixed (ImPlotItemGroup* pself = &self)
			{
				int ret = GetLegendCountNative((ImPlotItemGroup*)pself);
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static ImPlotItem* GetLegendItemNative(ImPlotItemGroup* self, int i)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<ImPlotItemGroup*, int, ImPlotItem*>)funcTable[606])(self, i);
			#else
			return (ImPlotItem*)((delegate* unmanaged[Cdecl]<nint, int, nint>)funcTable[606])((nint)self, i);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static ImPlotItemPtr GetLegendItem(ImPlotItemGroupPtr self, int i)
		{
			ImPlotItemPtr ret = GetLegendItemNative((ImPlotItemGroup*)self, i);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static ImPlotItemPtr GetLegendItem(ref ImPlotItemGroup self, int i)
		{
			fixed (ImPlotItemGroup* pself = &self)
			{
				ImPlotItemPtr ret = GetLegendItemNative((ImPlotItemGroup*)pself, i);
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte* GetLegendLabelNative(ImPlotItemGroup* self, int i)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<ImPlotItemGroup*, int, byte*>)funcTable[607])(self, i);
			#else
			return (byte*)((delegate* unmanaged[Cdecl]<nint, int, nint>)funcTable[607])((nint)self, i);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static byte* GetLegendLabel(ImPlotItemGroupPtr self, int i)
		{
			byte* ret = GetLegendLabelNative((ImPlotItemGroup*)self, i);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static string GetLegendLabelS(ImPlotItemGroupPtr self, int i)
		{
			string ret = Utils.DecodeStringUTF8(GetLegendLabelNative((ImPlotItemGroup*)self, i));
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static byte* GetLegendLabel(ref ImPlotItemGroup self, int i)
		{
			fixed (ImPlotItemGroup* pself = &self)
			{
				byte* ret = GetLegendLabelNative((ImPlotItemGroup*)pself, i);
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static string GetLegendLabelS(ref ImPlotItemGroup self, int i)
		{
			fixed (ImPlotItemGroup* pself = &self)
			{
				string ret = Utils.DecodeStringUTF8(GetLegendLabelNative((ImPlotItemGroup*)pself, i));
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void ResetNative(ImPlotItemGroup* self)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<ImPlotItemGroup*, void>)funcTable[608])(self);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)funcTable[608])((nint)self);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void Reset(ImPlotItemGroupPtr self)
		{
			ResetNative((ImPlotItemGroup*)self);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void Reset(ref ImPlotItemGroup self)
		{
			fixed (ImPlotItemGroup* pself = &self)
			{
				ResetNative((ImPlotItemGroup*)pself);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static ImPlotPlot* ImPlotPlotNative()
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<ImPlotPlot*>)funcTable[609])();
			#else
			return (ImPlotPlot*)((delegate* unmanaged[Cdecl]<nint>)funcTable[609])();
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static ImPlotPlotPtr ImPlotPlot()
		{
			ImPlotPlotPtr ret = ImPlotPlotNative();
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void DestroyNative(ImPlotPlot* self)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<ImPlotPlot*, void>)funcTable[610])(self);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)funcTable[610])((nint)self);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void Destroy(ImPlotPlotPtr self)
		{
			DestroyNative((ImPlotPlot*)self);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void Destroy(ref ImPlotPlot self)
		{
			fixed (ImPlotPlot* pself = &self)
			{
				DestroyNative((ImPlotPlot*)pself);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte IsInputLockedNative(ImPlotPlot* self)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<ImPlotPlot*, byte>)funcTable[611])(self);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<nint, byte>)funcTable[611])((nint)self);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool IsInputLocked(ImPlotPlotPtr self)
		{
			byte ret = IsInputLockedNative((ImPlotPlot*)self);
			return ret != 0;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool IsInputLocked(ref ImPlotPlot self)
		{
			fixed (ImPlotPlot* pself = &self)
			{
				byte ret = IsInputLockedNative((ImPlotPlot*)pself);
				return ret != 0;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void ClearTextBufferNative(ImPlotPlot* self)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<ImPlotPlot*, void>)funcTable[612])(self);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)funcTable[612])((nint)self);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void ClearTextBuffer(ImPlotPlotPtr self)
		{
			ClearTextBufferNative((ImPlotPlot*)self);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void ClearTextBuffer(ref ImPlotPlot self)
		{
			fixed (ImPlotPlot* pself = &self)
			{
				ClearTextBufferNative((ImPlotPlot*)pself);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void SetTitleNative(ImPlotPlot* self, byte* title)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<ImPlotPlot*, byte*, void>)funcTable[613])(self, title);
			#else
			((delegate* unmanaged[Cdecl]<nint, nint, void>)funcTable[613])((nint)self, (nint)title);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void SetTitle(ImPlotPlotPtr self, byte* title)
		{
			SetTitleNative((ImPlotPlot*)self, title);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void SetTitle(ref ImPlotPlot self, byte* title)
		{
			fixed (ImPlotPlot* pself = &self)
			{
				SetTitleNative((ImPlotPlot*)pself, title);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void SetTitle(ImPlotPlotPtr self, in byte title)
		{
			fixed (byte* ptitle = &title)
			{
				SetTitleNative((ImPlotPlot*)self, (byte*)ptitle);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void SetTitle(ImPlotPlotPtr self, ReadOnlySpan<byte> title)
		{
			fixed (byte* ptitle = title)
			{
				SetTitleNative((ImPlotPlot*)self, (byte*)ptitle);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void SetTitle(ImPlotPlotPtr self, string title)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (title != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(title);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(title, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			SetTitleNative((ImPlotPlot*)self, pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void SetTitle(ref ImPlotPlot self, in byte title)
		{
			fixed (ImPlotPlot* pself = &self)
			{
				fixed (byte* ptitle = &title)
				{
					SetTitleNative((ImPlotPlot*)pself, (byte*)ptitle);
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void SetTitle(ref ImPlotPlot self, ReadOnlySpan<byte> title)
		{
			fixed (ImPlotPlot* pself = &self)
			{
				fixed (byte* ptitle = title)
				{
					SetTitleNative((ImPlotPlot*)pself, (byte*)ptitle);
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void SetTitle(ref ImPlotPlot self, string title)
		{
			fixed (ImPlotPlot* pself = &self)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (title != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(title);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(title, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				SetTitleNative((ImPlotPlot*)pself, pStr0);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte HasTitleNative(ImPlotPlot* self)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<ImPlotPlot*, byte>)funcTable[614])(self);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<nint, byte>)funcTable[614])((nint)self);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool HasTitle(ImPlotPlotPtr self)
		{
			byte ret = HasTitleNative((ImPlotPlot*)self);
			return ret != 0;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool HasTitle(ref ImPlotPlot self)
		{
			fixed (ImPlotPlot* pself = &self)
			{
				byte ret = HasTitleNative((ImPlotPlot*)pself);
				return ret != 0;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte* GetTitleNative(ImPlotPlot* self)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<ImPlotPlot*, byte*>)funcTable[615])(self);
			#else
			return (byte*)((delegate* unmanaged[Cdecl]<nint, nint>)funcTable[615])((nint)self);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static byte* GetTitle(ImPlotPlotPtr self)
		{
			byte* ret = GetTitleNative((ImPlotPlot*)self);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static string GetTitleS(ImPlotPlotPtr self)
		{
			string ret = Utils.DecodeStringUTF8(GetTitleNative((ImPlotPlot*)self));
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static byte* GetTitle(ref ImPlotPlot self)
		{
			fixed (ImPlotPlot* pself = &self)
			{
				byte* ret = GetTitleNative((ImPlotPlot*)pself);
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static string GetTitleS(ref ImPlotPlot self)
		{
			fixed (ImPlotPlot* pself = &self)
			{
				string ret = Utils.DecodeStringUTF8(GetTitleNative((ImPlotPlot*)pself));
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static ImPlotAxis* XAxisNative(ImPlotPlot* self, int i)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<ImPlotPlot*, int, ImPlotAxis*>)funcTable[616])(self, i);
			#else
			return (ImPlotAxis*)((delegate* unmanaged[Cdecl]<nint, int, nint>)funcTable[616])((nint)self, i);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static ImPlotAxisPtr XAxis(ImPlotPlotPtr self, int i)
		{
			ImPlotAxisPtr ret = XAxisNative((ImPlotPlot*)self, i);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static ImPlotAxisPtr XAxis(ref ImPlotPlot self, int i)
		{
			fixed (ImPlotPlot* pself = &self)
			{
				ImPlotAxisPtr ret = XAxisNative((ImPlotPlot*)pself, i);
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static ImPlotAxis* ImPlotPlotXAxisConstNative(ImPlotPlot* self, int i)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<ImPlotPlot*, int, ImPlotAxis*>)funcTable[617])(self, i);
			#else
			return (ImPlotAxis*)((delegate* unmanaged[Cdecl]<nint, int, nint>)funcTable[617])((nint)self, i);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static ImPlotAxisPtr ImPlotPlotXAxisConst(ImPlotPlotPtr self, int i)
		{
			ImPlotAxisPtr ret = ImPlotPlotXAxisConstNative((ImPlotPlot*)self, i);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static ImPlotAxisPtr ImPlotPlotXAxisConst(ref ImPlotPlot self, int i)
		{
			fixed (ImPlotPlot* pself = &self)
			{
				ImPlotAxisPtr ret = ImPlotPlotXAxisConstNative((ImPlotPlot*)pself, i);
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static ImPlotAxis* YAxisNative(ImPlotPlot* self, int i)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<ImPlotPlot*, int, ImPlotAxis*>)funcTable[618])(self, i);
			#else
			return (ImPlotAxis*)((delegate* unmanaged[Cdecl]<nint, int, nint>)funcTable[618])((nint)self, i);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static ImPlotAxisPtr YAxis(ImPlotPlotPtr self, int i)
		{
			ImPlotAxisPtr ret = YAxisNative((ImPlotPlot*)self, i);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static ImPlotAxisPtr YAxis(ref ImPlotPlot self, int i)
		{
			fixed (ImPlotPlot* pself = &self)
			{
				ImPlotAxisPtr ret = YAxisNative((ImPlotPlot*)pself, i);
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static ImPlotAxis* ImPlotPlotYAxisConstNative(ImPlotPlot* self, int i)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<ImPlotPlot*, int, ImPlotAxis*>)funcTable[619])(self, i);
			#else
			return (ImPlotAxis*)((delegate* unmanaged[Cdecl]<nint, int, nint>)funcTable[619])((nint)self, i);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static ImPlotAxisPtr ImPlotPlotYAxisConst(ImPlotPlotPtr self, int i)
		{
			ImPlotAxisPtr ret = ImPlotPlotYAxisConstNative((ImPlotPlot*)self, i);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static ImPlotAxisPtr ImPlotPlotYAxisConst(ref ImPlotPlot self, int i)
		{
			fixed (ImPlotPlot* pself = &self)
			{
				ImPlotAxisPtr ret = ImPlotPlotYAxisConstNative((ImPlotPlot*)pself, i);
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int EnabledAxesXNative(ImPlotPlot* self)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<ImPlotPlot*, int>)funcTable[620])(self);
			#else
			return (int)((delegate* unmanaged[Cdecl]<nint, int>)funcTable[620])((nint)self);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static int EnabledAxesX(ImPlotPlotPtr self)
		{
			int ret = EnabledAxesXNative((ImPlotPlot*)self);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static int EnabledAxesX(ref ImPlotPlot self)
		{
			fixed (ImPlotPlot* pself = &self)
			{
				int ret = EnabledAxesXNative((ImPlotPlot*)pself);
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int EnabledAxesYNative(ImPlotPlot* self)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<ImPlotPlot*, int>)funcTable[621])(self);
			#else
			return (int)((delegate* unmanaged[Cdecl]<nint, int>)funcTable[621])((nint)self);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static int EnabledAxesY(ImPlotPlotPtr self)
		{
			int ret = EnabledAxesYNative((ImPlotPlot*)self);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static int EnabledAxesY(ref ImPlotPlot self)
		{
			fixed (ImPlotPlot* pself = &self)
			{
				int ret = EnabledAxesYNative((ImPlotPlot*)pself);
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void SetAxisLabelNative(ImPlotPlot* self, ImPlotAxis* axis, byte* label)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<ImPlotPlot*, ImPlotAxis*, byte*, void>)funcTable[622])(self, axis, label);
			#else
			((delegate* unmanaged[Cdecl]<nint, nint, nint, void>)funcTable[622])((nint)self, (nint)axis, (nint)label);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void SetAxisLabel(ImPlotPlotPtr self, ImPlotAxisPtr axis, byte* label)
		{
			SetAxisLabelNative((ImPlotPlot*)self, (ImPlotAxis*)axis, label);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void SetAxisLabel(ref ImPlotPlot self, ImPlotAxisPtr axis, byte* label)
		{
			fixed (ImPlotPlot* pself = &self)
			{
				SetAxisLabelNative((ImPlotPlot*)pself, (ImPlotAxis*)axis, label);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void SetAxisLabel(ImPlotPlotPtr self, ref ImPlotAxis axis, byte* label)
		{
			fixed (ImPlotAxis* paxis = &axis)
			{
				SetAxisLabelNative((ImPlotPlot*)self, (ImPlotAxis*)paxis, label);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void SetAxisLabel(ref ImPlotPlot self, ref ImPlotAxis axis, byte* label)
		{
			fixed (ImPlotPlot* pself = &self)
			{
				fixed (ImPlotAxis* paxis = &axis)
				{
					SetAxisLabelNative((ImPlotPlot*)pself, (ImPlotAxis*)paxis, label);
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void SetAxisLabel(ImPlotPlotPtr self, ImPlotAxisPtr axis, in byte label)
		{
			fixed (byte* plabel = &label)
			{
				SetAxisLabelNative((ImPlotPlot*)self, (ImPlotAxis*)axis, (byte*)plabel);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void SetAxisLabel(ImPlotPlotPtr self, ImPlotAxisPtr axis, ReadOnlySpan<byte> label)
		{
			fixed (byte* plabel = label)
			{
				SetAxisLabelNative((ImPlotPlot*)self, (ImPlotAxis*)axis, (byte*)plabel);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void SetAxisLabel(ImPlotPlotPtr self, ImPlotAxisPtr axis, string label)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			SetAxisLabelNative((ImPlotPlot*)self, (ImPlotAxis*)axis, pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void SetAxisLabel(ref ImPlotPlot self, ImPlotAxisPtr axis, in byte label)
		{
			fixed (ImPlotPlot* pself = &self)
			{
				fixed (byte* plabel = &label)
				{
					SetAxisLabelNative((ImPlotPlot*)pself, (ImPlotAxis*)axis, (byte*)plabel);
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void SetAxisLabel(ref ImPlotPlot self, ImPlotAxisPtr axis, ReadOnlySpan<byte> label)
		{
			fixed (ImPlotPlot* pself = &self)
			{
				fixed (byte* plabel = label)
				{
					SetAxisLabelNative((ImPlotPlot*)pself, (ImPlotAxis*)axis, (byte*)plabel);
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void SetAxisLabel(ref ImPlotPlot self, ImPlotAxisPtr axis, string label)
		{
			fixed (ImPlotPlot* pself = &self)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (label != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(label);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				SetAxisLabelNative((ImPlotPlot*)pself, (ImPlotAxis*)axis, pStr0);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void SetAxisLabel(ImPlotPlotPtr self, ref ImPlotAxis axis, in byte label)
		{
			fixed (ImPlotAxis* paxis = &axis)
			{
				fixed (byte* plabel = &label)
				{
					SetAxisLabelNative((ImPlotPlot*)self, (ImPlotAxis*)paxis, (byte*)plabel);
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void SetAxisLabel(ImPlotPlotPtr self, ref ImPlotAxis axis, ReadOnlySpan<byte> label)
		{
			fixed (ImPlotAxis* paxis = &axis)
			{
				fixed (byte* plabel = label)
				{
					SetAxisLabelNative((ImPlotPlot*)self, (ImPlotAxis*)paxis, (byte*)plabel);
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void SetAxisLabel(ImPlotPlotPtr self, ref ImPlotAxis axis, string label)
		{
			fixed (ImPlotAxis* paxis = &axis)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (label != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(label);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				SetAxisLabelNative((ImPlotPlot*)self, (ImPlotAxis*)paxis, pStr0);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void SetAxisLabel(ref ImPlotPlot self, ref ImPlotAxis axis, in byte label)
		{
			fixed (ImPlotPlot* pself = &self)
			{
				fixed (ImPlotAxis* paxis = &axis)
				{
					fixed (byte* plabel = &label)
					{
						SetAxisLabelNative((ImPlotPlot*)pself, (ImPlotAxis*)paxis, (byte*)plabel);
					}
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void SetAxisLabel(ref ImPlotPlot self, ref ImPlotAxis axis, ReadOnlySpan<byte> label)
		{
			fixed (ImPlotPlot* pself = &self)
			{
				fixed (ImPlotAxis* paxis = &axis)
				{
					fixed (byte* plabel = label)
					{
						SetAxisLabelNative((ImPlotPlot*)pself, (ImPlotAxis*)paxis, (byte*)plabel);
					}
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void SetAxisLabel(ref ImPlotPlot self, ref ImPlotAxis axis, string label)
		{
			fixed (ImPlotPlot* pself = &self)
			{
				fixed (ImPlotAxis* paxis = &axis)
				{
					byte* pStr0 = null;
					int pStrSize0 = 0;
					if (label != null)
					{
						pStrSize0 = Utils.GetByteCountUTF8(label);
						if (pStrSize0 >= Utils.MaxStackallocSize)
						{
							pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
						}
						else
						{
							byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
							pStr0 = pStrStack0;
						}
						int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
						pStr0[pStrOffset0] = 0;
					}
					SetAxisLabelNative((ImPlotPlot*)pself, (ImPlotAxis*)paxis, pStr0);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte* GetAxisLabelNative(ImPlotPlot* self, ImPlotAxis axis)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<ImPlotPlot*, ImPlotAxis, byte*>)funcTable[623])(self, axis);
			#else
			return (byte*)((delegate* unmanaged[Cdecl]<nint, ImPlotAxis, nint>)funcTable[623])((nint)self, axis);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static byte* GetAxisLabel(ImPlotPlotPtr self, ImPlotAxis axis)
		{
			byte* ret = GetAxisLabelNative((ImPlotPlot*)self, axis);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static string GetAxisLabelS(ImPlotPlotPtr self, ImPlotAxis axis)
		{
			string ret = Utils.DecodeStringUTF8(GetAxisLabelNative((ImPlotPlot*)self, axis));
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static byte* GetAxisLabel(ref ImPlotPlot self, ImPlotAxis axis)
		{
			fixed (ImPlotPlot* pself = &self)
			{
				byte* ret = GetAxisLabelNative((ImPlotPlot*)pself, axis);
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static string GetAxisLabelS(ref ImPlotPlot self, ImPlotAxis axis)
		{
			fixed (ImPlotPlot* pself = &self)
			{
				string ret = Utils.DecodeStringUTF8(GetAxisLabelNative((ImPlotPlot*)pself, axis));
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static ImPlotSubplot* ImPlotSubplotNative()
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<ImPlotSubplot*>)funcTable[624])();
			#else
			return (ImPlotSubplot*)((delegate* unmanaged[Cdecl]<nint>)funcTable[624])();
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static ImPlotSubplotPtr ImPlotSubplot()
		{
			ImPlotSubplotPtr ret = ImPlotSubplotNative();
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void DestroyNative(ImPlotSubplot* self)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<ImPlotSubplot*, void>)funcTable[625])(self);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)funcTable[625])((nint)self);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void Destroy(ImPlotSubplotPtr self)
		{
			DestroyNative((ImPlotSubplot*)self);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void Destroy(ref ImPlotSubplot self)
		{
			fixed (ImPlotSubplot* pself = &self)
			{
				DestroyNative((ImPlotSubplot*)pself);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static ImPlotNextPlotData* ImPlotNextPlotDataNative()
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<ImPlotNextPlotData*>)funcTable[626])();
			#else
			return (ImPlotNextPlotData*)((delegate* unmanaged[Cdecl]<nint>)funcTable[626])();
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static ImPlotNextPlotDataPtr ImPlotNextPlotData()
		{
			ImPlotNextPlotDataPtr ret = ImPlotNextPlotDataNative();
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void DestroyNative(ImPlotNextPlotData* self)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<ImPlotNextPlotData*, void>)funcTable[627])(self);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)funcTable[627])((nint)self);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void Destroy(ImPlotNextPlotDataPtr self)
		{
			DestroyNative((ImPlotNextPlotData*)self);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void Destroy(ref ImPlotNextPlotData self)
		{
			fixed (ImPlotNextPlotData* pself = &self)
			{
				DestroyNative((ImPlotNextPlotData*)pself);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void ResetNative(ImPlotNextPlotData* self)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<ImPlotNextPlotData*, void>)funcTable[628])(self);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)funcTable[628])((nint)self);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void Reset(ImPlotNextPlotDataPtr self)
		{
			ResetNative((ImPlotNextPlotData*)self);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void Reset(ref ImPlotNextPlotData self)
		{
			fixed (ImPlotNextPlotData* pself = &self)
			{
				ResetNative((ImPlotNextPlotData*)pself);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static ImPlotNextItemData* ImPlotNextItemDataNative()
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<ImPlotNextItemData*>)funcTable[629])();
			#else
			return (ImPlotNextItemData*)((delegate* unmanaged[Cdecl]<nint>)funcTable[629])();
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static ImPlotNextItemDataPtr ImPlotNextItemData()
		{
			ImPlotNextItemDataPtr ret = ImPlotNextItemDataNative();
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void DestroyNative(ImPlotNextItemData* self)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<ImPlotNextItemData*, void>)funcTable[630])(self);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)funcTable[630])((nint)self);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void Destroy(ImPlotNextItemDataPtr self)
		{
			DestroyNative((ImPlotNextItemData*)self);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void Destroy(ref ImPlotNextItemData self)
		{
			fixed (ImPlotNextItemData* pself = &self)
			{
				DestroyNative((ImPlotNextItemData*)pself);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void ResetNative(ImPlotNextItemData* self)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<ImPlotNextItemData*, void>)funcTable[631])(self);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)funcTable[631])((nint)self);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void Reset(ImPlotNextItemDataPtr self)
		{
			ResetNative((ImPlotNextItemData*)self);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void Reset(ref ImPlotNextItemData self)
		{
			fixed (ImPlotNextItemData* pself = &self)
			{
				ResetNative((ImPlotNextItemData*)pself);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void InitializeNative(ImPlotContext* ctx)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<ImPlotContext*, void>)funcTable[632])(ctx);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)funcTable[632])((nint)ctx);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void Initialize(ImPlotContextPtr ctx)
		{
			InitializeNative((ImPlotContext*)ctx);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void Initialize(ref ImPlotContext ctx)
		{
			fixed (ImPlotContext* pctx = &ctx)
			{
				InitializeNative((ImPlotContext*)pctx);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void ResetCtxForNextPlotNative(ImPlotContext* ctx)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<ImPlotContext*, void>)funcTable[633])(ctx);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)funcTable[633])((nint)ctx);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void ResetCtxForNextPlot(ImPlotContextPtr ctx)
		{
			ResetCtxForNextPlotNative((ImPlotContext*)ctx);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void ResetCtxForNextPlot(ref ImPlotContext ctx)
		{
			fixed (ImPlotContext* pctx = &ctx)
			{
				ResetCtxForNextPlotNative((ImPlotContext*)pctx);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void ResetCtxForNextAlignedPlotsNative(ImPlotContext* ctx)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<ImPlotContext*, void>)funcTable[634])(ctx);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)funcTable[634])((nint)ctx);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void ResetCtxForNextAlignedPlots(ImPlotContextPtr ctx)
		{
			ResetCtxForNextAlignedPlotsNative((ImPlotContext*)ctx);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void ResetCtxForNextAlignedPlots(ref ImPlotContext ctx)
		{
			fixed (ImPlotContext* pctx = &ctx)
			{
				ResetCtxForNextAlignedPlotsNative((ImPlotContext*)pctx);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void ResetCtxForNextSubplotNative(ImPlotContext* ctx)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<ImPlotContext*, void>)funcTable[635])(ctx);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)funcTable[635])((nint)ctx);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void ResetCtxForNextSubplot(ImPlotContextPtr ctx)
		{
			ResetCtxForNextSubplotNative((ImPlotContext*)ctx);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void ResetCtxForNextSubplot(ref ImPlotContext ctx)
		{
			fixed (ImPlotContext* pctx = &ctx)
			{
				ResetCtxForNextSubplotNative((ImPlotContext*)pctx);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static ImPlotPlot* GetPlotNative(byte* title)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<byte*, ImPlotPlot*>)funcTable[636])(title);
			#else
			return (ImPlotPlot*)((delegate* unmanaged[Cdecl]<nint, nint>)funcTable[636])((nint)title);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static ImPlotPlotPtr GetPlot(byte* title)
		{
			ImPlotPlotPtr ret = GetPlotNative(title);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static ImPlotPlotPtr GetPlot(in byte title)
		{
			fixed (byte* ptitle = &title)
			{
				ImPlotPlotPtr ret = GetPlotNative((byte*)ptitle);
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static ImPlotPlotPtr GetPlot(ReadOnlySpan<byte> title)
		{
			fixed (byte* ptitle = title)
			{
				ImPlotPlotPtr ret = GetPlotNative((byte*)ptitle);
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static ImPlotPlotPtr GetPlot(string title)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (title != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(title);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(title, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			ImPlotPlotPtr ret = GetPlotNative(pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static ImPlotPlot* GetCurrentPlotNative()
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<ImPlotPlot*>)funcTable[637])();
			#else
			return (ImPlotPlot*)((delegate* unmanaged[Cdecl]<nint>)funcTable[637])();
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static ImPlotPlotPtr GetCurrentPlot()
		{
			ImPlotPlotPtr ret = GetCurrentPlotNative();
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void BustPlotCacheNative()
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<void>)funcTable[638])();
			#else
			((delegate* unmanaged[Cdecl]<void>)funcTable[638])();
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void BustPlotCache()
		{
			BustPlotCacheNative();
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void ShowPlotContextMenuNative(ImPlotPlot* plot)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<ImPlotPlot*, void>)funcTable[639])(plot);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)funcTable[639])((nint)plot);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void ShowPlotContextMenu(ImPlotPlotPtr plot)
		{
			ShowPlotContextMenuNative((ImPlotPlot*)plot);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void ShowPlotContextMenu(ref ImPlotPlot plot)
		{
			fixed (ImPlotPlot* pplot = &plot)
			{
				ShowPlotContextMenuNative((ImPlotPlot*)pplot);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void SetupLockNative()
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<void>)funcTable[640])();
			#else
			((delegate* unmanaged[Cdecl]<void>)funcTable[640])();
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void SetupLock()
		{
			SetupLockNative();
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void SubplotNextCellNative()
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<void>)funcTable[641])();
			#else
			((delegate* unmanaged[Cdecl]<void>)funcTable[641])();
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void SubplotNextCell()
		{
			SubplotNextCellNative();
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void ShowSubplotsContextMenuNative(ImPlotSubplot* subplot)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<ImPlotSubplot*, void>)funcTable[642])(subplot);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)funcTable[642])((nint)subplot);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void ShowSubplotsContextMenu(ImPlotSubplotPtr subplot)
		{
			ShowSubplotsContextMenuNative((ImPlotSubplot*)subplot);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void ShowSubplotsContextMenu(ref ImPlotSubplot subplot)
		{
			fixed (ImPlotSubplot* psubplot = &subplot)
			{
				ShowSubplotsContextMenuNative((ImPlotSubplot*)psubplot);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte BeginItemNative(byte* labelId, ImPlotItemFlags flags, ImPlotCol recolorFrom)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<byte*, ImPlotItemFlags, ImPlotCol, byte>)funcTable[643])(labelId, flags, recolorFrom);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<nint, ImPlotItemFlags, ImPlotCol, byte>)funcTable[643])((nint)labelId, flags, recolorFrom);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool BeginItem(byte* labelId, ImPlotItemFlags flags, ImPlotCol recolorFrom)
		{
			byte ret = BeginItemNative(labelId, flags, recolorFrom);
			return ret != 0;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool BeginItem(byte* labelId, ImPlotItemFlags flags)
		{
			byte ret = BeginItemNative(labelId, flags, (ImPlotCol)(-1));
			return ret != 0;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool BeginItem(byte* labelId)
		{
			byte ret = BeginItemNative(labelId, (ImPlotItemFlags)(0), (ImPlotCol)(-1));
			return ret != 0;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool BeginItem(byte* labelId, ImPlotCol recolorFrom)
		{
			byte ret = BeginItemNative(labelId, (ImPlotItemFlags)(0), recolorFrom);
			return ret != 0;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool BeginItem(in byte labelId, ImPlotItemFlags flags, ImPlotCol recolorFrom)
		{
			fixed (byte* plabelId = &labelId)
			{
				byte ret = BeginItemNative((byte*)plabelId, flags, recolorFrom);
				return ret != 0;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool BeginItem(in byte labelId, ImPlotItemFlags flags)
		{
			fixed (byte* plabelId = &labelId)
			{
				byte ret = BeginItemNative((byte*)plabelId, flags, (ImPlotCol)(-1));
				return ret != 0;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool BeginItem(in byte labelId)
		{
			fixed (byte* plabelId = &labelId)
			{
				byte ret = BeginItemNative((byte*)plabelId, (ImPlotItemFlags)(0), (ImPlotCol)(-1));
				return ret != 0;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool BeginItem(in byte labelId, ImPlotCol recolorFrom)
		{
			fixed (byte* plabelId = &labelId)
			{
				byte ret = BeginItemNative((byte*)plabelId, (ImPlotItemFlags)(0), recolorFrom);
				return ret != 0;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool BeginItem(ReadOnlySpan<byte> labelId, ImPlotItemFlags flags, ImPlotCol recolorFrom)
		{
			fixed (byte* plabelId = labelId)
			{
				byte ret = BeginItemNative((byte*)plabelId, flags, recolorFrom);
				return ret != 0;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool BeginItem(ReadOnlySpan<byte> labelId, ImPlotItemFlags flags)
		{
			fixed (byte* plabelId = labelId)
			{
				byte ret = BeginItemNative((byte*)plabelId, flags, (ImPlotCol)(-1));
				return ret != 0;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool BeginItem(ReadOnlySpan<byte> labelId)
		{
			fixed (byte* plabelId = labelId)
			{
				byte ret = BeginItemNative((byte*)plabelId, (ImPlotItemFlags)(0), (ImPlotCol)(-1));
				return ret != 0;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool BeginItem(ReadOnlySpan<byte> labelId, ImPlotCol recolorFrom)
		{
			fixed (byte* plabelId = labelId)
			{
				byte ret = BeginItemNative((byte*)plabelId, (ImPlotItemFlags)(0), recolorFrom);
				return ret != 0;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool BeginItem(string labelId, ImPlotItemFlags flags, ImPlotCol recolorFrom)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (labelId != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(labelId);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(labelId, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = BeginItemNative(pStr0, flags, recolorFrom);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool BeginItem(string labelId, ImPlotItemFlags flags)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (labelId != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(labelId);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(labelId, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = BeginItemNative(pStr0, flags, (ImPlotCol)(-1));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool BeginItem(string labelId)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (labelId != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(labelId);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(labelId, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = BeginItemNative(pStr0, (ImPlotItemFlags)(0), (ImPlotCol)(-1));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool BeginItem(string labelId, ImPlotCol recolorFrom)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (labelId != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(labelId);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(labelId, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = BeginItemNative(pStr0, (ImPlotItemFlags)(0), recolorFrom);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void EndItemNative()
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<void>)funcTable[644])();
			#else
			((delegate* unmanaged[Cdecl]<void>)funcTable[644])();
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void EndItem()
		{
			EndItemNative();
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static ImPlotItem* RegisterOrGetItemNative(byte* labelId, ImPlotItemFlags flags, bool* justCreated)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<byte*, ImPlotItemFlags, bool*, ImPlotItem*>)funcTable[645])(labelId, flags, justCreated);
			#else
			return (ImPlotItem*)((delegate* unmanaged[Cdecl]<nint, ImPlotItemFlags, nint, nint>)funcTable[645])((nint)labelId, flags, (nint)justCreated);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static ImPlotItemPtr RegisterOrGetItem(byte* labelId, ImPlotItemFlags flags, bool* justCreated)
		{
			ImPlotItemPtr ret = RegisterOrGetItemNative(labelId, flags, justCreated);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static ImPlotItemPtr RegisterOrGetItem(byte* labelId, ImPlotItemFlags flags)
		{
			ImPlotItemPtr ret = RegisterOrGetItemNative(labelId, flags, (bool*)(default));
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static ImPlotItemPtr RegisterOrGetItem(in byte labelId, ImPlotItemFlags flags, bool* justCreated)
		{
			fixed (byte* plabelId = &labelId)
			{
				ImPlotItemPtr ret = RegisterOrGetItemNative((byte*)plabelId, flags, justCreated);
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static ImPlotItemPtr RegisterOrGetItem(in byte labelId, ImPlotItemFlags flags)
		{
			fixed (byte* plabelId = &labelId)
			{
				ImPlotItemPtr ret = RegisterOrGetItemNative((byte*)plabelId, flags, (bool*)(default));
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static ImPlotItemPtr RegisterOrGetItem(ReadOnlySpan<byte> labelId, ImPlotItemFlags flags, bool* justCreated)
		{
			fixed (byte* plabelId = labelId)
			{
				ImPlotItemPtr ret = RegisterOrGetItemNative((byte*)plabelId, flags, justCreated);
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static ImPlotItemPtr RegisterOrGetItem(ReadOnlySpan<byte> labelId, ImPlotItemFlags flags)
		{
			fixed (byte* plabelId = labelId)
			{
				ImPlotItemPtr ret = RegisterOrGetItemNative((byte*)plabelId, flags, (bool*)(default));
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static ImPlotItemPtr RegisterOrGetItem(string labelId, ImPlotItemFlags flags, bool* justCreated)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (labelId != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(labelId);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(labelId, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			ImPlotItemPtr ret = RegisterOrGetItemNative(pStr0, flags, justCreated);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static ImPlotItemPtr RegisterOrGetItem(string labelId, ImPlotItemFlags flags)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (labelId != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(labelId);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(labelId, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			ImPlotItemPtr ret = RegisterOrGetItemNative(pStr0, flags, (bool*)(default));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}
	}
}
