// ------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
// ------------------------------------------------------------------------------

using System;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;
using HexaGen.Runtime;
using System.Numerics;
using Hexa.NET.ImGui;

namespace Hexa.NET.ImPlot
{
	public unsafe partial class ImPlot
	{

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool ColormapSlider(byte* label, ref float t, Vector4* output, ReadOnlySpan<byte> format, ImPlotColormap cmap)
		{
			fixed (float* pt = &t)
			{
				fixed (byte* pformat = format)
				{
					byte ret = ColormapSliderNative(label, (float*)pt, output, (byte*)pformat, cmap);
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool ColormapSlider(byte* label, ref float t, Vector4* output, ReadOnlySpan<byte> format)
		{
			fixed (float* pt = &t)
			{
				fixed (byte* pformat = format)
				{
					byte ret = ColormapSliderNative(label, (float*)pt, output, (byte*)pformat, (ImPlotColormap)(-1));
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool ColormapSlider(byte* label, ref float t, ReadOnlySpan<byte> format)
		{
			fixed (float* pt = &t)
			{
				fixed (byte* pformat = format)
				{
					byte ret = ColormapSliderNative(label, (float*)pt, (Vector4*)(default), (byte*)pformat, (ImPlotColormap)(-1));
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool ColormapSlider(byte* label, ref float t, ReadOnlySpan<byte> format, ImPlotColormap cmap)
		{
			fixed (float* pt = &t)
			{
				fixed (byte* pformat = format)
				{
					byte ret = ColormapSliderNative(label, (float*)pt, (Vector4*)(default), (byte*)pformat, cmap);
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool ColormapSlider(byte* label, ref float t, Vector4* output, string format, ImPlotColormap cmap)
		{
			fixed (float* pt = &t)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (format != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(format);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(format, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				byte ret = ColormapSliderNative(label, (float*)pt, output, pStr0, cmap);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret != 0;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool ColormapSlider(byte* label, ref float t, Vector4* output, string format)
		{
			fixed (float* pt = &t)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (format != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(format);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(format, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				byte ret = ColormapSliderNative(label, (float*)pt, output, pStr0, (ImPlotColormap)(-1));
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret != 0;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool ColormapSlider(byte* label, ref float t, string format)
		{
			fixed (float* pt = &t)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (format != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(format);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(format, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				byte ret = ColormapSliderNative(label, (float*)pt, (Vector4*)(default), pStr0, (ImPlotColormap)(-1));
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret != 0;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool ColormapSlider(byte* label, ref float t, string format, ImPlotColormap cmap)
		{
			fixed (float* pt = &t)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (format != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(format);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(format, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				byte ret = ColormapSliderNative(label, (float*)pt, (Vector4*)(default), pStr0, cmap);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret != 0;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool ColormapSlider(in byte label, ref float t, Vector4* output, in byte format, ImPlotColormap cmap)
		{
			fixed (byte* plabel = &label)
			{
				fixed (float* pt = &t)
				{
					fixed (byte* pformat = &format)
					{
						byte ret = ColormapSliderNative((byte*)plabel, (float*)pt, output, (byte*)pformat, cmap);
						return ret != 0;
					}
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool ColormapSlider(in byte label, ref float t, Vector4* output, in byte format)
		{
			fixed (byte* plabel = &label)
			{
				fixed (float* pt = &t)
				{
					fixed (byte* pformat = &format)
					{
						byte ret = ColormapSliderNative((byte*)plabel, (float*)pt, output, (byte*)pformat, (ImPlotColormap)(-1));
						return ret != 0;
					}
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool ColormapSlider(in byte label, ref float t, in byte format)
		{
			fixed (byte* plabel = &label)
			{
				fixed (float* pt = &t)
				{
					fixed (byte* pformat = &format)
					{
						byte ret = ColormapSliderNative((byte*)plabel, (float*)pt, (Vector4*)(default), (byte*)pformat, (ImPlotColormap)(-1));
						return ret != 0;
					}
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool ColormapSlider(in byte label, ref float t, in byte format, ImPlotColormap cmap)
		{
			fixed (byte* plabel = &label)
			{
				fixed (float* pt = &t)
				{
					fixed (byte* pformat = &format)
					{
						byte ret = ColormapSliderNative((byte*)plabel, (float*)pt, (Vector4*)(default), (byte*)pformat, cmap);
						return ret != 0;
					}
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool ColormapSlider(ReadOnlySpan<byte> label, ref float t, Vector4* output, ReadOnlySpan<byte> format, ImPlotColormap cmap)
		{
			fixed (byte* plabel = label)
			{
				fixed (float* pt = &t)
				{
					fixed (byte* pformat = format)
					{
						byte ret = ColormapSliderNative((byte*)plabel, (float*)pt, output, (byte*)pformat, cmap);
						return ret != 0;
					}
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool ColormapSlider(ReadOnlySpan<byte> label, ref float t, Vector4* output, ReadOnlySpan<byte> format)
		{
			fixed (byte* plabel = label)
			{
				fixed (float* pt = &t)
				{
					fixed (byte* pformat = format)
					{
						byte ret = ColormapSliderNative((byte*)plabel, (float*)pt, output, (byte*)pformat, (ImPlotColormap)(-1));
						return ret != 0;
					}
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool ColormapSlider(ReadOnlySpan<byte> label, ref float t, ReadOnlySpan<byte> format)
		{
			fixed (byte* plabel = label)
			{
				fixed (float* pt = &t)
				{
					fixed (byte* pformat = format)
					{
						byte ret = ColormapSliderNative((byte*)plabel, (float*)pt, (Vector4*)(default), (byte*)pformat, (ImPlotColormap)(-1));
						return ret != 0;
					}
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool ColormapSlider(ReadOnlySpan<byte> label, ref float t, ReadOnlySpan<byte> format, ImPlotColormap cmap)
		{
			fixed (byte* plabel = label)
			{
				fixed (float* pt = &t)
				{
					fixed (byte* pformat = format)
					{
						byte ret = ColormapSliderNative((byte*)plabel, (float*)pt, (Vector4*)(default), (byte*)pformat, cmap);
						return ret != 0;
					}
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool ColormapSlider(string label, ref float t, Vector4* output, string format, ImPlotColormap cmap)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (float* pt = &t)
			{
				byte* pStr1 = null;
				int pStrSize1 = 0;
				if (format != null)
				{
					pStrSize1 = Utils.GetByteCountUTF8(format);
					if (pStrSize1 >= Utils.MaxStackallocSize)
					{
						pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
					}
					else
					{
						byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
						pStr1 = pStrStack1;
					}
					int pStrOffset1 = Utils.EncodeStringUTF8(format, pStr1, pStrSize1);
					pStr1[pStrOffset1] = 0;
				}
				byte ret = ColormapSliderNative(pStr0, (float*)pt, output, pStr1, cmap);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr1);
				}
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret != 0;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool ColormapSlider(string label, ref float t, Vector4* output, string format)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (float* pt = &t)
			{
				byte* pStr1 = null;
				int pStrSize1 = 0;
				if (format != null)
				{
					pStrSize1 = Utils.GetByteCountUTF8(format);
					if (pStrSize1 >= Utils.MaxStackallocSize)
					{
						pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
					}
					else
					{
						byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
						pStr1 = pStrStack1;
					}
					int pStrOffset1 = Utils.EncodeStringUTF8(format, pStr1, pStrSize1);
					pStr1[pStrOffset1] = 0;
				}
				byte ret = ColormapSliderNative(pStr0, (float*)pt, output, pStr1, (ImPlotColormap)(-1));
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr1);
				}
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret != 0;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool ColormapSlider(string label, ref float t, string format)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (float* pt = &t)
			{
				byte* pStr1 = null;
				int pStrSize1 = 0;
				if (format != null)
				{
					pStrSize1 = Utils.GetByteCountUTF8(format);
					if (pStrSize1 >= Utils.MaxStackallocSize)
					{
						pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
					}
					else
					{
						byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
						pStr1 = pStrStack1;
					}
					int pStrOffset1 = Utils.EncodeStringUTF8(format, pStr1, pStrSize1);
					pStr1[pStrOffset1] = 0;
				}
				byte ret = ColormapSliderNative(pStr0, (float*)pt, (Vector4*)(default), pStr1, (ImPlotColormap)(-1));
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr1);
				}
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret != 0;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool ColormapSlider(string label, ref float t, string format, ImPlotColormap cmap)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (float* pt = &t)
			{
				byte* pStr1 = null;
				int pStrSize1 = 0;
				if (format != null)
				{
					pStrSize1 = Utils.GetByteCountUTF8(format);
					if (pStrSize1 >= Utils.MaxStackallocSize)
					{
						pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
					}
					else
					{
						byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
						pStr1 = pStrStack1;
					}
					int pStrOffset1 = Utils.EncodeStringUTF8(format, pStr1, pStrSize1);
					pStr1[pStrOffset1] = 0;
				}
				byte ret = ColormapSliderNative(pStr0, (float*)pt, (Vector4*)(default), pStr1, cmap);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr1);
				}
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret != 0;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool ColormapSlider(in byte label, ref float t, Vector4* output, ReadOnlySpan<byte> format, ImPlotColormap cmap)
		{
			fixed (byte* plabel = &label)
			{
				fixed (float* pt = &t)
				{
					fixed (byte* pformat = format)
					{
						byte ret = ColormapSliderNative((byte*)plabel, (float*)pt, output, (byte*)pformat, cmap);
						return ret != 0;
					}
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool ColormapSlider(in byte label, ref float t, Vector4* output, ReadOnlySpan<byte> format)
		{
			fixed (byte* plabel = &label)
			{
				fixed (float* pt = &t)
				{
					fixed (byte* pformat = format)
					{
						byte ret = ColormapSliderNative((byte*)plabel, (float*)pt, output, (byte*)pformat, (ImPlotColormap)(-1));
						return ret != 0;
					}
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool ColormapSlider(in byte label, ref float t, ReadOnlySpan<byte> format)
		{
			fixed (byte* plabel = &label)
			{
				fixed (float* pt = &t)
				{
					fixed (byte* pformat = format)
					{
						byte ret = ColormapSliderNative((byte*)plabel, (float*)pt, (Vector4*)(default), (byte*)pformat, (ImPlotColormap)(-1));
						return ret != 0;
					}
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool ColormapSlider(in byte label, ref float t, ReadOnlySpan<byte> format, ImPlotColormap cmap)
		{
			fixed (byte* plabel = &label)
			{
				fixed (float* pt = &t)
				{
					fixed (byte* pformat = format)
					{
						byte ret = ColormapSliderNative((byte*)plabel, (float*)pt, (Vector4*)(default), (byte*)pformat, cmap);
						return ret != 0;
					}
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool ColormapSlider(in byte label, ref float t, Vector4* output, string format, ImPlotColormap cmap)
		{
			fixed (byte* plabel = &label)
			{
				fixed (float* pt = &t)
				{
					byte* pStr0 = null;
					int pStrSize0 = 0;
					if (format != null)
					{
						pStrSize0 = Utils.GetByteCountUTF8(format);
						if (pStrSize0 >= Utils.MaxStackallocSize)
						{
							pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
						}
						else
						{
							byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
							pStr0 = pStrStack0;
						}
						int pStrOffset0 = Utils.EncodeStringUTF8(format, pStr0, pStrSize0);
						pStr0[pStrOffset0] = 0;
					}
					byte ret = ColormapSliderNative((byte*)plabel, (float*)pt, output, pStr0, cmap);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool ColormapSlider(in byte label, ref float t, Vector4* output, string format)
		{
			fixed (byte* plabel = &label)
			{
				fixed (float* pt = &t)
				{
					byte* pStr0 = null;
					int pStrSize0 = 0;
					if (format != null)
					{
						pStrSize0 = Utils.GetByteCountUTF8(format);
						if (pStrSize0 >= Utils.MaxStackallocSize)
						{
							pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
						}
						else
						{
							byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
							pStr0 = pStrStack0;
						}
						int pStrOffset0 = Utils.EncodeStringUTF8(format, pStr0, pStrSize0);
						pStr0[pStrOffset0] = 0;
					}
					byte ret = ColormapSliderNative((byte*)plabel, (float*)pt, output, pStr0, (ImPlotColormap)(-1));
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool ColormapSlider(in byte label, ref float t, string format)
		{
			fixed (byte* plabel = &label)
			{
				fixed (float* pt = &t)
				{
					byte* pStr0 = null;
					int pStrSize0 = 0;
					if (format != null)
					{
						pStrSize0 = Utils.GetByteCountUTF8(format);
						if (pStrSize0 >= Utils.MaxStackallocSize)
						{
							pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
						}
						else
						{
							byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
							pStr0 = pStrStack0;
						}
						int pStrOffset0 = Utils.EncodeStringUTF8(format, pStr0, pStrSize0);
						pStr0[pStrOffset0] = 0;
					}
					byte ret = ColormapSliderNative((byte*)plabel, (float*)pt, (Vector4*)(default), pStr0, (ImPlotColormap)(-1));
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool ColormapSlider(in byte label, ref float t, string format, ImPlotColormap cmap)
		{
			fixed (byte* plabel = &label)
			{
				fixed (float* pt = &t)
				{
					byte* pStr0 = null;
					int pStrSize0 = 0;
					if (format != null)
					{
						pStrSize0 = Utils.GetByteCountUTF8(format);
						if (pStrSize0 >= Utils.MaxStackallocSize)
						{
							pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
						}
						else
						{
							byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
							pStr0 = pStrStack0;
						}
						int pStrOffset0 = Utils.EncodeStringUTF8(format, pStr0, pStrSize0);
						pStr0[pStrOffset0] = 0;
					}
					byte ret = ColormapSliderNative((byte*)plabel, (float*)pt, (Vector4*)(default), pStr0, cmap);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool ColormapSlider(ReadOnlySpan<byte> label, ref float t, Vector4* output, in byte format, ImPlotColormap cmap)
		{
			fixed (byte* plabel = label)
			{
				fixed (float* pt = &t)
				{
					fixed (byte* pformat = &format)
					{
						byte ret = ColormapSliderNative((byte*)plabel, (float*)pt, output, (byte*)pformat, cmap);
						return ret != 0;
					}
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool ColormapSlider(ReadOnlySpan<byte> label, ref float t, Vector4* output, in byte format)
		{
			fixed (byte* plabel = label)
			{
				fixed (float* pt = &t)
				{
					fixed (byte* pformat = &format)
					{
						byte ret = ColormapSliderNative((byte*)plabel, (float*)pt, output, (byte*)pformat, (ImPlotColormap)(-1));
						return ret != 0;
					}
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool ColormapSlider(ReadOnlySpan<byte> label, ref float t, in byte format)
		{
			fixed (byte* plabel = label)
			{
				fixed (float* pt = &t)
				{
					fixed (byte* pformat = &format)
					{
						byte ret = ColormapSliderNative((byte*)plabel, (float*)pt, (Vector4*)(default), (byte*)pformat, (ImPlotColormap)(-1));
						return ret != 0;
					}
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool ColormapSlider(ReadOnlySpan<byte> label, ref float t, in byte format, ImPlotColormap cmap)
		{
			fixed (byte* plabel = label)
			{
				fixed (float* pt = &t)
				{
					fixed (byte* pformat = &format)
					{
						byte ret = ColormapSliderNative((byte*)plabel, (float*)pt, (Vector4*)(default), (byte*)pformat, cmap);
						return ret != 0;
					}
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool ColormapSlider(ReadOnlySpan<byte> label, ref float t, Vector4* output, string format, ImPlotColormap cmap)
		{
			fixed (byte* plabel = label)
			{
				fixed (float* pt = &t)
				{
					byte* pStr0 = null;
					int pStrSize0 = 0;
					if (format != null)
					{
						pStrSize0 = Utils.GetByteCountUTF8(format);
						if (pStrSize0 >= Utils.MaxStackallocSize)
						{
							pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
						}
						else
						{
							byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
							pStr0 = pStrStack0;
						}
						int pStrOffset0 = Utils.EncodeStringUTF8(format, pStr0, pStrSize0);
						pStr0[pStrOffset0] = 0;
					}
					byte ret = ColormapSliderNative((byte*)plabel, (float*)pt, output, pStr0, cmap);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool ColormapSlider(ReadOnlySpan<byte> label, ref float t, Vector4* output, string format)
		{
			fixed (byte* plabel = label)
			{
				fixed (float* pt = &t)
				{
					byte* pStr0 = null;
					int pStrSize0 = 0;
					if (format != null)
					{
						pStrSize0 = Utils.GetByteCountUTF8(format);
						if (pStrSize0 >= Utils.MaxStackallocSize)
						{
							pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
						}
						else
						{
							byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
							pStr0 = pStrStack0;
						}
						int pStrOffset0 = Utils.EncodeStringUTF8(format, pStr0, pStrSize0);
						pStr0[pStrOffset0] = 0;
					}
					byte ret = ColormapSliderNative((byte*)plabel, (float*)pt, output, pStr0, (ImPlotColormap)(-1));
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool ColormapSlider(ReadOnlySpan<byte> label, ref float t, string format)
		{
			fixed (byte* plabel = label)
			{
				fixed (float* pt = &t)
				{
					byte* pStr0 = null;
					int pStrSize0 = 0;
					if (format != null)
					{
						pStrSize0 = Utils.GetByteCountUTF8(format);
						if (pStrSize0 >= Utils.MaxStackallocSize)
						{
							pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
						}
						else
						{
							byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
							pStr0 = pStrStack0;
						}
						int pStrOffset0 = Utils.EncodeStringUTF8(format, pStr0, pStrSize0);
						pStr0[pStrOffset0] = 0;
					}
					byte ret = ColormapSliderNative((byte*)plabel, (float*)pt, (Vector4*)(default), pStr0, (ImPlotColormap)(-1));
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool ColormapSlider(ReadOnlySpan<byte> label, ref float t, string format, ImPlotColormap cmap)
		{
			fixed (byte* plabel = label)
			{
				fixed (float* pt = &t)
				{
					byte* pStr0 = null;
					int pStrSize0 = 0;
					if (format != null)
					{
						pStrSize0 = Utils.GetByteCountUTF8(format);
						if (pStrSize0 >= Utils.MaxStackallocSize)
						{
							pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
						}
						else
						{
							byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
							pStr0 = pStrStack0;
						}
						int pStrOffset0 = Utils.EncodeStringUTF8(format, pStr0, pStrSize0);
						pStr0[pStrOffset0] = 0;
					}
					byte ret = ColormapSliderNative((byte*)plabel, (float*)pt, (Vector4*)(default), pStr0, cmap);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool ColormapSlider(string label, ref float t, Vector4* output, in byte format, ImPlotColormap cmap)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (float* pt = &t)
			{
				fixed (byte* pformat = &format)
				{
					byte ret = ColormapSliderNative(pStr0, (float*)pt, output, (byte*)pformat, cmap);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool ColormapSlider(string label, ref float t, Vector4* output, in byte format)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (float* pt = &t)
			{
				fixed (byte* pformat = &format)
				{
					byte ret = ColormapSliderNative(pStr0, (float*)pt, output, (byte*)pformat, (ImPlotColormap)(-1));
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool ColormapSlider(string label, ref float t, in byte format)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (float* pt = &t)
			{
				fixed (byte* pformat = &format)
				{
					byte ret = ColormapSliderNative(pStr0, (float*)pt, (Vector4*)(default), (byte*)pformat, (ImPlotColormap)(-1));
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool ColormapSlider(string label, ref float t, in byte format, ImPlotColormap cmap)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (float* pt = &t)
			{
				fixed (byte* pformat = &format)
				{
					byte ret = ColormapSliderNative(pStr0, (float*)pt, (Vector4*)(default), (byte*)pformat, cmap);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool ColormapSlider(string label, ref float t, Vector4* output, ReadOnlySpan<byte> format, ImPlotColormap cmap)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (float* pt = &t)
			{
				fixed (byte* pformat = format)
				{
					byte ret = ColormapSliderNative(pStr0, (float*)pt, output, (byte*)pformat, cmap);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool ColormapSlider(string label, ref float t, Vector4* output, ReadOnlySpan<byte> format)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (float* pt = &t)
			{
				fixed (byte* pformat = format)
				{
					byte ret = ColormapSliderNative(pStr0, (float*)pt, output, (byte*)pformat, (ImPlotColormap)(-1));
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool ColormapSlider(string label, ref float t, ReadOnlySpan<byte> format)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (float* pt = &t)
			{
				fixed (byte* pformat = format)
				{
					byte ret = ColormapSliderNative(pStr0, (float*)pt, (Vector4*)(default), (byte*)pformat, (ImPlotColormap)(-1));
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool ColormapSlider(string label, ref float t, ReadOnlySpan<byte> format, ImPlotColormap cmap)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (float* pt = &t)
			{
				fixed (byte* pformat = format)
				{
					byte ret = ColormapSliderNative(pStr0, (float*)pt, (Vector4*)(default), (byte*)pformat, cmap);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool ColormapSlider(byte* label, float* t, ref Vector4 output, in byte format, ImPlotColormap cmap)
		{
			fixed (Vector4* poutput = &output)
			{
				fixed (byte* pformat = &format)
				{
					byte ret = ColormapSliderNative(label, t, (Vector4*)poutput, (byte*)pformat, cmap);
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool ColormapSlider(byte* label, float* t, ref Vector4 output, in byte format)
		{
			fixed (Vector4* poutput = &output)
			{
				fixed (byte* pformat = &format)
				{
					byte ret = ColormapSliderNative(label, t, (Vector4*)poutput, (byte*)pformat, (ImPlotColormap)(-1));
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool ColormapSlider(byte* label, float* t, ref Vector4 output, ReadOnlySpan<byte> format, ImPlotColormap cmap)
		{
			fixed (Vector4* poutput = &output)
			{
				fixed (byte* pformat = format)
				{
					byte ret = ColormapSliderNative(label, t, (Vector4*)poutput, (byte*)pformat, cmap);
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool ColormapSlider(byte* label, float* t, ref Vector4 output, ReadOnlySpan<byte> format)
		{
			fixed (Vector4* poutput = &output)
			{
				fixed (byte* pformat = format)
				{
					byte ret = ColormapSliderNative(label, t, (Vector4*)poutput, (byte*)pformat, (ImPlotColormap)(-1));
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool ColormapSlider(byte* label, float* t, ref Vector4 output, string format, ImPlotColormap cmap)
		{
			fixed (Vector4* poutput = &output)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (format != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(format);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(format, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				byte ret = ColormapSliderNative(label, t, (Vector4*)poutput, pStr0, cmap);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret != 0;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool ColormapSlider(byte* label, float* t, ref Vector4 output, string format)
		{
			fixed (Vector4* poutput = &output)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (format != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(format);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(format, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				byte ret = ColormapSliderNative(label, t, (Vector4*)poutput, pStr0, (ImPlotColormap)(-1));
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret != 0;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool ColormapSlider(in byte label, float* t, ref Vector4 output, in byte format, ImPlotColormap cmap)
		{
			fixed (byte* plabel = &label)
			{
				fixed (Vector4* poutput = &output)
				{
					fixed (byte* pformat = &format)
					{
						byte ret = ColormapSliderNative((byte*)plabel, t, (Vector4*)poutput, (byte*)pformat, cmap);
						return ret != 0;
					}
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool ColormapSlider(in byte label, float* t, ref Vector4 output, in byte format)
		{
			fixed (byte* plabel = &label)
			{
				fixed (Vector4* poutput = &output)
				{
					fixed (byte* pformat = &format)
					{
						byte ret = ColormapSliderNative((byte*)plabel, t, (Vector4*)poutput, (byte*)pformat, (ImPlotColormap)(-1));
						return ret != 0;
					}
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool ColormapSlider(ReadOnlySpan<byte> label, float* t, ref Vector4 output, ReadOnlySpan<byte> format, ImPlotColormap cmap)
		{
			fixed (byte* plabel = label)
			{
				fixed (Vector4* poutput = &output)
				{
					fixed (byte* pformat = format)
					{
						byte ret = ColormapSliderNative((byte*)plabel, t, (Vector4*)poutput, (byte*)pformat, cmap);
						return ret != 0;
					}
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool ColormapSlider(ReadOnlySpan<byte> label, float* t, ref Vector4 output, ReadOnlySpan<byte> format)
		{
			fixed (byte* plabel = label)
			{
				fixed (Vector4* poutput = &output)
				{
					fixed (byte* pformat = format)
					{
						byte ret = ColormapSliderNative((byte*)plabel, t, (Vector4*)poutput, (byte*)pformat, (ImPlotColormap)(-1));
						return ret != 0;
					}
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool ColormapSlider(string label, float* t, ref Vector4 output, string format, ImPlotColormap cmap)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (Vector4* poutput = &output)
			{
				byte* pStr1 = null;
				int pStrSize1 = 0;
				if (format != null)
				{
					pStrSize1 = Utils.GetByteCountUTF8(format);
					if (pStrSize1 >= Utils.MaxStackallocSize)
					{
						pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
					}
					else
					{
						byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
						pStr1 = pStrStack1;
					}
					int pStrOffset1 = Utils.EncodeStringUTF8(format, pStr1, pStrSize1);
					pStr1[pStrOffset1] = 0;
				}
				byte ret = ColormapSliderNative(pStr0, t, (Vector4*)poutput, pStr1, cmap);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr1);
				}
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret != 0;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool ColormapSlider(string label, float* t, ref Vector4 output, string format)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (Vector4* poutput = &output)
			{
				byte* pStr1 = null;
				int pStrSize1 = 0;
				if (format != null)
				{
					pStrSize1 = Utils.GetByteCountUTF8(format);
					if (pStrSize1 >= Utils.MaxStackallocSize)
					{
						pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
					}
					else
					{
						byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
						pStr1 = pStrStack1;
					}
					int pStrOffset1 = Utils.EncodeStringUTF8(format, pStr1, pStrSize1);
					pStr1[pStrOffset1] = 0;
				}
				byte ret = ColormapSliderNative(pStr0, t, (Vector4*)poutput, pStr1, (ImPlotColormap)(-1));
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr1);
				}
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret != 0;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool ColormapSlider(in byte label, float* t, ref Vector4 output, ReadOnlySpan<byte> format, ImPlotColormap cmap)
		{
			fixed (byte* plabel = &label)
			{
				fixed (Vector4* poutput = &output)
				{
					fixed (byte* pformat = format)
					{
						byte ret = ColormapSliderNative((byte*)plabel, t, (Vector4*)poutput, (byte*)pformat, cmap);
						return ret != 0;
					}
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool ColormapSlider(in byte label, float* t, ref Vector4 output, ReadOnlySpan<byte> format)
		{
			fixed (byte* plabel = &label)
			{
				fixed (Vector4* poutput = &output)
				{
					fixed (byte* pformat = format)
					{
						byte ret = ColormapSliderNative((byte*)plabel, t, (Vector4*)poutput, (byte*)pformat, (ImPlotColormap)(-1));
						return ret != 0;
					}
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool ColormapSlider(in byte label, float* t, ref Vector4 output, string format, ImPlotColormap cmap)
		{
			fixed (byte* plabel = &label)
			{
				fixed (Vector4* poutput = &output)
				{
					byte* pStr0 = null;
					int pStrSize0 = 0;
					if (format != null)
					{
						pStrSize0 = Utils.GetByteCountUTF8(format);
						if (pStrSize0 >= Utils.MaxStackallocSize)
						{
							pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
						}
						else
						{
							byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
							pStr0 = pStrStack0;
						}
						int pStrOffset0 = Utils.EncodeStringUTF8(format, pStr0, pStrSize0);
						pStr0[pStrOffset0] = 0;
					}
					byte ret = ColormapSliderNative((byte*)plabel, t, (Vector4*)poutput, pStr0, cmap);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool ColormapSlider(in byte label, float* t, ref Vector4 output, string format)
		{
			fixed (byte* plabel = &label)
			{
				fixed (Vector4* poutput = &output)
				{
					byte* pStr0 = null;
					int pStrSize0 = 0;
					if (format != null)
					{
						pStrSize0 = Utils.GetByteCountUTF8(format);
						if (pStrSize0 >= Utils.MaxStackallocSize)
						{
							pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
						}
						else
						{
							byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
							pStr0 = pStrStack0;
						}
						int pStrOffset0 = Utils.EncodeStringUTF8(format, pStr0, pStrSize0);
						pStr0[pStrOffset0] = 0;
					}
					byte ret = ColormapSliderNative((byte*)plabel, t, (Vector4*)poutput, pStr0, (ImPlotColormap)(-1));
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool ColormapSlider(ReadOnlySpan<byte> label, float* t, ref Vector4 output, in byte format, ImPlotColormap cmap)
		{
			fixed (byte* plabel = label)
			{
				fixed (Vector4* poutput = &output)
				{
					fixed (byte* pformat = &format)
					{
						byte ret = ColormapSliderNative((byte*)plabel, t, (Vector4*)poutput, (byte*)pformat, cmap);
						return ret != 0;
					}
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool ColormapSlider(ReadOnlySpan<byte> label, float* t, ref Vector4 output, in byte format)
		{
			fixed (byte* plabel = label)
			{
				fixed (Vector4* poutput = &output)
				{
					fixed (byte* pformat = &format)
					{
						byte ret = ColormapSliderNative((byte*)plabel, t, (Vector4*)poutput, (byte*)pformat, (ImPlotColormap)(-1));
						return ret != 0;
					}
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool ColormapSlider(ReadOnlySpan<byte> label, float* t, ref Vector4 output, string format, ImPlotColormap cmap)
		{
			fixed (byte* plabel = label)
			{
				fixed (Vector4* poutput = &output)
				{
					byte* pStr0 = null;
					int pStrSize0 = 0;
					if (format != null)
					{
						pStrSize0 = Utils.GetByteCountUTF8(format);
						if (pStrSize0 >= Utils.MaxStackallocSize)
						{
							pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
						}
						else
						{
							byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
							pStr0 = pStrStack0;
						}
						int pStrOffset0 = Utils.EncodeStringUTF8(format, pStr0, pStrSize0);
						pStr0[pStrOffset0] = 0;
					}
					byte ret = ColormapSliderNative((byte*)plabel, t, (Vector4*)poutput, pStr0, cmap);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool ColormapSlider(ReadOnlySpan<byte> label, float* t, ref Vector4 output, string format)
		{
			fixed (byte* plabel = label)
			{
				fixed (Vector4* poutput = &output)
				{
					byte* pStr0 = null;
					int pStrSize0 = 0;
					if (format != null)
					{
						pStrSize0 = Utils.GetByteCountUTF8(format);
						if (pStrSize0 >= Utils.MaxStackallocSize)
						{
							pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
						}
						else
						{
							byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
							pStr0 = pStrStack0;
						}
						int pStrOffset0 = Utils.EncodeStringUTF8(format, pStr0, pStrSize0);
						pStr0[pStrOffset0] = 0;
					}
					byte ret = ColormapSliderNative((byte*)plabel, t, (Vector4*)poutput, pStr0, (ImPlotColormap)(-1));
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool ColormapSlider(string label, float* t, ref Vector4 output, in byte format, ImPlotColormap cmap)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (Vector4* poutput = &output)
			{
				fixed (byte* pformat = &format)
				{
					byte ret = ColormapSliderNative(pStr0, t, (Vector4*)poutput, (byte*)pformat, cmap);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool ColormapSlider(string label, float* t, ref Vector4 output, in byte format)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (Vector4* poutput = &output)
			{
				fixed (byte* pformat = &format)
				{
					byte ret = ColormapSliderNative(pStr0, t, (Vector4*)poutput, (byte*)pformat, (ImPlotColormap)(-1));
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool ColormapSlider(string label, float* t, ref Vector4 output, ReadOnlySpan<byte> format, ImPlotColormap cmap)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (Vector4* poutput = &output)
			{
				fixed (byte* pformat = format)
				{
					byte ret = ColormapSliderNative(pStr0, t, (Vector4*)poutput, (byte*)pformat, cmap);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool ColormapSlider(string label, float* t, ref Vector4 output, ReadOnlySpan<byte> format)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (Vector4* poutput = &output)
			{
				fixed (byte* pformat = format)
				{
					byte ret = ColormapSliderNative(pStr0, t, (Vector4*)poutput, (byte*)pformat, (ImPlotColormap)(-1));
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool ColormapSlider(byte* label, ref float t, ref Vector4 output, in byte format, ImPlotColormap cmap)
		{
			fixed (float* pt = &t)
			{
				fixed (Vector4* poutput = &output)
				{
					fixed (byte* pformat = &format)
					{
						byte ret = ColormapSliderNative(label, (float*)pt, (Vector4*)poutput, (byte*)pformat, cmap);
						return ret != 0;
					}
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool ColormapSlider(byte* label, ref float t, ref Vector4 output, in byte format)
		{
			fixed (float* pt = &t)
			{
				fixed (Vector4* poutput = &output)
				{
					fixed (byte* pformat = &format)
					{
						byte ret = ColormapSliderNative(label, (float*)pt, (Vector4*)poutput, (byte*)pformat, (ImPlotColormap)(-1));
						return ret != 0;
					}
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool ColormapSlider(byte* label, ref float t, ref Vector4 output, ReadOnlySpan<byte> format, ImPlotColormap cmap)
		{
			fixed (float* pt = &t)
			{
				fixed (Vector4* poutput = &output)
				{
					fixed (byte* pformat = format)
					{
						byte ret = ColormapSliderNative(label, (float*)pt, (Vector4*)poutput, (byte*)pformat, cmap);
						return ret != 0;
					}
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool ColormapSlider(byte* label, ref float t, ref Vector4 output, ReadOnlySpan<byte> format)
		{
			fixed (float* pt = &t)
			{
				fixed (Vector4* poutput = &output)
				{
					fixed (byte* pformat = format)
					{
						byte ret = ColormapSliderNative(label, (float*)pt, (Vector4*)poutput, (byte*)pformat, (ImPlotColormap)(-1));
						return ret != 0;
					}
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool ColormapSlider(byte* label, ref float t, ref Vector4 output, string format, ImPlotColormap cmap)
		{
			fixed (float* pt = &t)
			{
				fixed (Vector4* poutput = &output)
				{
					byte* pStr0 = null;
					int pStrSize0 = 0;
					if (format != null)
					{
						pStrSize0 = Utils.GetByteCountUTF8(format);
						if (pStrSize0 >= Utils.MaxStackallocSize)
						{
							pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
						}
						else
						{
							byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
							pStr0 = pStrStack0;
						}
						int pStrOffset0 = Utils.EncodeStringUTF8(format, pStr0, pStrSize0);
						pStr0[pStrOffset0] = 0;
					}
					byte ret = ColormapSliderNative(label, (float*)pt, (Vector4*)poutput, pStr0, cmap);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool ColormapSlider(byte* label, ref float t, ref Vector4 output, string format)
		{
			fixed (float* pt = &t)
			{
				fixed (Vector4* poutput = &output)
				{
					byte* pStr0 = null;
					int pStrSize0 = 0;
					if (format != null)
					{
						pStrSize0 = Utils.GetByteCountUTF8(format);
						if (pStrSize0 >= Utils.MaxStackallocSize)
						{
							pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
						}
						else
						{
							byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
							pStr0 = pStrStack0;
						}
						int pStrOffset0 = Utils.EncodeStringUTF8(format, pStr0, pStrSize0);
						pStr0[pStrOffset0] = 0;
					}
					byte ret = ColormapSliderNative(label, (float*)pt, (Vector4*)poutput, pStr0, (ImPlotColormap)(-1));
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool ColormapSlider(in byte label, ref float t, ref Vector4 output, in byte format, ImPlotColormap cmap)
		{
			fixed (byte* plabel = &label)
			{
				fixed (float* pt = &t)
				{
					fixed (Vector4* poutput = &output)
					{
						fixed (byte* pformat = &format)
						{
							byte ret = ColormapSliderNative((byte*)plabel, (float*)pt, (Vector4*)poutput, (byte*)pformat, cmap);
							return ret != 0;
						}
					}
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool ColormapSlider(in byte label, ref float t, ref Vector4 output, in byte format)
		{
			fixed (byte* plabel = &label)
			{
				fixed (float* pt = &t)
				{
					fixed (Vector4* poutput = &output)
					{
						fixed (byte* pformat = &format)
						{
							byte ret = ColormapSliderNative((byte*)plabel, (float*)pt, (Vector4*)poutput, (byte*)pformat, (ImPlotColormap)(-1));
							return ret != 0;
						}
					}
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool ColormapSlider(ReadOnlySpan<byte> label, ref float t, ref Vector4 output, ReadOnlySpan<byte> format, ImPlotColormap cmap)
		{
			fixed (byte* plabel = label)
			{
				fixed (float* pt = &t)
				{
					fixed (Vector4* poutput = &output)
					{
						fixed (byte* pformat = format)
						{
							byte ret = ColormapSliderNative((byte*)plabel, (float*)pt, (Vector4*)poutput, (byte*)pformat, cmap);
							return ret != 0;
						}
					}
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool ColormapSlider(ReadOnlySpan<byte> label, ref float t, ref Vector4 output, ReadOnlySpan<byte> format)
		{
			fixed (byte* plabel = label)
			{
				fixed (float* pt = &t)
				{
					fixed (Vector4* poutput = &output)
					{
						fixed (byte* pformat = format)
						{
							byte ret = ColormapSliderNative((byte*)plabel, (float*)pt, (Vector4*)poutput, (byte*)pformat, (ImPlotColormap)(-1));
							return ret != 0;
						}
					}
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool ColormapSlider(string label, ref float t, ref Vector4 output, string format, ImPlotColormap cmap)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (float* pt = &t)
			{
				fixed (Vector4* poutput = &output)
				{
					byte* pStr1 = null;
					int pStrSize1 = 0;
					if (format != null)
					{
						pStrSize1 = Utils.GetByteCountUTF8(format);
						if (pStrSize1 >= Utils.MaxStackallocSize)
						{
							pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
						}
						else
						{
							byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
							pStr1 = pStrStack1;
						}
						int pStrOffset1 = Utils.EncodeStringUTF8(format, pStr1, pStrSize1);
						pStr1[pStrOffset1] = 0;
					}
					byte ret = ColormapSliderNative(pStr0, (float*)pt, (Vector4*)poutput, pStr1, cmap);
					if (pStrSize1 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr1);
					}
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool ColormapSlider(string label, ref float t, ref Vector4 output, string format)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (float* pt = &t)
			{
				fixed (Vector4* poutput = &output)
				{
					byte* pStr1 = null;
					int pStrSize1 = 0;
					if (format != null)
					{
						pStrSize1 = Utils.GetByteCountUTF8(format);
						if (pStrSize1 >= Utils.MaxStackallocSize)
						{
							pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
						}
						else
						{
							byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
							pStr1 = pStrStack1;
						}
						int pStrOffset1 = Utils.EncodeStringUTF8(format, pStr1, pStrSize1);
						pStr1[pStrOffset1] = 0;
					}
					byte ret = ColormapSliderNative(pStr0, (float*)pt, (Vector4*)poutput, pStr1, (ImPlotColormap)(-1));
					if (pStrSize1 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr1);
					}
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool ColormapSlider(in byte label, ref float t, ref Vector4 output, ReadOnlySpan<byte> format, ImPlotColormap cmap)
		{
			fixed (byte* plabel = &label)
			{
				fixed (float* pt = &t)
				{
					fixed (Vector4* poutput = &output)
					{
						fixed (byte* pformat = format)
						{
							byte ret = ColormapSliderNative((byte*)plabel, (float*)pt, (Vector4*)poutput, (byte*)pformat, cmap);
							return ret != 0;
						}
					}
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool ColormapSlider(in byte label, ref float t, ref Vector4 output, ReadOnlySpan<byte> format)
		{
			fixed (byte* plabel = &label)
			{
				fixed (float* pt = &t)
				{
					fixed (Vector4* poutput = &output)
					{
						fixed (byte* pformat = format)
						{
							byte ret = ColormapSliderNative((byte*)plabel, (float*)pt, (Vector4*)poutput, (byte*)pformat, (ImPlotColormap)(-1));
							return ret != 0;
						}
					}
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool ColormapSlider(in byte label, ref float t, ref Vector4 output, string format, ImPlotColormap cmap)
		{
			fixed (byte* plabel = &label)
			{
				fixed (float* pt = &t)
				{
					fixed (Vector4* poutput = &output)
					{
						byte* pStr0 = null;
						int pStrSize0 = 0;
						if (format != null)
						{
							pStrSize0 = Utils.GetByteCountUTF8(format);
							if (pStrSize0 >= Utils.MaxStackallocSize)
							{
								pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
							}
							else
							{
								byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
								pStr0 = pStrStack0;
							}
							int pStrOffset0 = Utils.EncodeStringUTF8(format, pStr0, pStrSize0);
							pStr0[pStrOffset0] = 0;
						}
						byte ret = ColormapSliderNative((byte*)plabel, (float*)pt, (Vector4*)poutput, pStr0, cmap);
						if (pStrSize0 >= Utils.MaxStackallocSize)
						{
							Utils.Free(pStr0);
						}
						return ret != 0;
					}
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool ColormapSlider(in byte label, ref float t, ref Vector4 output, string format)
		{
			fixed (byte* plabel = &label)
			{
				fixed (float* pt = &t)
				{
					fixed (Vector4* poutput = &output)
					{
						byte* pStr0 = null;
						int pStrSize0 = 0;
						if (format != null)
						{
							pStrSize0 = Utils.GetByteCountUTF8(format);
							if (pStrSize0 >= Utils.MaxStackallocSize)
							{
								pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
							}
							else
							{
								byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
								pStr0 = pStrStack0;
							}
							int pStrOffset0 = Utils.EncodeStringUTF8(format, pStr0, pStrSize0);
							pStr0[pStrOffset0] = 0;
						}
						byte ret = ColormapSliderNative((byte*)plabel, (float*)pt, (Vector4*)poutput, pStr0, (ImPlotColormap)(-1));
						if (pStrSize0 >= Utils.MaxStackallocSize)
						{
							Utils.Free(pStr0);
						}
						return ret != 0;
					}
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool ColormapSlider(ReadOnlySpan<byte> label, ref float t, ref Vector4 output, in byte format, ImPlotColormap cmap)
		{
			fixed (byte* plabel = label)
			{
				fixed (float* pt = &t)
				{
					fixed (Vector4* poutput = &output)
					{
						fixed (byte* pformat = &format)
						{
							byte ret = ColormapSliderNative((byte*)plabel, (float*)pt, (Vector4*)poutput, (byte*)pformat, cmap);
							return ret != 0;
						}
					}
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool ColormapSlider(ReadOnlySpan<byte> label, ref float t, ref Vector4 output, in byte format)
		{
			fixed (byte* plabel = label)
			{
				fixed (float* pt = &t)
				{
					fixed (Vector4* poutput = &output)
					{
						fixed (byte* pformat = &format)
						{
							byte ret = ColormapSliderNative((byte*)plabel, (float*)pt, (Vector4*)poutput, (byte*)pformat, (ImPlotColormap)(-1));
							return ret != 0;
						}
					}
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool ColormapSlider(ReadOnlySpan<byte> label, ref float t, ref Vector4 output, string format, ImPlotColormap cmap)
		{
			fixed (byte* plabel = label)
			{
				fixed (float* pt = &t)
				{
					fixed (Vector4* poutput = &output)
					{
						byte* pStr0 = null;
						int pStrSize0 = 0;
						if (format != null)
						{
							pStrSize0 = Utils.GetByteCountUTF8(format);
							if (pStrSize0 >= Utils.MaxStackallocSize)
							{
								pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
							}
							else
							{
								byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
								pStr0 = pStrStack0;
							}
							int pStrOffset0 = Utils.EncodeStringUTF8(format, pStr0, pStrSize0);
							pStr0[pStrOffset0] = 0;
						}
						byte ret = ColormapSliderNative((byte*)plabel, (float*)pt, (Vector4*)poutput, pStr0, cmap);
						if (pStrSize0 >= Utils.MaxStackallocSize)
						{
							Utils.Free(pStr0);
						}
						return ret != 0;
					}
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool ColormapSlider(ReadOnlySpan<byte> label, ref float t, ref Vector4 output, string format)
		{
			fixed (byte* plabel = label)
			{
				fixed (float* pt = &t)
				{
					fixed (Vector4* poutput = &output)
					{
						byte* pStr0 = null;
						int pStrSize0 = 0;
						if (format != null)
						{
							pStrSize0 = Utils.GetByteCountUTF8(format);
							if (pStrSize0 >= Utils.MaxStackallocSize)
							{
								pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
							}
							else
							{
								byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
								pStr0 = pStrStack0;
							}
							int pStrOffset0 = Utils.EncodeStringUTF8(format, pStr0, pStrSize0);
							pStr0[pStrOffset0] = 0;
						}
						byte ret = ColormapSliderNative((byte*)plabel, (float*)pt, (Vector4*)poutput, pStr0, (ImPlotColormap)(-1));
						if (pStrSize0 >= Utils.MaxStackallocSize)
						{
							Utils.Free(pStr0);
						}
						return ret != 0;
					}
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool ColormapSlider(string label, ref float t, ref Vector4 output, in byte format, ImPlotColormap cmap)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (float* pt = &t)
			{
				fixed (Vector4* poutput = &output)
				{
					fixed (byte* pformat = &format)
					{
						byte ret = ColormapSliderNative(pStr0, (float*)pt, (Vector4*)poutput, (byte*)pformat, cmap);
						if (pStrSize0 >= Utils.MaxStackallocSize)
						{
							Utils.Free(pStr0);
						}
						return ret != 0;
					}
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool ColormapSlider(string label, ref float t, ref Vector4 output, in byte format)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (float* pt = &t)
			{
				fixed (Vector4* poutput = &output)
				{
					fixed (byte* pformat = &format)
					{
						byte ret = ColormapSliderNative(pStr0, (float*)pt, (Vector4*)poutput, (byte*)pformat, (ImPlotColormap)(-1));
						if (pStrSize0 >= Utils.MaxStackallocSize)
						{
							Utils.Free(pStr0);
						}
						return ret != 0;
					}
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool ColormapSlider(string label, ref float t, ref Vector4 output, ReadOnlySpan<byte> format, ImPlotColormap cmap)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (float* pt = &t)
			{
				fixed (Vector4* poutput = &output)
				{
					fixed (byte* pformat = format)
					{
						byte ret = ColormapSliderNative(pStr0, (float*)pt, (Vector4*)poutput, (byte*)pformat, cmap);
						if (pStrSize0 >= Utils.MaxStackallocSize)
						{
							Utils.Free(pStr0);
						}
						return ret != 0;
					}
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool ColormapSlider(string label, ref float t, ref Vector4 output, ReadOnlySpan<byte> format)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (float* pt = &t)
			{
				fixed (Vector4* poutput = &output)
				{
					fixed (byte* pformat = format)
					{
						byte ret = ColormapSliderNative(pStr0, (float*)pt, (Vector4*)poutput, (byte*)pformat, (ImPlotColormap)(-1));
						if (pStrSize0 >= Utils.MaxStackallocSize)
						{
							Utils.Free(pStr0);
						}
						return ret != 0;
					}
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte ColormapButtonNative(byte* label, Vector2 size, ImPlotColormap cmap)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<byte*, Vector2, ImPlotColormap, byte>)funcTable[369])(label, size, cmap);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<nint, Vector2, ImPlotColormap, byte>)funcTable[369])((nint)label, size, cmap);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool ColormapButton(byte* label, Vector2 size, ImPlotColormap cmap)
		{
			byte ret = ColormapButtonNative(label, size, cmap);
			return ret != 0;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool ColormapButton(byte* label, Vector2 size)
		{
			byte ret = ColormapButtonNative(label, size, (ImPlotColormap)(-1));
			return ret != 0;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool ColormapButton(byte* label)
		{
			byte ret = ColormapButtonNative(label, (Vector2)(new Vector2(0,0)), (ImPlotColormap)(-1));
			return ret != 0;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool ColormapButton(byte* label, ImPlotColormap cmap)
		{
			byte ret = ColormapButtonNative(label, (Vector2)(new Vector2(0,0)), cmap);
			return ret != 0;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool ColormapButton(in byte label, Vector2 size, ImPlotColormap cmap)
		{
			fixed (byte* plabel = &label)
			{
				byte ret = ColormapButtonNative((byte*)plabel, size, cmap);
				return ret != 0;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool ColormapButton(in byte label, Vector2 size)
		{
			fixed (byte* plabel = &label)
			{
				byte ret = ColormapButtonNative((byte*)plabel, size, (ImPlotColormap)(-1));
				return ret != 0;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool ColormapButton(in byte label)
		{
			fixed (byte* plabel = &label)
			{
				byte ret = ColormapButtonNative((byte*)plabel, (Vector2)(new Vector2(0,0)), (ImPlotColormap)(-1));
				return ret != 0;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool ColormapButton(in byte label, ImPlotColormap cmap)
		{
			fixed (byte* plabel = &label)
			{
				byte ret = ColormapButtonNative((byte*)plabel, (Vector2)(new Vector2(0,0)), cmap);
				return ret != 0;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool ColormapButton(ReadOnlySpan<byte> label, Vector2 size, ImPlotColormap cmap)
		{
			fixed (byte* plabel = label)
			{
				byte ret = ColormapButtonNative((byte*)plabel, size, cmap);
				return ret != 0;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool ColormapButton(ReadOnlySpan<byte> label, Vector2 size)
		{
			fixed (byte* plabel = label)
			{
				byte ret = ColormapButtonNative((byte*)plabel, size, (ImPlotColormap)(-1));
				return ret != 0;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool ColormapButton(ReadOnlySpan<byte> label)
		{
			fixed (byte* plabel = label)
			{
				byte ret = ColormapButtonNative((byte*)plabel, (Vector2)(new Vector2(0,0)), (ImPlotColormap)(-1));
				return ret != 0;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool ColormapButton(ReadOnlySpan<byte> label, ImPlotColormap cmap)
		{
			fixed (byte* plabel = label)
			{
				byte ret = ColormapButtonNative((byte*)plabel, (Vector2)(new Vector2(0,0)), cmap);
				return ret != 0;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool ColormapButton(string label, Vector2 size, ImPlotColormap cmap)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = ColormapButtonNative(pStr0, size, cmap);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool ColormapButton(string label, Vector2 size)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = ColormapButtonNative(pStr0, size, (ImPlotColormap)(-1));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool ColormapButton(string label)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = ColormapButtonNative(pStr0, (Vector2)(new Vector2(0,0)), (ImPlotColormap)(-1));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool ColormapButton(string label, ImPlotColormap cmap)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = ColormapButtonNative(pStr0, (Vector2)(new Vector2(0,0)), cmap);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void BustColorCacheNative(byte* plotTitleId)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<byte*, void>)funcTable[370])(plotTitleId);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)funcTable[370])((nint)plotTitleId);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void BustColorCache(byte* plotTitleId)
		{
			BustColorCacheNative(plotTitleId);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void BustColorCache()
		{
			BustColorCacheNative((byte*)(default));
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void BustColorCache(in byte plotTitleId)
		{
			fixed (byte* pplotTitleId = &plotTitleId)
			{
				BustColorCacheNative((byte*)pplotTitleId);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void BustColorCache(ReadOnlySpan<byte> plotTitleId)
		{
			fixed (byte* pplotTitleId = plotTitleId)
			{
				BustColorCacheNative((byte*)pplotTitleId);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void BustColorCache(string plotTitleId)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (plotTitleId != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(plotTitleId);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(plotTitleId, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			BustColorCacheNative(pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static ImPlotInputMap* GetInputMapNative()
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<ImPlotInputMap*>)funcTable[371])();
			#else
			return (ImPlotInputMap*)((delegate* unmanaged[Cdecl]<nint>)funcTable[371])();
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static ImPlotInputMapPtr GetInputMap()
		{
			ImPlotInputMapPtr ret = GetInputMapNative();
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void MapInputDefaultNative(ImPlotInputMap* dst)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<ImPlotInputMap*, void>)funcTable[372])(dst);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)funcTable[372])((nint)dst);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void MapInputDefault(ImPlotInputMapPtr dst)
		{
			MapInputDefaultNative((ImPlotInputMap*)dst);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void MapInputDefault()
		{
			MapInputDefaultNative((ImPlotInputMap*)(default));
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void MapInputDefault(ref ImPlotInputMap dst)
		{
			fixed (ImPlotInputMap* pdst = &dst)
			{
				MapInputDefaultNative((ImPlotInputMap*)pdst);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void MapInputReverseNative(ImPlotInputMap* dst)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<ImPlotInputMap*, void>)funcTable[373])(dst);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)funcTable[373])((nint)dst);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void MapInputReverse(ImPlotInputMapPtr dst)
		{
			MapInputReverseNative((ImPlotInputMap*)dst);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void MapInputReverse()
		{
			MapInputReverseNative((ImPlotInputMap*)(default));
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void MapInputReverse(ref ImPlotInputMap dst)
		{
			fixed (ImPlotInputMap* pdst = &dst)
			{
				MapInputReverseNative((ImPlotInputMap*)pdst);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void ItemIconNative(Vector4 col)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<Vector4, void>)funcTable[374])(col);
			#else
			((delegate* unmanaged[Cdecl]<Vector4, void>)funcTable[374])(col);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void ItemIcon(Vector4 col)
		{
			ItemIconNative(col);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void ItemIconNative(uint col)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, void>)funcTable[375])(col);
			#else
			((delegate* unmanaged[Cdecl]<uint, void>)funcTable[375])(col);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void ItemIcon(uint col)
		{
			ItemIconNative(col);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void ColormapIconNative(ImPlotColormap cmap)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<ImPlotColormap, void>)funcTable[376])(cmap);
			#else
			((delegate* unmanaged[Cdecl]<ImPlotColormap, void>)funcTable[376])(cmap);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void ColormapIcon(ImPlotColormap cmap)
		{
			ColormapIconNative(cmap);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static ImDrawList* GetPlotDrawListNative()
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<ImDrawList*>)funcTable[377])();
			#else
			return (ImDrawList*)((delegate* unmanaged[Cdecl]<nint>)funcTable[377])();
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static ImDrawListPtr GetPlotDrawList()
		{
			ImDrawListPtr ret = GetPlotDrawListNative();
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void PushPlotClipRectNative(float expand)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<float, void>)funcTable[378])(expand);
			#else
			((delegate* unmanaged[Cdecl]<float, void>)funcTable[378])(expand);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void PushPlotClipRect(float expand)
		{
			PushPlotClipRectNative(expand);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void PushPlotClipRect()
		{
			PushPlotClipRectNative((float)(0));
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void PopPlotClipRectNative()
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<void>)funcTable[379])();
			#else
			((delegate* unmanaged[Cdecl]<void>)funcTable[379])();
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void PopPlotClipRect()
		{
			PopPlotClipRectNative();
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte ShowStyleSelectorNative(byte* label)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<byte*, byte>)funcTable[380])(label);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<nint, byte>)funcTable[380])((nint)label);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool ShowStyleSelector(byte* label)
		{
			byte ret = ShowStyleSelectorNative(label);
			return ret != 0;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool ShowStyleSelector(in byte label)
		{
			fixed (byte* plabel = &label)
			{
				byte ret = ShowStyleSelectorNative((byte*)plabel);
				return ret != 0;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool ShowStyleSelector(ReadOnlySpan<byte> label)
		{
			fixed (byte* plabel = label)
			{
				byte ret = ShowStyleSelectorNative((byte*)plabel);
				return ret != 0;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool ShowStyleSelector(string label)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = ShowStyleSelectorNative(pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte ShowColormapSelectorNative(byte* label)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<byte*, byte>)funcTable[381])(label);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<nint, byte>)funcTable[381])((nint)label);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool ShowColormapSelector(byte* label)
		{
			byte ret = ShowColormapSelectorNative(label);
			return ret != 0;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool ShowColormapSelector(in byte label)
		{
			fixed (byte* plabel = &label)
			{
				byte ret = ShowColormapSelectorNative((byte*)plabel);
				return ret != 0;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool ShowColormapSelector(ReadOnlySpan<byte> label)
		{
			fixed (byte* plabel = label)
			{
				byte ret = ShowColormapSelectorNative((byte*)plabel);
				return ret != 0;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool ShowColormapSelector(string label)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = ShowColormapSelectorNative(pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte ShowInputMapSelectorNative(byte* label)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<byte*, byte>)funcTable[382])(label);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<nint, byte>)funcTable[382])((nint)label);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool ShowInputMapSelector(byte* label)
		{
			byte ret = ShowInputMapSelectorNative(label);
			return ret != 0;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool ShowInputMapSelector(in byte label)
		{
			fixed (byte* plabel = &label)
			{
				byte ret = ShowInputMapSelectorNative((byte*)plabel);
				return ret != 0;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool ShowInputMapSelector(ReadOnlySpan<byte> label)
		{
			fixed (byte* plabel = label)
			{
				byte ret = ShowInputMapSelectorNative((byte*)plabel);
				return ret != 0;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool ShowInputMapSelector(string label)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = ShowInputMapSelectorNative(pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void ShowStyleEditorNative(ImPlotStyle* reference)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<ImPlotStyle*, void>)funcTable[383])(reference);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)funcTable[383])((nint)reference);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void ShowStyleEditor(ImPlotStylePtr reference)
		{
			ShowStyleEditorNative((ImPlotStyle*)reference);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void ShowStyleEditor()
		{
			ShowStyleEditorNative((ImPlotStyle*)(default));
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void ShowStyleEditor(ref ImPlotStyle reference)
		{
			fixed (ImPlotStyle* preference = &reference)
			{
				ShowStyleEditorNative((ImPlotStyle*)preference);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void ShowUserGuideNative()
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<void>)funcTable[384])();
			#else
			((delegate* unmanaged[Cdecl]<void>)funcTable[384])();
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void ShowUserGuide()
		{
			ShowUserGuideNative();
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void ShowMetricsWindowNative(bool* pPopen)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<bool*, void>)funcTable[385])(pPopen);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)funcTable[385])((nint)pPopen);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void ShowMetricsWindow(bool* pPopen)
		{
			ShowMetricsWindowNative(pPopen);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void ShowMetricsWindow()
		{
			ShowMetricsWindowNative((bool*)(default));
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void ShowMetricsWindow(ref bool pPopen)
		{
			fixed (bool* ppPopen = &pPopen)
			{
				ShowMetricsWindowNative((bool*)ppPopen);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void ShowDemoWindowNative(bool* pOpen)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<bool*, void>)funcTable[386])(pOpen);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)funcTable[386])((nint)pOpen);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void ShowDemoWindow(bool* pOpen)
		{
			ShowDemoWindowNative(pOpen);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void ShowDemoWindow()
		{
			ShowDemoWindowNative((bool*)(default));
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void ShowDemoWindow(ref bool pOpen)
		{
			fixed (bool* ppOpen = &pOpen)
			{
				ShowDemoWindowNative((bool*)ppOpen);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static float ImLog10Native(float x)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<float, float>)funcTable[387])(x);
			#else
			return (float)((delegate* unmanaged[Cdecl]<float, float>)funcTable[387])(x);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static float ImLog10(float x)
		{
			float ret = ImLog10Native(x);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static double ImLog10Native(double x)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<double, double>)funcTable[388])(x);
			#else
			return (double)((delegate* unmanaged[Cdecl]<double, double>)funcTable[388])(x);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static double ImLog10(double x)
		{
			double ret = ImLog10Native(x);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static float ImSinhNative(float x)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<float, float>)funcTable[389])(x);
			#else
			return (float)((delegate* unmanaged[Cdecl]<float, float>)funcTable[389])(x);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static float ImSinh(float x)
		{
			float ret = ImSinhNative(x);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static double ImSinhNative(double x)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<double, double>)funcTable[390])(x);
			#else
			return (double)((delegate* unmanaged[Cdecl]<double, double>)funcTable[390])(x);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static double ImSinh(double x)
		{
			double ret = ImSinhNative(x);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static float ImAsinhNative(float x)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<float, float>)funcTable[391])(x);
			#else
			return (float)((delegate* unmanaged[Cdecl]<float, float>)funcTable[391])(x);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static float ImAsinh(float x)
		{
			float ret = ImAsinhNative(x);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static double ImAsinhNative(double x)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<double, double>)funcTable[392])(x);
			#else
			return (double)((delegate* unmanaged[Cdecl]<double, double>)funcTable[392])(x);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static double ImAsinh(double x)
		{
			double ret = ImAsinhNative(x);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static float ImRemapNative(float x, float x0, float x1, float y0, float y1)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<float, float, float, float, float, float>)funcTable[393])(x, x0, x1, y0, y1);
			#else
			return (float)((delegate* unmanaged[Cdecl]<float, float, float, float, float, float>)funcTable[393])(x, x0, x1, y0, y1);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static float ImRemap(float x, float x0, float x1, float y0, float y1)
		{
			float ret = ImRemapNative(x, x0, x1, y0, y1);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static double ImRemapNative(double x, double x0, double x1, double y0, double y1)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<double, double, double, double, double, double>)funcTable[394])(x, x0, x1, y0, y1);
			#else
			return (double)((delegate* unmanaged[Cdecl]<double, double, double, double, double, double>)funcTable[394])(x, x0, x1, y0, y1);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static double ImRemap(double x, double x0, double x1, double y0, double y1)
		{
			double ret = ImRemapNative(x, x0, x1, y0, y1);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static sbyte ImRemapNative(sbyte x, sbyte x0, sbyte x1, sbyte y0, sbyte y1)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<sbyte, sbyte, sbyte, sbyte, sbyte, sbyte>)funcTable[395])(x, x0, x1, y0, y1);
			#else
			return (sbyte)((delegate* unmanaged[Cdecl]<sbyte, sbyte, sbyte, sbyte, sbyte, sbyte>)funcTable[395])(x, x0, x1, y0, y1);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static sbyte ImRemap(sbyte x, sbyte x0, sbyte x1, sbyte y0, sbyte y1)
		{
			sbyte ret = ImRemapNative(x, x0, x1, y0, y1);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte ImRemapNative(byte x, byte x0, byte x1, byte y0, byte y1)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<byte, byte, byte, byte, byte, byte>)funcTable[396])(x, x0, x1, y0, y1);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<byte, byte, byte, byte, byte, byte>)funcTable[396])(x, x0, x1, y0, y1);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static byte ImRemap(byte x, byte x0, byte x1, byte y0, byte y1)
		{
			byte ret = ImRemapNative(x, x0, x1, y0, y1);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static short ImRemapNative(short x, short x0, short x1, short y0, short y1)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<short, short, short, short, short, short>)funcTable[397])(x, x0, x1, y0, y1);
			#else
			return (short)((delegate* unmanaged[Cdecl]<short, short, short, short, short, short>)funcTable[397])(x, x0, x1, y0, y1);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static short ImRemap(short x, short x0, short x1, short y0, short y1)
		{
			short ret = ImRemapNative(x, x0, x1, y0, y1);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static ushort ImRemapNative(ushort x, ushort x0, ushort x1, ushort y0, ushort y1)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<ushort, ushort, ushort, ushort, ushort, ushort>)funcTable[398])(x, x0, x1, y0, y1);
			#else
			return (ushort)((delegate* unmanaged[Cdecl]<ushort, ushort, ushort, ushort, ushort, ushort>)funcTable[398])(x, x0, x1, y0, y1);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static ushort ImRemap(ushort x, ushort x0, ushort x1, ushort y0, ushort y1)
		{
			ushort ret = ImRemapNative(x, x0, x1, y0, y1);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int ImRemapNative(int x, int x0, int x1, int y0, int y1)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<int, int, int, int, int, int>)funcTable[399])(x, x0, x1, y0, y1);
			#else
			return (int)((delegate* unmanaged[Cdecl]<int, int, int, int, int, int>)funcTable[399])(x, x0, x1, y0, y1);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static int ImRemap(int x, int x0, int x1, int y0, int y1)
		{
			int ret = ImRemapNative(x, x0, x1, y0, y1);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static uint ImRemapNative(uint x, uint x0, uint x1, uint y0, uint y1)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<uint, uint, uint, uint, uint, uint>)funcTable[400])(x, x0, x1, y0, y1);
			#else
			return (uint)((delegate* unmanaged[Cdecl]<uint, uint, uint, uint, uint, uint>)funcTable[400])(x, x0, x1, y0, y1);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static uint ImRemap(uint x, uint x0, uint x1, uint y0, uint y1)
		{
			uint ret = ImRemapNative(x, x0, x1, y0, y1);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static long ImRemapNative(long x, long x0, long x1, long y0, long y1)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<long, long, long, long, long, long>)funcTable[401])(x, x0, x1, y0, y1);
			#else
			return (long)((delegate* unmanaged[Cdecl]<long, long, long, long, long, long>)funcTable[401])(x, x0, x1, y0, y1);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static long ImRemap(long x, long x0, long x1, long y0, long y1)
		{
			long ret = ImRemapNative(x, x0, x1, y0, y1);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static ulong ImRemapNative(ulong x, ulong x0, ulong x1, ulong y0, ulong y1)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<ulong, ulong, ulong, ulong, ulong, ulong>)funcTable[402])(x, x0, x1, y0, y1);
			#else
			return (ulong)((delegate* unmanaged[Cdecl]<ulong, ulong, ulong, ulong, ulong, ulong>)funcTable[402])(x, x0, x1, y0, y1);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static ulong ImRemap(ulong x, ulong x0, ulong x1, ulong y0, ulong y1)
		{
			ulong ret = ImRemapNative(x, x0, x1, y0, y1);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static float ImRemap01Native(float x, float x0, float x1)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<float, float, float, float>)funcTable[403])(x, x0, x1);
			#else
			return (float)((delegate* unmanaged[Cdecl]<float, float, float, float>)funcTable[403])(x, x0, x1);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static float ImRemap01(float x, float x0, float x1)
		{
			float ret = ImRemap01Native(x, x0, x1);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static double ImRemap01Native(double x, double x0, double x1)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<double, double, double, double>)funcTable[404])(x, x0, x1);
			#else
			return (double)((delegate* unmanaged[Cdecl]<double, double, double, double>)funcTable[404])(x, x0, x1);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static double ImRemap01(double x, double x0, double x1)
		{
			double ret = ImRemap01Native(x, x0, x1);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static sbyte ImRemap01Native(sbyte x, sbyte x0, sbyte x1)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<sbyte, sbyte, sbyte, sbyte>)funcTable[405])(x, x0, x1);
			#else
			return (sbyte)((delegate* unmanaged[Cdecl]<sbyte, sbyte, sbyte, sbyte>)funcTable[405])(x, x0, x1);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static sbyte ImRemap01(sbyte x, sbyte x0, sbyte x1)
		{
			sbyte ret = ImRemap01Native(x, x0, x1);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte ImRemap01Native(byte x, byte x0, byte x1)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<byte, byte, byte, byte>)funcTable[406])(x, x0, x1);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<byte, byte, byte, byte>)funcTable[406])(x, x0, x1);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static byte ImRemap01(byte x, byte x0, byte x1)
		{
			byte ret = ImRemap01Native(x, x0, x1);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static short ImRemap01Native(short x, short x0, short x1)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<short, short, short, short>)funcTable[407])(x, x0, x1);
			#else
			return (short)((delegate* unmanaged[Cdecl]<short, short, short, short>)funcTable[407])(x, x0, x1);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static short ImRemap01(short x, short x0, short x1)
		{
			short ret = ImRemap01Native(x, x0, x1);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static ushort ImRemap01Native(ushort x, ushort x0, ushort x1)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<ushort, ushort, ushort, ushort>)funcTable[408])(x, x0, x1);
			#else
			return (ushort)((delegate* unmanaged[Cdecl]<ushort, ushort, ushort, ushort>)funcTable[408])(x, x0, x1);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static ushort ImRemap01(ushort x, ushort x0, ushort x1)
		{
			ushort ret = ImRemap01Native(x, x0, x1);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int ImRemap01Native(int x, int x0, int x1)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<int, int, int, int>)funcTable[409])(x, x0, x1);
			#else
			return (int)((delegate* unmanaged[Cdecl]<int, int, int, int>)funcTable[409])(x, x0, x1);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static int ImRemap01(int x, int x0, int x1)
		{
			int ret = ImRemap01Native(x, x0, x1);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static uint ImRemap01Native(uint x, uint x0, uint x1)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<uint, uint, uint, uint>)funcTable[410])(x, x0, x1);
			#else
			return (uint)((delegate* unmanaged[Cdecl]<uint, uint, uint, uint>)funcTable[410])(x, x0, x1);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static uint ImRemap01(uint x, uint x0, uint x1)
		{
			uint ret = ImRemap01Native(x, x0, x1);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static long ImRemap01Native(long x, long x0, long x1)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<long, long, long, long>)funcTable[411])(x, x0, x1);
			#else
			return (long)((delegate* unmanaged[Cdecl]<long, long, long, long>)funcTable[411])(x, x0, x1);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static long ImRemap01(long x, long x0, long x1)
		{
			long ret = ImRemap01Native(x, x0, x1);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static ulong ImRemap01Native(ulong x, ulong x0, ulong x1)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<ulong, ulong, ulong, ulong>)funcTable[412])(x, x0, x1);
			#else
			return (ulong)((delegate* unmanaged[Cdecl]<ulong, ulong, ulong, ulong>)funcTable[412])(x, x0, x1);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static ulong ImRemap01(ulong x, ulong x0, ulong x1)
		{
			ulong ret = ImRemap01Native(x, x0, x1);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int ImPosModNative(int l, int r)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<int, int, int>)funcTable[413])(l, r);
			#else
			return (int)((delegate* unmanaged[Cdecl]<int, int, int>)funcTable[413])(l, r);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static int ImPosMod(int l, int r)
		{
			int ret = ImPosModNative(l, r);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte ImNanNative(double val)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<double, byte>)funcTable[414])(val);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<double, byte>)funcTable[414])(val);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool ImNan(double val)
		{
			byte ret = ImNanNative(val);
			return ret != 0;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte ImNanOrInfNative(double val)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<double, byte>)funcTable[415])(val);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<double, byte>)funcTable[415])(val);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool ImNanOrInf(double val)
		{
			byte ret = ImNanOrInfNative(val);
			return ret != 0;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static double ImConstrainNanNative(double val)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<double, double>)funcTable[416])(val);
			#else
			return (double)((delegate* unmanaged[Cdecl]<double, double>)funcTable[416])(val);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static double ImConstrainNan(double val)
		{
			double ret = ImConstrainNanNative(val);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static double ImConstrainInfNative(double val)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<double, double>)funcTable[417])(val);
			#else
			return (double)((delegate* unmanaged[Cdecl]<double, double>)funcTable[417])(val);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static double ImConstrainInf(double val)
		{
			double ret = ImConstrainInfNative(val);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static double ImConstrainLogNative(double val)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<double, double>)funcTable[418])(val);
			#else
			return (double)((delegate* unmanaged[Cdecl]<double, double>)funcTable[418])(val);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static double ImConstrainLog(double val)
		{
			double ret = ImConstrainLogNative(val);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static double ImConstrainTimeNative(double val)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<double, double>)funcTable[419])(val);
			#else
			return (double)((delegate* unmanaged[Cdecl]<double, double>)funcTable[419])(val);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static double ImConstrainTime(double val)
		{
			double ret = ImConstrainTimeNative(val);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte ImAlmostEqualNative(double v1, double v2, int ulp)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<double, double, int, byte>)funcTable[420])(v1, v2, ulp);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<double, double, int, byte>)funcTable[420])(v1, v2, ulp);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool ImAlmostEqual(double v1, double v2, int ulp)
		{
			byte ret = ImAlmostEqualNative(v1, v2, ulp);
			return ret != 0;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool ImAlmostEqual(double v1, double v2)
		{
			byte ret = ImAlmostEqualNative(v1, v2, (int)(2));
			return ret != 0;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static float ImMinArrayNative(float* values, int count)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<float*, int, float>)funcTable[421])(values, count);
			#else
			return (float)((delegate* unmanaged[Cdecl]<nint, int, float>)funcTable[421])((nint)values, count);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static float ImMinArray(float* values, int count)
		{
			float ret = ImMinArrayNative(values, count);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static float ImMinArray(in float values, int count)
		{
			fixed (float* pvalues = &values)
			{
				float ret = ImMinArrayNative((float*)pvalues, count);
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static double ImMinArrayNative(double* values, int count)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<double*, int, double>)funcTable[422])(values, count);
			#else
			return (double)((delegate* unmanaged[Cdecl]<nint, int, double>)funcTable[422])((nint)values, count);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static double ImMinArray(double* values, int count)
		{
			double ret = ImMinArrayNative(values, count);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static double ImMinArray(in double values, int count)
		{
			fixed (double* pvalues = &values)
			{
				double ret = ImMinArrayNative((double*)pvalues, count);
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static sbyte ImMinArrayNative(sbyte* values, int count)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<sbyte*, int, sbyte>)funcTable[423])(values, count);
			#else
			return (sbyte)((delegate* unmanaged[Cdecl]<nint, int, sbyte>)funcTable[423])((nint)values, count);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static sbyte ImMinArray(sbyte* values, int count)
		{
			sbyte ret = ImMinArrayNative(values, count);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static sbyte ImMinArray(in sbyte values, int count)
		{
			fixed (sbyte* pvalues = &values)
			{
				sbyte ret = ImMinArrayNative((sbyte*)pvalues, count);
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte ImMinArrayNative(byte* values, int count)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<byte*, int, byte>)funcTable[424])(values, count);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<nint, int, byte>)funcTable[424])((nint)values, count);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static byte ImMinArray(byte* values, int count)
		{
			byte ret = ImMinArrayNative(values, count);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static byte ImMinArray(in byte values, int count)
		{
			fixed (byte* pvalues = &values)
			{
				byte ret = ImMinArrayNative((byte*)pvalues, count);
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static short ImMinArrayNative(short* values, int count)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<short*, int, short>)funcTable[425])(values, count);
			#else
			return (short)((delegate* unmanaged[Cdecl]<nint, int, short>)funcTable[425])((nint)values, count);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static short ImMinArray(short* values, int count)
		{
			short ret = ImMinArrayNative(values, count);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static short ImMinArray(in short values, int count)
		{
			fixed (short* pvalues = &values)
			{
				short ret = ImMinArrayNative((short*)pvalues, count);
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static ushort ImMinArrayNative(ushort* values, int count)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<ushort*, int, ushort>)funcTable[426])(values, count);
			#else
			return (ushort)((delegate* unmanaged[Cdecl]<nint, int, ushort>)funcTable[426])((nint)values, count);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static ushort ImMinArray(ushort* values, int count)
		{
			ushort ret = ImMinArrayNative(values, count);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static ushort ImMinArray(in ushort values, int count)
		{
			fixed (ushort* pvalues = &values)
			{
				ushort ret = ImMinArrayNative((ushort*)pvalues, count);
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int ImMinArrayNative(int* values, int count)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<int*, int, int>)funcTable[427])(values, count);
			#else
			return (int)((delegate* unmanaged[Cdecl]<nint, int, int>)funcTable[427])((nint)values, count);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static int ImMinArray(int* values, int count)
		{
			int ret = ImMinArrayNative(values, count);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static int ImMinArray(in int values, int count)
		{
			fixed (int* pvalues = &values)
			{
				int ret = ImMinArrayNative((int*)pvalues, count);
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static uint ImMinArrayNative(uint* values, int count)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<uint*, int, uint>)funcTable[428])(values, count);
			#else
			return (uint)((delegate* unmanaged[Cdecl]<nint, int, uint>)funcTable[428])((nint)values, count);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static uint ImMinArray(uint* values, int count)
		{
			uint ret = ImMinArrayNative(values, count);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static uint ImMinArray(in uint values, int count)
		{
			fixed (uint* pvalues = &values)
			{
				uint ret = ImMinArrayNative((uint*)pvalues, count);
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static long ImMinArrayNative(long* values, int count)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<long*, int, long>)funcTable[429])(values, count);
			#else
			return (long)((delegate* unmanaged[Cdecl]<nint, int, long>)funcTable[429])((nint)values, count);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static long ImMinArray(long* values, int count)
		{
			long ret = ImMinArrayNative(values, count);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static long ImMinArray(in long values, int count)
		{
			fixed (long* pvalues = &values)
			{
				long ret = ImMinArrayNative((long*)pvalues, count);
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static ulong ImMinArrayNative(ulong* values, int count)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<ulong*, int, ulong>)funcTable[430])(values, count);
			#else
			return (ulong)((delegate* unmanaged[Cdecl]<nint, int, ulong>)funcTable[430])((nint)values, count);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static ulong ImMinArray(ulong* values, int count)
		{
			ulong ret = ImMinArrayNative(values, count);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static ulong ImMinArray(in ulong values, int count)
		{
			fixed (ulong* pvalues = &values)
			{
				ulong ret = ImMinArrayNative((ulong*)pvalues, count);
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static float ImMaxArrayNative(float* values, int count)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<float*, int, float>)funcTable[431])(values, count);
			#else
			return (float)((delegate* unmanaged[Cdecl]<nint, int, float>)funcTable[431])((nint)values, count);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static float ImMaxArray(float* values, int count)
		{
			float ret = ImMaxArrayNative(values, count);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static float ImMaxArray(in float values, int count)
		{
			fixed (float* pvalues = &values)
			{
				float ret = ImMaxArrayNative((float*)pvalues, count);
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static double ImMaxArrayNative(double* values, int count)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<double*, int, double>)funcTable[432])(values, count);
			#else
			return (double)((delegate* unmanaged[Cdecl]<nint, int, double>)funcTable[432])((nint)values, count);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static double ImMaxArray(double* values, int count)
		{
			double ret = ImMaxArrayNative(values, count);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static double ImMaxArray(in double values, int count)
		{
			fixed (double* pvalues = &values)
			{
				double ret = ImMaxArrayNative((double*)pvalues, count);
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static sbyte ImMaxArrayNative(sbyte* values, int count)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<sbyte*, int, sbyte>)funcTable[433])(values, count);
			#else
			return (sbyte)((delegate* unmanaged[Cdecl]<nint, int, sbyte>)funcTable[433])((nint)values, count);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static sbyte ImMaxArray(sbyte* values, int count)
		{
			sbyte ret = ImMaxArrayNative(values, count);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static sbyte ImMaxArray(in sbyte values, int count)
		{
			fixed (sbyte* pvalues = &values)
			{
				sbyte ret = ImMaxArrayNative((sbyte*)pvalues, count);
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte ImMaxArrayNative(byte* values, int count)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<byte*, int, byte>)funcTable[434])(values, count);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<nint, int, byte>)funcTable[434])((nint)values, count);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static byte ImMaxArray(byte* values, int count)
		{
			byte ret = ImMaxArrayNative(values, count);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static byte ImMaxArray(in byte values, int count)
		{
			fixed (byte* pvalues = &values)
			{
				byte ret = ImMaxArrayNative((byte*)pvalues, count);
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static short ImMaxArrayNative(short* values, int count)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<short*, int, short>)funcTable[435])(values, count);
			#else
			return (short)((delegate* unmanaged[Cdecl]<nint, int, short>)funcTable[435])((nint)values, count);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static short ImMaxArray(short* values, int count)
		{
			short ret = ImMaxArrayNative(values, count);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static short ImMaxArray(in short values, int count)
		{
			fixed (short* pvalues = &values)
			{
				short ret = ImMaxArrayNative((short*)pvalues, count);
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static ushort ImMaxArrayNative(ushort* values, int count)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<ushort*, int, ushort>)funcTable[436])(values, count);
			#else
			return (ushort)((delegate* unmanaged[Cdecl]<nint, int, ushort>)funcTable[436])((nint)values, count);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static ushort ImMaxArray(ushort* values, int count)
		{
			ushort ret = ImMaxArrayNative(values, count);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static ushort ImMaxArray(in ushort values, int count)
		{
			fixed (ushort* pvalues = &values)
			{
				ushort ret = ImMaxArrayNative((ushort*)pvalues, count);
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int ImMaxArrayNative(int* values, int count)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<int*, int, int>)funcTable[437])(values, count);
			#else
			return (int)((delegate* unmanaged[Cdecl]<nint, int, int>)funcTable[437])((nint)values, count);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static int ImMaxArray(int* values, int count)
		{
			int ret = ImMaxArrayNative(values, count);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static int ImMaxArray(in int values, int count)
		{
			fixed (int* pvalues = &values)
			{
				int ret = ImMaxArrayNative((int*)pvalues, count);
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static uint ImMaxArrayNative(uint* values, int count)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<uint*, int, uint>)funcTable[438])(values, count);
			#else
			return (uint)((delegate* unmanaged[Cdecl]<nint, int, uint>)funcTable[438])((nint)values, count);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static uint ImMaxArray(uint* values, int count)
		{
			uint ret = ImMaxArrayNative(values, count);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static uint ImMaxArray(in uint values, int count)
		{
			fixed (uint* pvalues = &values)
			{
				uint ret = ImMaxArrayNative((uint*)pvalues, count);
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static long ImMaxArrayNative(long* values, int count)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<long*, int, long>)funcTable[439])(values, count);
			#else
			return (long)((delegate* unmanaged[Cdecl]<nint, int, long>)funcTable[439])((nint)values, count);
			#endif
		}
	}
}
