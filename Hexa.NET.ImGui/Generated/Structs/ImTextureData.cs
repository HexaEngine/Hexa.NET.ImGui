// ------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
// ------------------------------------------------------------------------------

using System;
using System.Diagnostics;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;
using HexaGen.Runtime;
using System.Numerics;

namespace Hexa.NET.ImGui
{
	/// <summary>
	/// Specs and pixel storage for a texture used by Dear ImGui.<br/>
	/// This is only useful for (1) core library and (2) backends. End-userapplications do not need to care about this.<br/>
	/// Renderer Backends will create a GPU-side version of this.<br/>
	/// Why does we store two identifiers: TexID and BackendUserData?<br/>
	/// - ImTextureID    TexID           = lower-level identifier stored in ImDrawCmd. ImDrawCmd can refer to textures not created by the backend, and for which there's no ImTextureData.<br/>
	/// - void*          BackendUserData = higher-level opaque storage for backend own book-keeping. Some backends may have enough with TexID and not need both.<br/>
	/// In columns below: who readswrites each fields? 'r'=read, 'w'=write, 'core'=main library, 'backend'=renderer backend<br/>
	/// </summary>
	[StructLayout(LayoutKind.Sequential)]
	public partial struct ImTextureData
	{
		/// <summary>
		/// To be documented.
		/// </summary>
		public int UniqueID;

		/// <summary>
		/// To be documented.
		/// </summary>
		public ImTextureStatus Status;

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void* BackendUserData;

		/// <summary>
		/// To be documented.
		/// </summary>
		public ImTextureID TexID;

		/// <summary>
		/// To be documented.
		/// </summary>
		public ImTextureFormat Format;

		/// <summary>
		/// To be documented.
		/// </summary>
		public int Width;

		/// <summary>
		/// To be documented.
		/// </summary>
		public int Height;

		/// <summary>
		/// To be documented.
		/// </summary>
		public int BytesPerPixel;

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe byte* Pixels;

		/// <summary>
		/// To be documented.
		/// </summary>
		public ImTextureRect UsedRect;

		/// <summary>
		/// To be documented.
		/// </summary>
		public ImTextureRect UpdateRect;

		/// <summary>
		/// To be documented.
		/// </summary>
		public ImVector<ImTextureRect> Updates;

		/// <summary>
		/// To be documented.
		/// </summary>
		public int UnusedFrames;

		/// <summary>
		/// To be documented.
		/// </summary>
		public ushort RefCount;

		/// <summary>
		/// To be documented.
		/// </summary>
		public byte UseColors;

		/// <summary>
		/// To be documented.
		/// </summary>
		public byte WantDestroyNextFrame;


		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe ImTextureData(int uniqueId = default, ImTextureStatus status = default, void* backendUserData = default, ImTextureID texId = default, ImTextureFormat format = default, int width = default, int height = default, int bytesPerPixel = default, byte* pixels = default, ImTextureRect usedRect = default, ImTextureRect updateRect = default, ImVector<ImTextureRect> updates = default, int unusedFrames = default, ushort refCount = default, bool useColors = default, bool wantDestroyNextFrame = default)
		{
			UniqueID = uniqueId;
			Status = status;
			BackendUserData = backendUserData;
			TexID = texId;
			Format = format;
			Width = width;
			Height = height;
			BytesPerPixel = bytesPerPixel;
			Pixels = pixels;
			UsedRect = usedRect;
			UpdateRect = updateRect;
			Updates = updates;
			UnusedFrames = unusedFrames;
			RefCount = refCount;
			UseColors = useColors ? (byte)1 : (byte)0;
			WantDestroyNextFrame = wantDestroyNextFrame ? (byte)1 : (byte)0;
		}


		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void Create(ImTextureFormat format, int w, int h)
		{
			fixed (ImTextureData* @this = &this)
			{
				ImGui.CreateNative(@this, format, w, h);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void Destroy()
		{
			fixed (ImTextureData* @this = &this)
			{
				ImGui.DestroyNative(@this);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void DestroyPixels()
		{
			fixed (ImTextureData* @this = &this)
			{
				ImGui.DestroyPixelsNative(@this);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe int GetPitch()
		{
			fixed (ImTextureData* @this = &this)
			{
				int ret = ImGui.GetPitchNative(@this);
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void* GetPixels()
		{
			fixed (ImTextureData* @this = &this)
			{
				void* ret = ImGui.GetPixelsNative(@this);
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void* GetPixelsAt(int x, int y)
		{
			fixed (ImTextureData* @this = &this)
			{
				void* ret = ImGui.GetPixelsAtNative(@this, x, y);
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe int GetSizeInBytes()
		{
			fixed (ImTextureData* @this = &this)
			{
				int ret = ImGui.GetSizeInBytesNative(@this);
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe ImTextureID GetTexID()
		{
			fixed (ImTextureData* @this = &this)
			{
				ImTextureID ret = ImGui.GetTexIDNative(@this);
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void SetStatus(ImTextureStatus status)
		{
			fixed (ImTextureData* @this = &this)
			{
				ImGui.SetStatusNative(@this, status);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void SetTexID(ImTextureID texId)
		{
			fixed (ImTextureData* @this = &this)
			{
				ImGui.SetTexIDNative(@this, texId);
			}
		}

	}

	/// <summary>
	/// To be documented.
	/// </summary>
	#if NET5_0_OR_GREATER
	[DebuggerDisplay("{DebuggerDisplay,nq}")]
	#endif
	public unsafe struct ImTextureDataPtr : IEquatable<ImTextureDataPtr>
	{
		public ImTextureDataPtr(ImTextureData* handle) { Handle = handle; }

		public ImTextureData* Handle;

		public bool IsNull => Handle == null;

		public static ImTextureDataPtr Null => new ImTextureDataPtr(null);

		public ImTextureData this[int index] { get => Handle[index]; set => Handle[index] = value; }

		public static implicit operator ImTextureDataPtr(ImTextureData* handle) => new ImTextureDataPtr(handle);

		public static implicit operator ImTextureData*(ImTextureDataPtr handle) => handle.Handle;

		public static bool operator ==(ImTextureDataPtr left, ImTextureDataPtr right) => left.Handle == right.Handle;

		public static bool operator !=(ImTextureDataPtr left, ImTextureDataPtr right) => left.Handle != right.Handle;

		public static bool operator ==(ImTextureDataPtr left, ImTextureData* right) => left.Handle == right;

		public static bool operator !=(ImTextureDataPtr left, ImTextureData* right) => left.Handle != right;

		public bool Equals(ImTextureDataPtr other) => Handle == other.Handle;

		/// <inheritdoc/>
		public override bool Equals(object obj) => obj is ImTextureDataPtr handle && Equals(handle);

		/// <inheritdoc/>
		public override int GetHashCode() => ((nuint)Handle).GetHashCode();

		#if NET5_0_OR_GREATER
		private string DebuggerDisplay => string.Format("ImTextureDataPtr [0x{0}]", ((nuint)Handle).ToString("X"));
		#endif
		/// <summary>
		/// To be documented.
		/// </summary>
		public ref int UniqueID => ref Unsafe.AsRef<int>(&Handle->UniqueID);
		/// <summary>
		/// To be documented.
		/// </summary>
		public ref ImTextureStatus Status => ref Unsafe.AsRef<ImTextureStatus>(&Handle->Status);
		/// <summary>
		/// To be documented.
		/// </summary>
		public void* BackendUserData { get => Handle->BackendUserData; set => Handle->BackendUserData = value; }
		/// <summary>
		/// To be documented.
		/// </summary>
		public ref ImTextureID TexID => ref Unsafe.AsRef<ImTextureID>(&Handle->TexID);
		/// <summary>
		/// To be documented.
		/// </summary>
		public ref ImTextureFormat Format => ref Unsafe.AsRef<ImTextureFormat>(&Handle->Format);
		/// <summary>
		/// To be documented.
		/// </summary>
		public ref int Width => ref Unsafe.AsRef<int>(&Handle->Width);
		/// <summary>
		/// To be documented.
		/// </summary>
		public ref int Height => ref Unsafe.AsRef<int>(&Handle->Height);
		/// <summary>
		/// To be documented.
		/// </summary>
		public ref int BytesPerPixel => ref Unsafe.AsRef<int>(&Handle->BytesPerPixel);
		/// <summary>
		/// To be documented.
		/// </summary>
		public byte* Pixels { get => Handle->Pixels; set => Handle->Pixels = value; }
		/// <summary>
		/// To be documented.
		/// </summary>
		public ref ImTextureRect UsedRect => ref Unsafe.AsRef<ImTextureRect>(&Handle->UsedRect);
		/// <summary>
		/// To be documented.
		/// </summary>
		public ref ImTextureRect UpdateRect => ref Unsafe.AsRef<ImTextureRect>(&Handle->UpdateRect);
		/// <summary>
		/// To be documented.
		/// </summary>
		public ref ImVector<ImTextureRect> Updates => ref Unsafe.AsRef<ImVector<ImTextureRect>>(&Handle->Updates);
		/// <summary>
		/// To be documented.
		/// </summary>
		public ref int UnusedFrames => ref Unsafe.AsRef<int>(&Handle->UnusedFrames);
		/// <summary>
		/// To be documented.
		/// </summary>
		public ref ushort RefCount => ref Unsafe.AsRef<ushort>(&Handle->RefCount);
		/// <summary>
		/// To be documented.
		/// </summary>
		public ref bool UseColors => ref Unsafe.AsRef<bool>(&Handle->UseColors);
		/// <summary>
		/// To be documented.
		/// </summary>
		public ref bool WantDestroyNextFrame => ref Unsafe.AsRef<bool>(&Handle->WantDestroyNextFrame);
		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void Create(ImTextureFormat format, int w, int h)
		{
			ImGui.CreateNative(Handle, format, w, h);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void Destroy()
		{
			ImGui.DestroyNative(Handle);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void DestroyPixels()
		{
			ImGui.DestroyPixelsNative(Handle);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe int GetPitch()
		{
			int ret = ImGui.GetPitchNative(Handle);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void* GetPixels()
		{
			void* ret = ImGui.GetPixelsNative(Handle);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void* GetPixelsAt(int x, int y)
		{
			void* ret = ImGui.GetPixelsAtNative(Handle, x, y);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe int GetSizeInBytes()
		{
			int ret = ImGui.GetSizeInBytesNative(Handle);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe ImTextureID GetTexID()
		{
			ImTextureID ret = ImGui.GetTexIDNative(Handle);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void SetStatus(ImTextureStatus status)
		{
			ImGui.SetStatusNative(Handle, status);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void SetTexID(ImTextureID texId)
		{
			ImGui.SetTexIDNative(Handle, texId);
		}

	}

	/// <summary>
	/// To be documented.
	/// </summary>
	#if NET5_0_OR_GREATER
	[DebuggerDisplay("{DebuggerDisplay,nq}")]
	#endif
	public unsafe struct ImTextureDataPtrPtr : IEquatable<ImTextureDataPtrPtr>
	{
		public ImTextureDataPtrPtr(ImTextureData** handle) { Handle = handle; }

		public ImTextureData** Handle;

		public bool IsNull => Handle == null;

		public static ImTextureDataPtrPtr Null => new ImTextureDataPtrPtr(null);

		public ImTextureData* this[int index] { get => Handle[index]; set => Handle[index] = value; }

		public static implicit operator ImTextureDataPtrPtr(ImTextureData** handle) => new ImTextureDataPtrPtr(handle);

		public static implicit operator ImTextureData**(ImTextureDataPtrPtr handle) => handle.Handle;

		public static bool operator ==(ImTextureDataPtrPtr left, ImTextureDataPtrPtr right) => left.Handle == right.Handle;

		public static bool operator !=(ImTextureDataPtrPtr left, ImTextureDataPtrPtr right) => left.Handle != right.Handle;

		public static bool operator ==(ImTextureDataPtrPtr left, ImTextureData** right) => left.Handle == right;

		public static bool operator !=(ImTextureDataPtrPtr left, ImTextureData** right) => left.Handle != right;

		public bool Equals(ImTextureDataPtrPtr other) => Handle == other.Handle;

		/// <inheritdoc/>
		public override bool Equals(object obj) => obj is ImTextureDataPtrPtr handle && Equals(handle);

		/// <inheritdoc/>
		public override int GetHashCode() => ((nuint)Handle).GetHashCode();

		#if NET5_0_OR_GREATER
		private string DebuggerDisplay => string.Format("ImTextureDataPtrPtr [0x{0}]", ((nuint)Handle).ToString("X"));
		#endif
	}

}
