// ------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
// ------------------------------------------------------------------------------

using System;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;
using HexaGen.Runtime;
using System.Numerics;

namespace Hexa.NET.ImGui
{
	public unsafe partial class ImGui
	{

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool BeginTable(ref byte strId, int columns)
		{
			fixed (byte* pstrId = &strId)
			{
				byte ret = BeginTableNative((byte*)pstrId, columns, (ImGuiTableFlags)(0), (Vector2)(new Vector2(0.0f,0.0f)), (float)(0.0f));
				return ret != 0;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool BeginTable(ref byte strId, int columns, Vector2 outerSize)
		{
			fixed (byte* pstrId = &strId)
			{
				byte ret = BeginTableNative((byte*)pstrId, columns, (ImGuiTableFlags)(0), outerSize, (float)(0.0f));
				return ret != 0;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool BeginTable(ref byte strId, int columns, ImGuiTableFlags flags, float innerWidth)
		{
			fixed (byte* pstrId = &strId)
			{
				byte ret = BeginTableNative((byte*)pstrId, columns, flags, (Vector2)(new Vector2(0.0f,0.0f)), innerWidth);
				return ret != 0;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool BeginTable(ref byte strId, int columns, float innerWidth)
		{
			fixed (byte* pstrId = &strId)
			{
				byte ret = BeginTableNative((byte*)pstrId, columns, (ImGuiTableFlags)(0), (Vector2)(new Vector2(0.0f,0.0f)), innerWidth);
				return ret != 0;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool BeginTable(ref byte strId, int columns, Vector2 outerSize, float innerWidth)
		{
			fixed (byte* pstrId = &strId)
			{
				byte ret = BeginTableNative((byte*)pstrId, columns, (ImGuiTableFlags)(0), outerSize, innerWidth);
				return ret != 0;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool BeginTable(ReadOnlySpan<byte> strId, int columns, ImGuiTableFlags flags, Vector2 outerSize, float innerWidth)
		{
			fixed (byte* pstrId = strId)
			{
				byte ret = BeginTableNative((byte*)pstrId, columns, flags, outerSize, innerWidth);
				return ret != 0;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool BeginTable(ReadOnlySpan<byte> strId, int columns, ImGuiTableFlags flags, Vector2 outerSize)
		{
			fixed (byte* pstrId = strId)
			{
				byte ret = BeginTableNative((byte*)pstrId, columns, flags, outerSize, (float)(0.0f));
				return ret != 0;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool BeginTable(ReadOnlySpan<byte> strId, int columns, ImGuiTableFlags flags)
		{
			fixed (byte* pstrId = strId)
			{
				byte ret = BeginTableNative((byte*)pstrId, columns, flags, (Vector2)(new Vector2(0.0f,0.0f)), (float)(0.0f));
				return ret != 0;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool BeginTable(ReadOnlySpan<byte> strId, int columns)
		{
			fixed (byte* pstrId = strId)
			{
				byte ret = BeginTableNative((byte*)pstrId, columns, (ImGuiTableFlags)(0), (Vector2)(new Vector2(0.0f,0.0f)), (float)(0.0f));
				return ret != 0;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool BeginTable(ReadOnlySpan<byte> strId, int columns, Vector2 outerSize)
		{
			fixed (byte* pstrId = strId)
			{
				byte ret = BeginTableNative((byte*)pstrId, columns, (ImGuiTableFlags)(0), outerSize, (float)(0.0f));
				return ret != 0;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool BeginTable(ReadOnlySpan<byte> strId, int columns, ImGuiTableFlags flags, float innerWidth)
		{
			fixed (byte* pstrId = strId)
			{
				byte ret = BeginTableNative((byte*)pstrId, columns, flags, (Vector2)(new Vector2(0.0f,0.0f)), innerWidth);
				return ret != 0;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool BeginTable(ReadOnlySpan<byte> strId, int columns, float innerWidth)
		{
			fixed (byte* pstrId = strId)
			{
				byte ret = BeginTableNative((byte*)pstrId, columns, (ImGuiTableFlags)(0), (Vector2)(new Vector2(0.0f,0.0f)), innerWidth);
				return ret != 0;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool BeginTable(ReadOnlySpan<byte> strId, int columns, Vector2 outerSize, float innerWidth)
		{
			fixed (byte* pstrId = strId)
			{
				byte ret = BeginTableNative((byte*)pstrId, columns, (ImGuiTableFlags)(0), outerSize, innerWidth);
				return ret != 0;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool BeginTable(string strId, int columns, ImGuiTableFlags flags, Vector2 outerSize, float innerWidth)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (strId != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(strId);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(strId, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = BeginTableNative(pStr0, columns, flags, outerSize, innerWidth);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool BeginTable(string strId, int columns, ImGuiTableFlags flags, Vector2 outerSize)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (strId != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(strId);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(strId, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = BeginTableNative(pStr0, columns, flags, outerSize, (float)(0.0f));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool BeginTable(string strId, int columns, ImGuiTableFlags flags)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (strId != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(strId);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(strId, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = BeginTableNative(pStr0, columns, flags, (Vector2)(new Vector2(0.0f,0.0f)), (float)(0.0f));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool BeginTable(string strId, int columns)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (strId != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(strId);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(strId, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = BeginTableNative(pStr0, columns, (ImGuiTableFlags)(0), (Vector2)(new Vector2(0.0f,0.0f)), (float)(0.0f));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool BeginTable(string strId, int columns, Vector2 outerSize)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (strId != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(strId);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(strId, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = BeginTableNative(pStr0, columns, (ImGuiTableFlags)(0), outerSize, (float)(0.0f));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool BeginTable(string strId, int columns, ImGuiTableFlags flags, float innerWidth)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (strId != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(strId);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(strId, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = BeginTableNative(pStr0, columns, flags, (Vector2)(new Vector2(0.0f,0.0f)), innerWidth);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool BeginTable(string strId, int columns, float innerWidth)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (strId != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(strId);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(strId, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = BeginTableNative(pStr0, columns, (ImGuiTableFlags)(0), (Vector2)(new Vector2(0.0f,0.0f)), innerWidth);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool BeginTable(string strId, int columns, Vector2 outerSize, float innerWidth)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (strId != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(strId);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(strId, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = BeginTableNative(pStr0, columns, (ImGuiTableFlags)(0), outerSize, innerWidth);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		/// <summary>
		/// only call EndTable() if BeginTable() returns true!<br/>
		/// </summary>
		internal static void EndTableNative()
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<void>)vt[269])();
			#else
			((delegate* unmanaged[Cdecl]<void>)vt[269])();
			#endif
		}

		/// <summary>
		/// only call EndTable() if BeginTable() returns true!<br/>
		/// </summary>
		public static void EndTable()
		{
			EndTableNative();
		}

		/// <summary>
		/// append into the first cell of a new row.<br/>
		/// </summary>
		internal static void TableNextRowNative(ImGuiTableRowFlags rowFlags, float minRowHeight)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<ImGuiTableRowFlags, float, void>)vt[270])(rowFlags, minRowHeight);
			#else
			((delegate* unmanaged[Cdecl]<ImGuiTableRowFlags, float, void>)vt[270])(rowFlags, minRowHeight);
			#endif
		}

		/// <summary>
		/// append into the first cell of a new row.<br/>
		/// </summary>
		public static void TableNextRow(ImGuiTableRowFlags rowFlags, float minRowHeight)
		{
			TableNextRowNative(rowFlags, minRowHeight);
		}

		/// <summary>
		/// append into the first cell of a new row.<br/>
		/// </summary>
		public static void TableNextRow(ImGuiTableRowFlags rowFlags)
		{
			TableNextRowNative(rowFlags, (float)(0.0f));
		}

		/// <summary>
		/// append into the first cell of a new row.<br/>
		/// </summary>
		public static void TableNextRow()
		{
			TableNextRowNative((ImGuiTableRowFlags)(0), (float)(0.0f));
		}

		/// <summary>
		/// append into the first cell of a new row.<br/>
		/// </summary>
		public static void TableNextRow(float minRowHeight)
		{
			TableNextRowNative((ImGuiTableRowFlags)(0), minRowHeight);
		}

		/// <summary>
		/// append into the next column (or first column of next row if currently in last column). Return true when column is visible.<br/>
		/// </summary>
		internal static byte TableNextColumnNative()
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<byte>)vt[271])();
			#else
			return (byte)((delegate* unmanaged[Cdecl]<byte>)vt[271])();
			#endif
		}

		/// <summary>
		/// append into the next column (or first column of next row if currently in last column). Return true when column is visible.<br/>
		/// </summary>
		public static bool TableNextColumn()
		{
			byte ret = TableNextColumnNative();
			return ret != 0;
		}

		/// <summary>
		/// append into the specified column. Return true when column is visible.<br/>
		/// </summary>
		internal static byte TableSetColumnIndexNative(int columnN)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<int, byte>)vt[272])(columnN);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<int, byte>)vt[272])(columnN);
			#endif
		}

		/// <summary>
		/// append into the specified column. Return true when column is visible.<br/>
		/// </summary>
		public static bool TableSetColumnIndex(int columnN)
		{
			byte ret = TableSetColumnIndexNative(columnN);
			return ret != 0;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		internal static void TableSetupColumnNative(byte* label, ImGuiTableColumnFlags flags, float initWidthOrWeight, uint userId)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<byte*, ImGuiTableColumnFlags, float, uint, void>)vt[273])(label, flags, initWidthOrWeight, userId);
			#else
			((delegate* unmanaged[Cdecl]<nint, ImGuiTableColumnFlags, float, uint, void>)vt[273])((nint)label, flags, initWidthOrWeight, userId);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void TableSetupColumn(byte* label, ImGuiTableColumnFlags flags, float initWidthOrWeight, uint userId)
		{
			TableSetupColumnNative(label, flags, initWidthOrWeight, userId);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void TableSetupColumn(byte* label, ImGuiTableColumnFlags flags, float initWidthOrWeight)
		{
			TableSetupColumnNative(label, flags, initWidthOrWeight, (uint)(0));
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void TableSetupColumn(byte* label, ImGuiTableColumnFlags flags)
		{
			TableSetupColumnNative(label, flags, (float)(0.0f), (uint)(0));
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void TableSetupColumn(byte* label)
		{
			TableSetupColumnNative(label, (ImGuiTableColumnFlags)(0), (float)(0.0f), (uint)(0));
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void TableSetupColumn(byte* label, float initWidthOrWeight)
		{
			TableSetupColumnNative(label, (ImGuiTableColumnFlags)(0), initWidthOrWeight, (uint)(0));
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void TableSetupColumn(byte* label, ImGuiTableColumnFlags flags, uint userId)
		{
			TableSetupColumnNative(label, flags, (float)(0.0f), userId);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void TableSetupColumn(byte* label, uint userId)
		{
			TableSetupColumnNative(label, (ImGuiTableColumnFlags)(0), (float)(0.0f), userId);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void TableSetupColumn(byte* label, float initWidthOrWeight, uint userId)
		{
			TableSetupColumnNative(label, (ImGuiTableColumnFlags)(0), initWidthOrWeight, userId);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void TableSetupColumn(ref byte label, ImGuiTableColumnFlags flags, float initWidthOrWeight, uint userId)
		{
			fixed (byte* plabel = &label)
			{
				TableSetupColumnNative((byte*)plabel, flags, initWidthOrWeight, userId);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void TableSetupColumn(ref byte label, ImGuiTableColumnFlags flags, float initWidthOrWeight)
		{
			fixed (byte* plabel = &label)
			{
				TableSetupColumnNative((byte*)plabel, flags, initWidthOrWeight, (uint)(0));
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void TableSetupColumn(ref byte label, ImGuiTableColumnFlags flags)
		{
			fixed (byte* plabel = &label)
			{
				TableSetupColumnNative((byte*)plabel, flags, (float)(0.0f), (uint)(0));
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void TableSetupColumn(ref byte label)
		{
			fixed (byte* plabel = &label)
			{
				TableSetupColumnNative((byte*)plabel, (ImGuiTableColumnFlags)(0), (float)(0.0f), (uint)(0));
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void TableSetupColumn(ref byte label, float initWidthOrWeight)
		{
			fixed (byte* plabel = &label)
			{
				TableSetupColumnNative((byte*)plabel, (ImGuiTableColumnFlags)(0), initWidthOrWeight, (uint)(0));
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void TableSetupColumn(ref byte label, ImGuiTableColumnFlags flags, uint userId)
		{
			fixed (byte* plabel = &label)
			{
				TableSetupColumnNative((byte*)plabel, flags, (float)(0.0f), userId);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void TableSetupColumn(ref byte label, uint userId)
		{
			fixed (byte* plabel = &label)
			{
				TableSetupColumnNative((byte*)plabel, (ImGuiTableColumnFlags)(0), (float)(0.0f), userId);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void TableSetupColumn(ref byte label, float initWidthOrWeight, uint userId)
		{
			fixed (byte* plabel = &label)
			{
				TableSetupColumnNative((byte*)plabel, (ImGuiTableColumnFlags)(0), initWidthOrWeight, userId);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void TableSetupColumn(ReadOnlySpan<byte> label, ImGuiTableColumnFlags flags, float initWidthOrWeight, uint userId)
		{
			fixed (byte* plabel = label)
			{
				TableSetupColumnNative((byte*)plabel, flags, initWidthOrWeight, userId);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void TableSetupColumn(ReadOnlySpan<byte> label, ImGuiTableColumnFlags flags, float initWidthOrWeight)
		{
			fixed (byte* plabel = label)
			{
				TableSetupColumnNative((byte*)plabel, flags, initWidthOrWeight, (uint)(0));
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void TableSetupColumn(ReadOnlySpan<byte> label, ImGuiTableColumnFlags flags)
		{
			fixed (byte* plabel = label)
			{
				TableSetupColumnNative((byte*)plabel, flags, (float)(0.0f), (uint)(0));
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void TableSetupColumn(ReadOnlySpan<byte> label)
		{
			fixed (byte* plabel = label)
			{
				TableSetupColumnNative((byte*)plabel, (ImGuiTableColumnFlags)(0), (float)(0.0f), (uint)(0));
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void TableSetupColumn(ReadOnlySpan<byte> label, float initWidthOrWeight)
		{
			fixed (byte* plabel = label)
			{
				TableSetupColumnNative((byte*)plabel, (ImGuiTableColumnFlags)(0), initWidthOrWeight, (uint)(0));
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void TableSetupColumn(ReadOnlySpan<byte> label, ImGuiTableColumnFlags flags, uint userId)
		{
			fixed (byte* plabel = label)
			{
				TableSetupColumnNative((byte*)plabel, flags, (float)(0.0f), userId);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void TableSetupColumn(ReadOnlySpan<byte> label, uint userId)
		{
			fixed (byte* plabel = label)
			{
				TableSetupColumnNative((byte*)plabel, (ImGuiTableColumnFlags)(0), (float)(0.0f), userId);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void TableSetupColumn(ReadOnlySpan<byte> label, float initWidthOrWeight, uint userId)
		{
			fixed (byte* plabel = label)
			{
				TableSetupColumnNative((byte*)plabel, (ImGuiTableColumnFlags)(0), initWidthOrWeight, userId);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void TableSetupColumn(string label, ImGuiTableColumnFlags flags, float initWidthOrWeight, uint userId)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			TableSetupColumnNative(pStr0, flags, initWidthOrWeight, userId);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void TableSetupColumn(string label, ImGuiTableColumnFlags flags, float initWidthOrWeight)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			TableSetupColumnNative(pStr0, flags, initWidthOrWeight, (uint)(0));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void TableSetupColumn(string label, ImGuiTableColumnFlags flags)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			TableSetupColumnNative(pStr0, flags, (float)(0.0f), (uint)(0));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void TableSetupColumn(string label)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			TableSetupColumnNative(pStr0, (ImGuiTableColumnFlags)(0), (float)(0.0f), (uint)(0));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void TableSetupColumn(string label, float initWidthOrWeight)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			TableSetupColumnNative(pStr0, (ImGuiTableColumnFlags)(0), initWidthOrWeight, (uint)(0));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void TableSetupColumn(string label, ImGuiTableColumnFlags flags, uint userId)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			TableSetupColumnNative(pStr0, flags, (float)(0.0f), userId);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void TableSetupColumn(string label, uint userId)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			TableSetupColumnNative(pStr0, (ImGuiTableColumnFlags)(0), (float)(0.0f), userId);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void TableSetupColumn(string label, float initWidthOrWeight, uint userId)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			TableSetupColumnNative(pStr0, (ImGuiTableColumnFlags)(0), initWidthOrWeight, userId);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		/// <summary>
		/// lock columnsrows so they stay visible when scrolled.<br/>
		/// </summary>
		internal static void TableSetupScrollFreezeNative(int cols, int rows)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<int, int, void>)vt[274])(cols, rows);
			#else
			((delegate* unmanaged[Cdecl]<int, int, void>)vt[274])(cols, rows);
			#endif
		}

		/// <summary>
		/// lock columnsrows so they stay visible when scrolled.<br/>
		/// </summary>
		public static void TableSetupScrollFreeze(int cols, int rows)
		{
			TableSetupScrollFreezeNative(cols, rows);
		}

		/// <summary>
		/// submit one header cell manually (rarely used)<br/>
		/// </summary>
		internal static void TableHeaderNative(byte* label)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<byte*, void>)vt[275])(label);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)vt[275])((nint)label);
			#endif
		}

		/// <summary>
		/// submit one header cell manually (rarely used)<br/>
		/// </summary>
		public static void TableHeader(byte* label)
		{
			TableHeaderNative(label);
		}

		/// <summary>
		/// submit one header cell manually (rarely used)<br/>
		/// </summary>
		public static void TableHeader(ref byte label)
		{
			fixed (byte* plabel = &label)
			{
				TableHeaderNative((byte*)plabel);
			}
		}

		/// <summary>
		/// submit one header cell manually (rarely used)<br/>
		/// </summary>
		public static void TableHeader(ReadOnlySpan<byte> label)
		{
			fixed (byte* plabel = label)
			{
				TableHeaderNative((byte*)plabel);
			}
		}

		/// <summary>
		/// submit one header cell manually (rarely used)<br/>
		/// </summary>
		public static void TableHeader(string label)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			TableHeaderNative(pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		/// <summary>
		/// submit a row with headers cells based on data provided to TableSetupColumn() + submit context menu<br/>
		/// </summary>
		internal static void TableHeadersRowNative()
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<void>)vt[276])();
			#else
			((delegate* unmanaged[Cdecl]<void>)vt[276])();
			#endif
		}

		/// <summary>
		/// submit a row with headers cells based on data provided to TableSetupColumn() + submit context menu<br/>
		/// </summary>
		public static void TableHeadersRow()
		{
			TableHeadersRowNative();
		}

		/// <summary>
		/// submit a row with angled headers for every column with the ImGuiTableColumnFlags_AngledHeader flag. MUST BE FIRST ROW.<br/>
		/// </summary>
		internal static void TableAngledHeadersRowNative()
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<void>)vt[277])();
			#else
			((delegate* unmanaged[Cdecl]<void>)vt[277])();
			#endif
		}

		/// <summary>
		/// submit a row with angled headers for every column with the ImGuiTableColumnFlags_AngledHeader flag. MUST BE FIRST ROW.<br/>
		/// </summary>
		public static void TableAngledHeadersRow()
		{
			TableAngledHeadersRowNative();
		}

		/// <summary>
		/// get latest sort specs for the table (NULL if not sorting).  Lifetime: don't hold on this pointer over multiple frames or past any subsequent call to BeginTable().<br/>
		/// </summary>
		internal static ImGuiTableSortSpecs* TableGetSortSpecsNative()
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<ImGuiTableSortSpecs*>)vt[278])();
			#else
			return (ImGuiTableSortSpecs*)((delegate* unmanaged[Cdecl]<nint>)vt[278])();
			#endif
		}

		/// <summary>
		/// get latest sort specs for the table (NULL if not sorting).  Lifetime: don't hold on this pointer over multiple frames or past any subsequent call to BeginTable().<br/>
		/// </summary>
		public static ImGuiTableSortSpecsPtr TableGetSortSpecs()
		{
			ImGuiTableSortSpecsPtr ret = TableGetSortSpecsNative();
			return ret;
		}

		/// <summary>
		/// return number of columns (value passed to BeginTable)<br/>
		/// </summary>
		internal static int TableGetColumnCountNative()
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<int>)vt[279])();
			#else
			return (int)((delegate* unmanaged[Cdecl]<int>)vt[279])();
			#endif
		}

		/// <summary>
		/// return number of columns (value passed to BeginTable)<br/>
		/// </summary>
		public static int TableGetColumnCount()
		{
			int ret = TableGetColumnCountNative();
			return ret;
		}

		/// <summary>
		/// return current column index.<br/>
		/// </summary>
		internal static int TableGetColumnIndexNative()
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<int>)vt[280])();
			#else
			return (int)((delegate* unmanaged[Cdecl]<int>)vt[280])();
			#endif
		}

		/// <summary>
		/// return current column index.<br/>
		/// </summary>
		public static int TableGetColumnIndex()
		{
			int ret = TableGetColumnIndexNative();
			return ret;
		}

		/// <summary>
		/// return current row index.<br/>
		/// </summary>
		internal static int TableGetRowIndexNative()
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<int>)vt[281])();
			#else
			return (int)((delegate* unmanaged[Cdecl]<int>)vt[281])();
			#endif
		}

		/// <summary>
		/// return current row index.<br/>
		/// </summary>
		public static int TableGetRowIndex()
		{
			int ret = TableGetRowIndexNative();
			return ret;
		}

		/// <summary>
		/// return "" if column didn't have a name declared by TableSetupColumn(). Pass -1 to use current column.<br/>
		/// </summary>
		internal static byte* TableGetColumnNameNative(int columnN)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<int, byte*>)vt[282])(columnN);
			#else
			return (byte*)((delegate* unmanaged[Cdecl]<int, nint>)vt[282])(columnN);
			#endif
		}

		/// <summary>
		/// return "" if column didn't have a name declared by TableSetupColumn(). Pass -1 to use current column.<br/>
		/// </summary>
		public static byte* TableGetColumnName(int columnN)
		{
			byte* ret = TableGetColumnNameNative(columnN);
			return ret;
		}

		/// <summary>
		/// return "" if column didn't have a name declared by TableSetupColumn(). Pass -1 to use current column.<br/>
		/// </summary>
		public static byte* TableGetColumnName()
		{
			byte* ret = TableGetColumnNameNative((int)(-1));
			return ret;
		}

		/// <summary>
		/// return "" if column didn't have a name declared by TableSetupColumn(). Pass -1 to use current column.<br/>
		/// </summary>
		public static string TableGetColumnNameS()
		{
			string ret = Utils.DecodeStringUTF8(TableGetColumnNameNative((int)(-1)));
			return ret;
		}

		/// <summary>
		/// return "" if column didn't have a name declared by TableSetupColumn(). Pass -1 to use current column.<br/>
		/// </summary>
		public static string TableGetColumnNameS(int columnN)
		{
			string ret = Utils.DecodeStringUTF8(TableGetColumnNameNative(columnN));
			return ret;
		}

		/// <summary>
		/// return column flags so you can query their EnabledVisibleSortedHovered status flags. Pass -1 to use current column.<br/>
		/// </summary>
		internal static ImGuiTableColumnFlags TableGetColumnFlagsNative(int columnN)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<int, ImGuiTableColumnFlags>)vt[283])(columnN);
			#else
			return (ImGuiTableColumnFlags)((delegate* unmanaged[Cdecl]<int, ImGuiTableColumnFlags>)vt[283])(columnN);
			#endif
		}

		/// <summary>
		/// return column flags so you can query their EnabledVisibleSortedHovered status flags. Pass -1 to use current column.<br/>
		/// </summary>
		public static ImGuiTableColumnFlags TableGetColumnFlags(int columnN)
		{
			ImGuiTableColumnFlags ret = TableGetColumnFlagsNative(columnN);
			return ret;
		}

		/// <summary>
		/// return column flags so you can query their EnabledVisibleSortedHovered status flags. Pass -1 to use current column.<br/>
		/// </summary>
		public static ImGuiTableColumnFlags TableGetColumnFlags()
		{
			ImGuiTableColumnFlags ret = TableGetColumnFlagsNative((int)(-1));
			return ret;
		}

		/// <summary>
		/// change user accessible enableddisabled state of a column. Set to false to hide the column. User can use the context menu to change this themselves (right-click in headers, or right-click in columns body with ImGuiTableFlags_ContextMenuInBody)<br/>
		/// </summary>
		internal static void TableSetColumnEnabledNative(int columnN, byte v)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<int, byte, void>)vt[284])(columnN, v);
			#else
			((delegate* unmanaged[Cdecl]<int, byte, void>)vt[284])(columnN, v);
			#endif
		}

		/// <summary>
		/// change user accessible enableddisabled state of a column. Set to false to hide the column. User can use the context menu to change this themselves (right-click in headers, or right-click in columns body with ImGuiTableFlags_ContextMenuInBody)<br/>
		/// </summary>
		public static void TableSetColumnEnabled(int columnN, bool v)
		{
			TableSetColumnEnabledNative(columnN, v ? (byte)1 : (byte)0);
		}

		/// <summary>
		/// return hovered column. return -1 when table is not hovered. return columns_count if the unused space at the right of visible columns is hovered. Can also use (TableGetColumnFlags() &amp; ImGuiTableColumnFlags_IsHovered) instead.<br/>
		/// </summary>
		internal static int TableGetHoveredColumnNative()
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<int>)vt[285])();
			#else
			return (int)((delegate* unmanaged[Cdecl]<int>)vt[285])();
			#endif
		}

		/// <summary>
		/// return hovered column. return -1 when table is not hovered. return columns_count if the unused space at the right of visible columns is hovered. Can also use (TableGetColumnFlags() &amp; ImGuiTableColumnFlags_IsHovered) instead.<br/>
		/// </summary>
		public static int TableGetHoveredColumn()
		{
			int ret = TableGetHoveredColumnNative();
			return ret;
		}

		/// <summary>
		/// change the color of a cell, row, or column. See ImGuiTableBgTarget_ flags for details.<br/>
		/// </summary>
		internal static void TableSetBgColorNative(ImGuiTableBgTarget target, uint color, int columnN)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<ImGuiTableBgTarget, uint, int, void>)vt[286])(target, color, columnN);
			#else
			((delegate* unmanaged[Cdecl]<ImGuiTableBgTarget, uint, int, void>)vt[286])(target, color, columnN);
			#endif
		}

		/// <summary>
		/// change the color of a cell, row, or column. See ImGuiTableBgTarget_ flags for details.<br/>
		/// </summary>
		public static void TableSetBgColor(ImGuiTableBgTarget target, uint color, int columnN)
		{
			TableSetBgColorNative(target, color, columnN);
		}

		/// <summary>
		/// change the color of a cell, row, or column. See ImGuiTableBgTarget_ flags for details.<br/>
		/// </summary>
		public static void TableSetBgColor(ImGuiTableBgTarget target, uint color)
		{
			TableSetBgColorNative(target, color, (int)(-1));
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		internal static void ColumnsNative(int count, byte* id, byte border)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<int, byte*, byte, void>)vt[287])(count, id, border);
			#else
			((delegate* unmanaged[Cdecl]<int, nint, byte, void>)vt[287])(count, (nint)id, border);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void Columns(int count, byte* id, bool border)
		{
			ColumnsNative(count, id, border ? (byte)1 : (byte)0);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void Columns(int count, byte* id)
		{
			ColumnsNative(count, id, (byte)(1));
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void Columns(int count)
		{
			ColumnsNative(count, (byte*)(default), (byte)(1));
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void Columns()
		{
			ColumnsNative((int)(1), (byte*)(default), (byte)(1));
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void Columns(byte* id)
		{
			ColumnsNative((int)(1), id, (byte)(1));
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void Columns(int count, bool border)
		{
			ColumnsNative(count, (byte*)(default), border ? (byte)1 : (byte)0);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void Columns(bool border)
		{
			ColumnsNative((int)(1), (byte*)(default), border ? (byte)1 : (byte)0);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void Columns(byte* id, bool border)
		{
			ColumnsNative((int)(1), id, border ? (byte)1 : (byte)0);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void Columns(int count, ref byte id, bool border)
		{
			fixed (byte* pid = &id)
			{
				ColumnsNative(count, (byte*)pid, border ? (byte)1 : (byte)0);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void Columns(int count, ref byte id)
		{
			fixed (byte* pid = &id)
			{
				ColumnsNative(count, (byte*)pid, (byte)(1));
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void Columns(ref byte id)
		{
			fixed (byte* pid = &id)
			{
				ColumnsNative((int)(1), (byte*)pid, (byte)(1));
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void Columns(ref byte id, bool border)
		{
			fixed (byte* pid = &id)
			{
				ColumnsNative((int)(1), (byte*)pid, border ? (byte)1 : (byte)0);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void Columns(int count, ReadOnlySpan<byte> id, bool border)
		{
			fixed (byte* pid = id)
			{
				ColumnsNative(count, (byte*)pid, border ? (byte)1 : (byte)0);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void Columns(int count, ReadOnlySpan<byte> id)
		{
			fixed (byte* pid = id)
			{
				ColumnsNative(count, (byte*)pid, (byte)(1));
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void Columns(ReadOnlySpan<byte> id)
		{
			fixed (byte* pid = id)
			{
				ColumnsNative((int)(1), (byte*)pid, (byte)(1));
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void Columns(ReadOnlySpan<byte> id, bool border)
		{
			fixed (byte* pid = id)
			{
				ColumnsNative((int)(1), (byte*)pid, border ? (byte)1 : (byte)0);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void Columns(int count, string id, bool border)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (id != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(id);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(id, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			ColumnsNative(count, pStr0, border ? (byte)1 : (byte)0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void Columns(int count, string id)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (id != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(id);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(id, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			ColumnsNative(count, pStr0, (byte)(1));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void Columns(string id)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (id != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(id);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(id, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			ColumnsNative((int)(1), pStr0, (byte)(1));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void Columns(string id, bool border)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (id != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(id);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(id, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			ColumnsNative((int)(1), pStr0, border ? (byte)1 : (byte)0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		/// <summary>
		/// next column, defaults to current row or next row if the current row is finished<br/>
		/// </summary>
		internal static void NextColumnNative()
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<void>)vt[288])();
			#else
			((delegate* unmanaged[Cdecl]<void>)vt[288])();
			#endif
		}

		/// <summary>
		/// next column, defaults to current row or next row if the current row is finished<br/>
		/// </summary>
		public static void NextColumn()
		{
			NextColumnNative();
		}

		/// <summary>
		/// get current column index<br/>
		/// </summary>
		internal static int GetColumnIndexNative()
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<int>)vt[289])();
			#else
			return (int)((delegate* unmanaged[Cdecl]<int>)vt[289])();
			#endif
		}

		/// <summary>
		/// get current column index<br/>
		/// </summary>
		public static int GetColumnIndex()
		{
			int ret = GetColumnIndexNative();
			return ret;
		}

		/// <summary>
		/// get column width (in pixels). pass -1 to use current column<br/>
		/// </summary>
		internal static float GetColumnWidthNative(int columnIndex)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<int, float>)vt[290])(columnIndex);
			#else
			return (float)((delegate* unmanaged[Cdecl]<int, float>)vt[290])(columnIndex);
			#endif
		}

		/// <summary>
		/// get column width (in pixels). pass -1 to use current column<br/>
		/// </summary>
		public static float GetColumnWidth(int columnIndex)
		{
			float ret = GetColumnWidthNative(columnIndex);
			return ret;
		}

		/// <summary>
		/// get column width (in pixels). pass -1 to use current column<br/>
		/// </summary>
		public static float GetColumnWidth()
		{
			float ret = GetColumnWidthNative((int)(-1));
			return ret;
		}

		/// <summary>
		/// set column width (in pixels). pass -1 to use current column<br/>
		/// </summary>
		internal static void SetColumnWidthNative(int columnIndex, float width)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<int, float, void>)vt[291])(columnIndex, width);
			#else
			((delegate* unmanaged[Cdecl]<int, float, void>)vt[291])(columnIndex, width);
			#endif
		}

		/// <summary>
		/// set column width (in pixels). pass -1 to use current column<br/>
		/// </summary>
		public static void SetColumnWidth(int columnIndex, float width)
		{
			SetColumnWidthNative(columnIndex, width);
		}

		/// <summary>
		/// get position of column line (in pixels, from the left side of the contents region). pass -1 to use current column, otherwise 0..GetColumnsCount() inclusive. column 0 is typically 0.0f<br/>
		/// </summary>
		internal static float GetColumnOffsetNative(int columnIndex)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<int, float>)vt[292])(columnIndex);
			#else
			return (float)((delegate* unmanaged[Cdecl]<int, float>)vt[292])(columnIndex);
			#endif
		}

		/// <summary>
		/// get position of column line (in pixels, from the left side of the contents region). pass -1 to use current column, otherwise 0..GetColumnsCount() inclusive. column 0 is typically 0.0f<br/>
		/// </summary>
		public static float GetColumnOffset(int columnIndex)
		{
			float ret = GetColumnOffsetNative(columnIndex);
			return ret;
		}

		/// <summary>
		/// get position of column line (in pixels, from the left side of the contents region). pass -1 to use current column, otherwise 0..GetColumnsCount() inclusive. column 0 is typically 0.0f<br/>
		/// </summary>
		public static float GetColumnOffset()
		{
			float ret = GetColumnOffsetNative((int)(-1));
			return ret;
		}

		/// <summary>
		/// set position of column line (in pixels, from the left side of the contents region). pass -1 to use current column<br/>
		/// </summary>
		internal static void SetColumnOffsetNative(int columnIndex, float offsetX)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<int, float, void>)vt[293])(columnIndex, offsetX);
			#else
			((delegate* unmanaged[Cdecl]<int, float, void>)vt[293])(columnIndex, offsetX);
			#endif
		}

		/// <summary>
		/// set position of column line (in pixels, from the left side of the contents region). pass -1 to use current column<br/>
		/// </summary>
		public static void SetColumnOffset(int columnIndex, float offsetX)
		{
			SetColumnOffsetNative(columnIndex, offsetX);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		internal static int GetColumnsCountNative()
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<int>)vt[294])();
			#else
			return (int)((delegate* unmanaged[Cdecl]<int>)vt[294])();
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static int GetColumnsCount()
		{
			int ret = GetColumnsCountNative();
			return ret;
		}

		/// <summary>
		/// create and append into a TabBar<br/>
		/// </summary>
		internal static byte BeginTabBarNative(byte* strId, ImGuiTabBarFlags flags)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<byte*, ImGuiTabBarFlags, byte>)vt[295])(strId, flags);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<nint, ImGuiTabBarFlags, byte>)vt[295])((nint)strId, flags);
			#endif
		}

		/// <summary>
		/// create and append into a TabBar<br/>
		/// </summary>
		public static bool BeginTabBar(byte* strId, ImGuiTabBarFlags flags)
		{
			byte ret = BeginTabBarNative(strId, flags);
			return ret != 0;
		}

		/// <summary>
		/// create and append into a TabBar<br/>
		/// </summary>
		public static bool BeginTabBar(byte* strId)
		{
			byte ret = BeginTabBarNative(strId, (ImGuiTabBarFlags)(0));
			return ret != 0;
		}

		/// <summary>
		/// create and append into a TabBar<br/>
		/// </summary>
		public static bool BeginTabBar(ref byte strId, ImGuiTabBarFlags flags)
		{
			fixed (byte* pstrId = &strId)
			{
				byte ret = BeginTabBarNative((byte*)pstrId, flags);
				return ret != 0;
			}
		}

		/// <summary>
		/// create and append into a TabBar<br/>
		/// </summary>
		public static bool BeginTabBar(ref byte strId)
		{
			fixed (byte* pstrId = &strId)
			{
				byte ret = BeginTabBarNative((byte*)pstrId, (ImGuiTabBarFlags)(0));
				return ret != 0;
			}
		}

		/// <summary>
		/// create and append into a TabBar<br/>
		/// </summary>
		public static bool BeginTabBar(ReadOnlySpan<byte> strId, ImGuiTabBarFlags flags)
		{
			fixed (byte* pstrId = strId)
			{
				byte ret = BeginTabBarNative((byte*)pstrId, flags);
				return ret != 0;
			}
		}

		/// <summary>
		/// create and append into a TabBar<br/>
		/// </summary>
		public static bool BeginTabBar(ReadOnlySpan<byte> strId)
		{
			fixed (byte* pstrId = strId)
			{
				byte ret = BeginTabBarNative((byte*)pstrId, (ImGuiTabBarFlags)(0));
				return ret != 0;
			}
		}

		/// <summary>
		/// create and append into a TabBar<br/>
		/// </summary>
		public static bool BeginTabBar(string strId, ImGuiTabBarFlags flags)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (strId != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(strId);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(strId, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = BeginTabBarNative(pStr0, flags);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		/// <summary>
		/// create and append into a TabBar<br/>
		/// </summary>
		public static bool BeginTabBar(string strId)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (strId != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(strId);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(strId, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = BeginTabBarNative(pStr0, (ImGuiTabBarFlags)(0));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		/// <summary>
		/// only call EndTabBar() if BeginTabBar() returns true!<br/>
		/// </summary>
		internal static void EndTabBarNative()
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<void>)vt[296])();
			#else
			((delegate* unmanaged[Cdecl]<void>)vt[296])();
			#endif
		}

		/// <summary>
		/// only call EndTabBar() if BeginTabBar() returns true!<br/>
		/// </summary>
		public static void EndTabBar()
		{
			EndTabBarNative();
		}

		/// <summary>
		/// create a Tab. Returns true if the Tab is selected.<br/>
		/// </summary>
		internal static byte BeginTabItemNative(byte* label, bool* pOpen, ImGuiTabItemFlags flags)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<byte*, bool*, ImGuiTabItemFlags, byte>)vt[297])(label, pOpen, flags);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<nint, nint, ImGuiTabItemFlags, byte>)vt[297])((nint)label, (nint)pOpen, flags);
			#endif
		}

		/// <summary>
		/// create a Tab. Returns true if the Tab is selected.<br/>
		/// </summary>
		public static bool BeginTabItem(byte* label, bool* pOpen, ImGuiTabItemFlags flags)
		{
			byte ret = BeginTabItemNative(label, pOpen, flags);
			return ret != 0;
		}

		/// <summary>
		/// create a Tab. Returns true if the Tab is selected.<br/>
		/// </summary>
		public static bool BeginTabItem(byte* label, bool* pOpen)
		{
			byte ret = BeginTabItemNative(label, pOpen, (ImGuiTabItemFlags)(0));
			return ret != 0;
		}

		/// <summary>
		/// create a Tab. Returns true if the Tab is selected.<br/>
		/// </summary>
		public static bool BeginTabItem(byte* label)
		{
			byte ret = BeginTabItemNative(label, (bool*)(default), (ImGuiTabItemFlags)(0));
			return ret != 0;
		}

		/// <summary>
		/// create a Tab. Returns true if the Tab is selected.<br/>
		/// </summary>
		public static bool BeginTabItem(byte* label, ImGuiTabItemFlags flags)
		{
			byte ret = BeginTabItemNative(label, (bool*)(default), flags);
			return ret != 0;
		}

		/// <summary>
		/// create a Tab. Returns true if the Tab is selected.<br/>
		/// </summary>
		public static bool BeginTabItem(ref byte label, bool* pOpen, ImGuiTabItemFlags flags)
		{
			fixed (byte* plabel = &label)
			{
				byte ret = BeginTabItemNative((byte*)plabel, pOpen, flags);
				return ret != 0;
			}
		}

		/// <summary>
		/// create a Tab. Returns true if the Tab is selected.<br/>
		/// </summary>
		public static bool BeginTabItem(ref byte label, bool* pOpen)
		{
			fixed (byte* plabel = &label)
			{
				byte ret = BeginTabItemNative((byte*)plabel, pOpen, (ImGuiTabItemFlags)(0));
				return ret != 0;
			}
		}

		/// <summary>
		/// create a Tab. Returns true if the Tab is selected.<br/>
		/// </summary>
		public static bool BeginTabItem(ref byte label)
		{
			fixed (byte* plabel = &label)
			{
				byte ret = BeginTabItemNative((byte*)plabel, (bool*)(default), (ImGuiTabItemFlags)(0));
				return ret != 0;
			}
		}

		/// <summary>
		/// create a Tab. Returns true if the Tab is selected.<br/>
		/// </summary>
		public static bool BeginTabItem(ref byte label, ImGuiTabItemFlags flags)
		{
			fixed (byte* plabel = &label)
			{
				byte ret = BeginTabItemNative((byte*)plabel, (bool*)(default), flags);
				return ret != 0;
			}
		}

		/// <summary>
		/// create a Tab. Returns true if the Tab is selected.<br/>
		/// </summary>
		public static bool BeginTabItem(ReadOnlySpan<byte> label, bool* pOpen, ImGuiTabItemFlags flags)
		{
			fixed (byte* plabel = label)
			{
				byte ret = BeginTabItemNative((byte*)plabel, pOpen, flags);
				return ret != 0;
			}
		}

		/// <summary>
		/// create a Tab. Returns true if the Tab is selected.<br/>
		/// </summary>
		public static bool BeginTabItem(ReadOnlySpan<byte> label, bool* pOpen)
		{
			fixed (byte* plabel = label)
			{
				byte ret = BeginTabItemNative((byte*)plabel, pOpen, (ImGuiTabItemFlags)(0));
				return ret != 0;
			}
		}

		/// <summary>
		/// create a Tab. Returns true if the Tab is selected.<br/>
		/// </summary>
		public static bool BeginTabItem(ReadOnlySpan<byte> label)
		{
			fixed (byte* plabel = label)
			{
				byte ret = BeginTabItemNative((byte*)plabel, (bool*)(default), (ImGuiTabItemFlags)(0));
				return ret != 0;
			}
		}

		/// <summary>
		/// create a Tab. Returns true if the Tab is selected.<br/>
		/// </summary>
		public static bool BeginTabItem(ReadOnlySpan<byte> label, ImGuiTabItemFlags flags)
		{
			fixed (byte* plabel = label)
			{
				byte ret = BeginTabItemNative((byte*)plabel, (bool*)(default), flags);
				return ret != 0;
			}
		}

		/// <summary>
		/// create a Tab. Returns true if the Tab is selected.<br/>
		/// </summary>
		public static bool BeginTabItem(string label, bool* pOpen, ImGuiTabItemFlags flags)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = BeginTabItemNative(pStr0, pOpen, flags);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		/// <summary>
		/// create a Tab. Returns true if the Tab is selected.<br/>
		/// </summary>
		public static bool BeginTabItem(string label, bool* pOpen)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = BeginTabItemNative(pStr0, pOpen, (ImGuiTabItemFlags)(0));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		/// <summary>
		/// create a Tab. Returns true if the Tab is selected.<br/>
		/// </summary>
		public static bool BeginTabItem(string label)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = BeginTabItemNative(pStr0, (bool*)(default), (ImGuiTabItemFlags)(0));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		/// <summary>
		/// create a Tab. Returns true if the Tab is selected.<br/>
		/// </summary>
		public static bool BeginTabItem(string label, ImGuiTabItemFlags flags)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = BeginTabItemNative(pStr0, (bool*)(default), flags);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		/// <summary>
		/// create a Tab. Returns true if the Tab is selected.<br/>
		/// </summary>
		public static bool BeginTabItem(byte* label, ref bool pOpen, ImGuiTabItemFlags flags)
		{
			fixed (bool* ppOpen = &pOpen)
			{
				byte ret = BeginTabItemNative(label, (bool*)ppOpen, flags);
				return ret != 0;
			}
		}

		/// <summary>
		/// create a Tab. Returns true if the Tab is selected.<br/>
		/// </summary>
		public static bool BeginTabItem(byte* label, ref bool pOpen)
		{
			fixed (bool* ppOpen = &pOpen)
			{
				byte ret = BeginTabItemNative(label, (bool*)ppOpen, (ImGuiTabItemFlags)(0));
				return ret != 0;
			}
		}

		/// <summary>
		/// create a Tab. Returns true if the Tab is selected.<br/>
		/// </summary>
		public static bool BeginTabItem(ref byte label, ref bool pOpen, ImGuiTabItemFlags flags)
		{
			fixed (byte* plabel = &label)
			{
				fixed (bool* ppOpen = &pOpen)
				{
					byte ret = BeginTabItemNative((byte*)plabel, (bool*)ppOpen, flags);
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// create a Tab. Returns true if the Tab is selected.<br/>
		/// </summary>
		public static bool BeginTabItem(ref byte label, ref bool pOpen)
		{
			fixed (byte* plabel = &label)
			{
				fixed (bool* ppOpen = &pOpen)
				{
					byte ret = BeginTabItemNative((byte*)plabel, (bool*)ppOpen, (ImGuiTabItemFlags)(0));
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// create a Tab. Returns true if the Tab is selected.<br/>
		/// </summary>
		public static bool BeginTabItem(ReadOnlySpan<byte> label, ref bool pOpen, ImGuiTabItemFlags flags)
		{
			fixed (byte* plabel = label)
			{
				fixed (bool* ppOpen = &pOpen)
				{
					byte ret = BeginTabItemNative((byte*)plabel, (bool*)ppOpen, flags);
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// create a Tab. Returns true if the Tab is selected.<br/>
		/// </summary>
		public static bool BeginTabItem(ReadOnlySpan<byte> label, ref bool pOpen)
		{
			fixed (byte* plabel = label)
			{
				fixed (bool* ppOpen = &pOpen)
				{
					byte ret = BeginTabItemNative((byte*)plabel, (bool*)ppOpen, (ImGuiTabItemFlags)(0));
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// create a Tab. Returns true if the Tab is selected.<br/>
		/// </summary>
		public static bool BeginTabItem(string label, ref bool pOpen, ImGuiTabItemFlags flags)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (bool* ppOpen = &pOpen)
			{
				byte ret = BeginTabItemNative(pStr0, (bool*)ppOpen, flags);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret != 0;
			}
		}

		/// <summary>
		/// create a Tab. Returns true if the Tab is selected.<br/>
		/// </summary>
		public static bool BeginTabItem(string label, ref bool pOpen)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (bool* ppOpen = &pOpen)
			{
				byte ret = BeginTabItemNative(pStr0, (bool*)ppOpen, (ImGuiTabItemFlags)(0));
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret != 0;
			}
		}

		/// <summary>
		/// only call EndTabItem() if BeginTabItem() returns true!<br/>
		/// </summary>
		internal static void EndTabItemNative()
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<void>)vt[298])();
			#else
			((delegate* unmanaged[Cdecl]<void>)vt[298])();
			#endif
		}

		/// <summary>
		/// only call EndTabItem() if BeginTabItem() returns true!<br/>
		/// </summary>
		public static void EndTabItem()
		{
			EndTabItemNative();
		}

		/// <summary>
		/// create a Tab behaving like a button. return true when clicked. cannot be selected in the tab bar.<br/>
		/// </summary>
		internal static byte TabItemButtonNative(byte* label, ImGuiTabItemFlags flags)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<byte*, ImGuiTabItemFlags, byte>)vt[299])(label, flags);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<nint, ImGuiTabItemFlags, byte>)vt[299])((nint)label, flags);
			#endif
		}

		/// <summary>
		/// create a Tab behaving like a button. return true when clicked. cannot be selected in the tab bar.<br/>
		/// </summary>
		public static bool TabItemButton(byte* label, ImGuiTabItemFlags flags)
		{
			byte ret = TabItemButtonNative(label, flags);
			return ret != 0;
		}

		/// <summary>
		/// create a Tab behaving like a button. return true when clicked. cannot be selected in the tab bar.<br/>
		/// </summary>
		public static bool TabItemButton(byte* label)
		{
			byte ret = TabItemButtonNative(label, (ImGuiTabItemFlags)(0));
			return ret != 0;
		}

		/// <summary>
		/// create a Tab behaving like a button. return true when clicked. cannot be selected in the tab bar.<br/>
		/// </summary>
		public static bool TabItemButton(ref byte label, ImGuiTabItemFlags flags)
		{
			fixed (byte* plabel = &label)
			{
				byte ret = TabItemButtonNative((byte*)plabel, flags);
				return ret != 0;
			}
		}

		/// <summary>
		/// create a Tab behaving like a button. return true when clicked. cannot be selected in the tab bar.<br/>
		/// </summary>
		public static bool TabItemButton(ref byte label)
		{
			fixed (byte* plabel = &label)
			{
				byte ret = TabItemButtonNative((byte*)plabel, (ImGuiTabItemFlags)(0));
				return ret != 0;
			}
		}

		/// <summary>
		/// create a Tab behaving like a button. return true when clicked. cannot be selected in the tab bar.<br/>
		/// </summary>
		public static bool TabItemButton(ReadOnlySpan<byte> label, ImGuiTabItemFlags flags)
		{
			fixed (byte* plabel = label)
			{
				byte ret = TabItemButtonNative((byte*)plabel, flags);
				return ret != 0;
			}
		}

		/// <summary>
		/// create a Tab behaving like a button. return true when clicked. cannot be selected in the tab bar.<br/>
		/// </summary>
		public static bool TabItemButton(ReadOnlySpan<byte> label)
		{
			fixed (byte* plabel = label)
			{
				byte ret = TabItemButtonNative((byte*)plabel, (ImGuiTabItemFlags)(0));
				return ret != 0;
			}
		}

		/// <summary>
		/// create a Tab behaving like a button. return true when clicked. cannot be selected in the tab bar.<br/>
		/// </summary>
		public static bool TabItemButton(string label, ImGuiTabItemFlags flags)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = TabItemButtonNative(pStr0, flags);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		/// <summary>
		/// create a Tab behaving like a button. return true when clicked. cannot be selected in the tab bar.<br/>
		/// </summary>
		public static bool TabItemButton(string label)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = TabItemButtonNative(pStr0, (ImGuiTabItemFlags)(0));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		/// <summary>
		/// notify TabBar or Docking system of a closed tabwindow ahead (useful to reduce visual flicker on reorderable tab bars). For tab-bar: call after BeginTabBar() and before Tab submissions. Otherwise call with a window name.<br/>
		/// </summary>
		internal static void SetTabItemClosedNative(byte* tabOrDockedWindowLabel)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<byte*, void>)vt[300])(tabOrDockedWindowLabel);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)vt[300])((nint)tabOrDockedWindowLabel);
			#endif
		}

		/// <summary>
		/// notify TabBar or Docking system of a closed tabwindow ahead (useful to reduce visual flicker on reorderable tab bars). For tab-bar: call after BeginTabBar() and before Tab submissions. Otherwise call with a window name.<br/>
		/// </summary>
		public static void SetTabItemClosed(byte* tabOrDockedWindowLabel)
		{
			SetTabItemClosedNative(tabOrDockedWindowLabel);
		}

		/// <summary>
		/// notify TabBar or Docking system of a closed tabwindow ahead (useful to reduce visual flicker on reorderable tab bars). For tab-bar: call after BeginTabBar() and before Tab submissions. Otherwise call with a window name.<br/>
		/// </summary>
		public static void SetTabItemClosed(ref byte tabOrDockedWindowLabel)
		{
			fixed (byte* ptabOrDockedWindowLabel = &tabOrDockedWindowLabel)
			{
				SetTabItemClosedNative((byte*)ptabOrDockedWindowLabel);
			}
		}

		/// <summary>
		/// notify TabBar or Docking system of a closed tabwindow ahead (useful to reduce visual flicker on reorderable tab bars). For tab-bar: call after BeginTabBar() and before Tab submissions. Otherwise call with a window name.<br/>
		/// </summary>
		public static void SetTabItemClosed(ReadOnlySpan<byte> tabOrDockedWindowLabel)
		{
			fixed (byte* ptabOrDockedWindowLabel = tabOrDockedWindowLabel)
			{
				SetTabItemClosedNative((byte*)ptabOrDockedWindowLabel);
			}
		}

		/// <summary>
		/// notify TabBar or Docking system of a closed tabwindow ahead (useful to reduce visual flicker on reorderable tab bars). For tab-bar: call after BeginTabBar() and before Tab submissions. Otherwise call with a window name.<br/>
		/// </summary>
		public static void SetTabItemClosed(string tabOrDockedWindowLabel)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (tabOrDockedWindowLabel != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(tabOrDockedWindowLabel);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(tabOrDockedWindowLabel, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			SetTabItemClosedNative(pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		internal static uint DockSpaceNative(uint dockspaceId, Vector2 size, ImGuiDockNodeFlags flags, ImGuiWindowClass* windowClass)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<uint, Vector2, ImGuiDockNodeFlags, ImGuiWindowClass*, uint>)vt[301])(dockspaceId, size, flags, windowClass);
			#else
			return (uint)((delegate* unmanaged[Cdecl]<uint, Vector2, ImGuiDockNodeFlags, nint, uint>)vt[301])(dockspaceId, size, flags, (nint)windowClass);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static uint DockSpace(uint dockspaceId, Vector2 size, ImGuiDockNodeFlags flags, ImGuiWindowClassPtr windowClass)
		{
			uint ret = DockSpaceNative(dockspaceId, size, flags, windowClass);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static uint DockSpace(uint dockspaceId, Vector2 size, ImGuiDockNodeFlags flags)
		{
			uint ret = DockSpaceNative(dockspaceId, size, flags, (ImGuiWindowClass*)(default));
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static uint DockSpace(uint dockspaceId, Vector2 size)
		{
			uint ret = DockSpaceNative(dockspaceId, size, (ImGuiDockNodeFlags)(0), (ImGuiWindowClass*)(default));
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static uint DockSpace(uint dockspaceId)
		{
			uint ret = DockSpaceNative(dockspaceId, (Vector2)(new Vector2(0,0)), (ImGuiDockNodeFlags)(0), (ImGuiWindowClass*)(default));
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static uint DockSpace(uint dockspaceId, ImGuiDockNodeFlags flags)
		{
			uint ret = DockSpaceNative(dockspaceId, (Vector2)(new Vector2(0,0)), flags, (ImGuiWindowClass*)(default));
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static uint DockSpace(uint dockspaceId, Vector2 size, ImGuiWindowClassPtr windowClass)
		{
			uint ret = DockSpaceNative(dockspaceId, size, (ImGuiDockNodeFlags)(0), windowClass);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static uint DockSpace(uint dockspaceId, ImGuiWindowClassPtr windowClass)
		{
			uint ret = DockSpaceNative(dockspaceId, (Vector2)(new Vector2(0,0)), (ImGuiDockNodeFlags)(0), windowClass);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static uint DockSpace(uint dockspaceId, ImGuiDockNodeFlags flags, ImGuiWindowClassPtr windowClass)
		{
			uint ret = DockSpaceNative(dockspaceId, (Vector2)(new Vector2(0,0)), flags, windowClass);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static uint DockSpace(uint dockspaceId, Vector2 size, ImGuiDockNodeFlags flags, ref ImGuiWindowClass windowClass)
		{
			fixed (ImGuiWindowClass* pwindowClass = &windowClass)
			{
				uint ret = DockSpaceNative(dockspaceId, size, flags, (ImGuiWindowClass*)pwindowClass);
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static uint DockSpace(uint dockspaceId, Vector2 size, ref ImGuiWindowClass windowClass)
		{
			fixed (ImGuiWindowClass* pwindowClass = &windowClass)
			{
				uint ret = DockSpaceNative(dockspaceId, size, (ImGuiDockNodeFlags)(0), (ImGuiWindowClass*)pwindowClass);
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static uint DockSpace(uint dockspaceId, ref ImGuiWindowClass windowClass)
		{
			fixed (ImGuiWindowClass* pwindowClass = &windowClass)
			{
				uint ret = DockSpaceNative(dockspaceId, (Vector2)(new Vector2(0,0)), (ImGuiDockNodeFlags)(0), (ImGuiWindowClass*)pwindowClass);
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static uint DockSpace(uint dockspaceId, ImGuiDockNodeFlags flags, ref ImGuiWindowClass windowClass)
		{
			fixed (ImGuiWindowClass* pwindowClass = &windowClass)
			{
				uint ret = DockSpaceNative(dockspaceId, (Vector2)(new Vector2(0,0)), flags, (ImGuiWindowClass*)pwindowClass);
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		internal static uint DockSpaceOverViewportNative(uint dockspaceId, ImGuiViewport* viewport, ImGuiDockNodeFlags flags, ImGuiWindowClass* windowClass)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<uint, ImGuiViewport*, ImGuiDockNodeFlags, ImGuiWindowClass*, uint>)vt[302])(dockspaceId, viewport, flags, windowClass);
			#else
			return (uint)((delegate* unmanaged[Cdecl]<uint, nint, ImGuiDockNodeFlags, nint, uint>)vt[302])(dockspaceId, (nint)viewport, flags, (nint)windowClass);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static uint DockSpaceOverViewport(uint dockspaceId, ImGuiViewportPtr viewport, ImGuiDockNodeFlags flags, ImGuiWindowClassPtr windowClass)
		{
			uint ret = DockSpaceOverViewportNative(dockspaceId, viewport, flags, windowClass);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static uint DockSpaceOverViewport(uint dockspaceId, ImGuiViewportPtr viewport, ImGuiDockNodeFlags flags)
		{
			uint ret = DockSpaceOverViewportNative(dockspaceId, viewport, flags, (ImGuiWindowClass*)(default));
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static uint DockSpaceOverViewport(uint dockspaceId, ImGuiViewportPtr viewport)
		{
			uint ret = DockSpaceOverViewportNative(dockspaceId, viewport, (ImGuiDockNodeFlags)(0), (ImGuiWindowClass*)(default));
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static uint DockSpaceOverViewport(uint dockspaceId)
		{
			uint ret = DockSpaceOverViewportNative(dockspaceId, (ImGuiViewport*)(default), (ImGuiDockNodeFlags)(0), (ImGuiWindowClass*)(default));
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static uint DockSpaceOverViewport()
		{
			uint ret = DockSpaceOverViewportNative((uint)(0), (ImGuiViewport*)(default), (ImGuiDockNodeFlags)(0), (ImGuiWindowClass*)(default));
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static uint DockSpaceOverViewport(ImGuiViewportPtr viewport)
		{
			uint ret = DockSpaceOverViewportNative((uint)(0), viewport, (ImGuiDockNodeFlags)(0), (ImGuiWindowClass*)(default));
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static uint DockSpaceOverViewport(uint dockspaceId, ImGuiDockNodeFlags flags)
		{
			uint ret = DockSpaceOverViewportNative(dockspaceId, (ImGuiViewport*)(default), flags, (ImGuiWindowClass*)(default));
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static uint DockSpaceOverViewport(ImGuiDockNodeFlags flags)
		{
			uint ret = DockSpaceOverViewportNative((uint)(0), (ImGuiViewport*)(default), flags, (ImGuiWindowClass*)(default));
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static uint DockSpaceOverViewport(ImGuiViewportPtr viewport, ImGuiDockNodeFlags flags)
		{
			uint ret = DockSpaceOverViewportNative((uint)(0), viewport, flags, (ImGuiWindowClass*)(default));
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static uint DockSpaceOverViewport(uint dockspaceId, ImGuiViewportPtr viewport, ImGuiWindowClassPtr windowClass)
		{
			uint ret = DockSpaceOverViewportNative(dockspaceId, viewport, (ImGuiDockNodeFlags)(0), windowClass);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static uint DockSpaceOverViewport(uint dockspaceId, ImGuiWindowClassPtr windowClass)
		{
			uint ret = DockSpaceOverViewportNative(dockspaceId, (ImGuiViewport*)(default), (ImGuiDockNodeFlags)(0), windowClass);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static uint DockSpaceOverViewport(ImGuiWindowClassPtr windowClass)
		{
			uint ret = DockSpaceOverViewportNative((uint)(0), (ImGuiViewport*)(default), (ImGuiDockNodeFlags)(0), windowClass);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static uint DockSpaceOverViewport(ImGuiViewportPtr viewport, ImGuiWindowClassPtr windowClass)
		{
			uint ret = DockSpaceOverViewportNative((uint)(0), viewport, (ImGuiDockNodeFlags)(0), windowClass);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static uint DockSpaceOverViewport(uint dockspaceId, ImGuiDockNodeFlags flags, ImGuiWindowClassPtr windowClass)
		{
			uint ret = DockSpaceOverViewportNative(dockspaceId, (ImGuiViewport*)(default), flags, windowClass);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static uint DockSpaceOverViewport(ImGuiDockNodeFlags flags, ImGuiWindowClassPtr windowClass)
		{
			uint ret = DockSpaceOverViewportNative((uint)(0), (ImGuiViewport*)(default), flags, windowClass);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static uint DockSpaceOverViewport(ImGuiViewportPtr viewport, ImGuiDockNodeFlags flags, ImGuiWindowClassPtr windowClass)
		{
			uint ret = DockSpaceOverViewportNative((uint)(0), viewport, flags, windowClass);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static uint DockSpaceOverViewport(uint dockspaceId, ref ImGuiViewport viewport, ImGuiDockNodeFlags flags, ImGuiWindowClassPtr windowClass)
		{
			fixed (ImGuiViewport* pviewport = &viewport)
			{
				uint ret = DockSpaceOverViewportNative(dockspaceId, (ImGuiViewport*)pviewport, flags, windowClass);
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static uint DockSpaceOverViewport(uint dockspaceId, ref ImGuiViewport viewport, ImGuiDockNodeFlags flags)
		{
			fixed (ImGuiViewport* pviewport = &viewport)
			{
				uint ret = DockSpaceOverViewportNative(dockspaceId, (ImGuiViewport*)pviewport, flags, (ImGuiWindowClass*)(default));
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static uint DockSpaceOverViewport(uint dockspaceId, ref ImGuiViewport viewport)
		{
			fixed (ImGuiViewport* pviewport = &viewport)
			{
				uint ret = DockSpaceOverViewportNative(dockspaceId, (ImGuiViewport*)pviewport, (ImGuiDockNodeFlags)(0), (ImGuiWindowClass*)(default));
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static uint DockSpaceOverViewport(ref ImGuiViewport viewport)
		{
			fixed (ImGuiViewport* pviewport = &viewport)
			{
				uint ret = DockSpaceOverViewportNative((uint)(0), (ImGuiViewport*)pviewport, (ImGuiDockNodeFlags)(0), (ImGuiWindowClass*)(default));
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static uint DockSpaceOverViewport(ref ImGuiViewport viewport, ImGuiDockNodeFlags flags)
		{
			fixed (ImGuiViewport* pviewport = &viewport)
			{
				uint ret = DockSpaceOverViewportNative((uint)(0), (ImGuiViewport*)pviewport, flags, (ImGuiWindowClass*)(default));
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static uint DockSpaceOverViewport(uint dockspaceId, ref ImGuiViewport viewport, ImGuiWindowClassPtr windowClass)
		{
			fixed (ImGuiViewport* pviewport = &viewport)
			{
				uint ret = DockSpaceOverViewportNative(dockspaceId, (ImGuiViewport*)pviewport, (ImGuiDockNodeFlags)(0), windowClass);
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static uint DockSpaceOverViewport(ref ImGuiViewport viewport, ImGuiWindowClassPtr windowClass)
		{
			fixed (ImGuiViewport* pviewport = &viewport)
			{
				uint ret = DockSpaceOverViewportNative((uint)(0), (ImGuiViewport*)pviewport, (ImGuiDockNodeFlags)(0), windowClass);
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static uint DockSpaceOverViewport(ref ImGuiViewport viewport, ImGuiDockNodeFlags flags, ImGuiWindowClassPtr windowClass)
		{
			fixed (ImGuiViewport* pviewport = &viewport)
			{
				uint ret = DockSpaceOverViewportNative((uint)(0), (ImGuiViewport*)pviewport, flags, windowClass);
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static uint DockSpaceOverViewport(uint dockspaceId, ImGuiViewportPtr viewport, ImGuiDockNodeFlags flags, ref ImGuiWindowClass windowClass)
		{
			fixed (ImGuiWindowClass* pwindowClass = &windowClass)
			{
				uint ret = DockSpaceOverViewportNative(dockspaceId, viewport, flags, (ImGuiWindowClass*)pwindowClass);
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static uint DockSpaceOverViewport(uint dockspaceId, ImGuiViewportPtr viewport, ref ImGuiWindowClass windowClass)
		{
			fixed (ImGuiWindowClass* pwindowClass = &windowClass)
			{
				uint ret = DockSpaceOverViewportNative(dockspaceId, viewport, (ImGuiDockNodeFlags)(0), (ImGuiWindowClass*)pwindowClass);
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static uint DockSpaceOverViewport(uint dockspaceId, ref ImGuiWindowClass windowClass)
		{
			fixed (ImGuiWindowClass* pwindowClass = &windowClass)
			{
				uint ret = DockSpaceOverViewportNative(dockspaceId, (ImGuiViewport*)(default), (ImGuiDockNodeFlags)(0), (ImGuiWindowClass*)pwindowClass);
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static uint DockSpaceOverViewport(ref ImGuiWindowClass windowClass)
		{
			fixed (ImGuiWindowClass* pwindowClass = &windowClass)
			{
				uint ret = DockSpaceOverViewportNative((uint)(0), (ImGuiViewport*)(default), (ImGuiDockNodeFlags)(0), (ImGuiWindowClass*)pwindowClass);
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static uint DockSpaceOverViewport(ImGuiViewportPtr viewport, ref ImGuiWindowClass windowClass)
		{
			fixed (ImGuiWindowClass* pwindowClass = &windowClass)
			{
				uint ret = DockSpaceOverViewportNative((uint)(0), viewport, (ImGuiDockNodeFlags)(0), (ImGuiWindowClass*)pwindowClass);
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static uint DockSpaceOverViewport(uint dockspaceId, ImGuiDockNodeFlags flags, ref ImGuiWindowClass windowClass)
		{
			fixed (ImGuiWindowClass* pwindowClass = &windowClass)
			{
				uint ret = DockSpaceOverViewportNative(dockspaceId, (ImGuiViewport*)(default), flags, (ImGuiWindowClass*)pwindowClass);
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static uint DockSpaceOverViewport(ImGuiDockNodeFlags flags, ref ImGuiWindowClass windowClass)
		{
			fixed (ImGuiWindowClass* pwindowClass = &windowClass)
			{
				uint ret = DockSpaceOverViewportNative((uint)(0), (ImGuiViewport*)(default), flags, (ImGuiWindowClass*)pwindowClass);
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static uint DockSpaceOverViewport(ImGuiViewportPtr viewport, ImGuiDockNodeFlags flags, ref ImGuiWindowClass windowClass)
		{
			fixed (ImGuiWindowClass* pwindowClass = &windowClass)
			{
				uint ret = DockSpaceOverViewportNative((uint)(0), viewport, flags, (ImGuiWindowClass*)pwindowClass);
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static uint DockSpaceOverViewport(uint dockspaceId, ref ImGuiViewport viewport, ImGuiDockNodeFlags flags, ref ImGuiWindowClass windowClass)
		{
			fixed (ImGuiViewport* pviewport = &viewport)
			{
				fixed (ImGuiWindowClass* pwindowClass = &windowClass)
				{
					uint ret = DockSpaceOverViewportNative(dockspaceId, (ImGuiViewport*)pviewport, flags, (ImGuiWindowClass*)pwindowClass);
					return ret;
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static uint DockSpaceOverViewport(uint dockspaceId, ref ImGuiViewport viewport, ref ImGuiWindowClass windowClass)
		{
			fixed (ImGuiViewport* pviewport = &viewport)
			{
				fixed (ImGuiWindowClass* pwindowClass = &windowClass)
				{
					uint ret = DockSpaceOverViewportNative(dockspaceId, (ImGuiViewport*)pviewport, (ImGuiDockNodeFlags)(0), (ImGuiWindowClass*)pwindowClass);
					return ret;
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static uint DockSpaceOverViewport(ref ImGuiViewport viewport, ref ImGuiWindowClass windowClass)
		{
			fixed (ImGuiViewport* pviewport = &viewport)
			{
				fixed (ImGuiWindowClass* pwindowClass = &windowClass)
				{
					uint ret = DockSpaceOverViewportNative((uint)(0), (ImGuiViewport*)pviewport, (ImGuiDockNodeFlags)(0), (ImGuiWindowClass*)pwindowClass);
					return ret;
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static uint DockSpaceOverViewport(ref ImGuiViewport viewport, ImGuiDockNodeFlags flags, ref ImGuiWindowClass windowClass)
		{
			fixed (ImGuiViewport* pviewport = &viewport)
			{
				fixed (ImGuiWindowClass* pwindowClass = &windowClass)
				{
					uint ret = DockSpaceOverViewportNative((uint)(0), (ImGuiViewport*)pviewport, flags, (ImGuiWindowClass*)pwindowClass);
					return ret;
				}
			}
		}

		/// <summary>
		/// set next window dock id<br/>
		/// </summary>
		internal static void SetNextWindowDockIDNative(uint dockId, ImGuiCond cond)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, ImGuiCond, void>)vt[303])(dockId, cond);
			#else
			((delegate* unmanaged[Cdecl]<uint, ImGuiCond, void>)vt[303])(dockId, cond);
			#endif
		}

		/// <summary>
		/// set next window dock id<br/>
		/// </summary>
		public static void SetNextWindowDockID(uint dockId, ImGuiCond cond)
		{
			SetNextWindowDockIDNative(dockId, cond);
		}

		/// <summary>
		/// set next window dock id<br/>
		/// </summary>
		public static void SetNextWindowDockID(uint dockId)
		{
			SetNextWindowDockIDNative(dockId, (ImGuiCond)(0));
		}

		/// <summary>
		/// set next window class (control docking compatibility + provide hints to platform backend via custom viewport flags and platform parentchild relationship)<br/>
		/// </summary>
		internal static void SetNextWindowClassNative(ImGuiWindowClass* windowClass)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<ImGuiWindowClass*, void>)vt[304])(windowClass);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)vt[304])((nint)windowClass);
			#endif
		}

		/// <summary>
		/// set next window class (control docking compatibility + provide hints to platform backend via custom viewport flags and platform parentchild relationship)<br/>
		/// </summary>
		public static void SetNextWindowClass(ImGuiWindowClassPtr windowClass)
		{
			SetNextWindowClassNative(windowClass);
		}

		/// <summary>
		/// set next window class (control docking compatibility + provide hints to platform backend via custom viewport flags and platform parentchild relationship)<br/>
		/// </summary>
		public static void SetNextWindowClass(ref ImGuiWindowClass windowClass)
		{
			fixed (ImGuiWindowClass* pwindowClass = &windowClass)
			{
				SetNextWindowClassNative((ImGuiWindowClass*)pwindowClass);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		internal static uint GetWindowDockIDNative()
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<uint>)vt[305])();
			#else
			return (uint)((delegate* unmanaged[Cdecl]<uint>)vt[305])();
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static uint GetWindowDockID()
		{
			uint ret = GetWindowDockIDNative();
			return ret;
		}

		/// <summary>
		/// is current window docked into another window?<br/>
		/// </summary>
		internal static byte IsWindowDockedNative()
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<byte>)vt[306])();
			#else
			return (byte)((delegate* unmanaged[Cdecl]<byte>)vt[306])();
			#endif
		}

		/// <summary>
		/// is current window docked into another window?<br/>
		/// </summary>
		public static bool IsWindowDocked()
		{
			byte ret = IsWindowDockedNative();
			return ret != 0;
		}

		/// <summary>
		/// start logging to tty (stdout)<br/>
		/// </summary>
		internal static void LogToTTYNative(int autoOpenDepth)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<int, void>)vt[307])(autoOpenDepth);
			#else
			((delegate* unmanaged[Cdecl]<int, void>)vt[307])(autoOpenDepth);
			#endif
		}

		/// <summary>
		/// start logging to tty (stdout)<br/>
		/// </summary>
		public static void LogToTTY(int autoOpenDepth)
		{
			LogToTTYNative(autoOpenDepth);
		}

		/// <summary>
		/// start logging to tty (stdout)<br/>
		/// </summary>
		public static void LogToTTY()
		{
			LogToTTYNative((int)(-1));
		}

		/// <summary>
		/// start logging to file<br/>
		/// </summary>
		internal static void LogToFileNative(int autoOpenDepth, byte* filename)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<int, byte*, void>)vt[308])(autoOpenDepth, filename);
			#else
			((delegate* unmanaged[Cdecl]<int, nint, void>)vt[308])(autoOpenDepth, (nint)filename);
			#endif
		}

		/// <summary>
		/// start logging to file<br/>
		/// </summary>
		public static void LogToFile(int autoOpenDepth, byte* filename)
		{
			LogToFileNative(autoOpenDepth, filename);
		}

		/// <summary>
		/// start logging to file<br/>
		/// </summary>
		public static void LogToFile(int autoOpenDepth)
		{
			LogToFileNative(autoOpenDepth, (byte*)(default));
		}

		/// <summary>
		/// start logging to file<br/>
		/// </summary>
		public static void LogToFile()
		{
			LogToFileNative((int)(-1), (byte*)(default));
		}

		/// <summary>
		/// start logging to file<br/>
		/// </summary>
		public static void LogToFile(byte* filename)
		{
			LogToFileNative((int)(-1), filename);
		}

		/// <summary>
		/// start logging to file<br/>
		/// </summary>
		public static void LogToFile(int autoOpenDepth, ref byte filename)
		{
			fixed (byte* pfilename = &filename)
			{
				LogToFileNative(autoOpenDepth, (byte*)pfilename);
			}
		}

		/// <summary>
		/// start logging to file<br/>
		/// </summary>
		public static void LogToFile(ref byte filename)
		{
			fixed (byte* pfilename = &filename)
			{
				LogToFileNative((int)(-1), (byte*)pfilename);
			}
		}

		/// <summary>
		/// start logging to file<br/>
		/// </summary>
		public static void LogToFile(int autoOpenDepth, ReadOnlySpan<byte> filename)
		{
			fixed (byte* pfilename = filename)
			{
				LogToFileNative(autoOpenDepth, (byte*)pfilename);
			}
		}

		/// <summary>
		/// start logging to file<br/>
		/// </summary>
		public static void LogToFile(ReadOnlySpan<byte> filename)
		{
			fixed (byte* pfilename = filename)
			{
				LogToFileNative((int)(-1), (byte*)pfilename);
			}
		}

		/// <summary>
		/// start logging to file<br/>
		/// </summary>
		public static void LogToFile(int autoOpenDepth, string filename)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (filename != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(filename);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(filename, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			LogToFileNative(autoOpenDepth, pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		/// <summary>
		/// start logging to file<br/>
		/// </summary>
		public static void LogToFile(string filename)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (filename != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(filename);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(filename, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			LogToFileNative((int)(-1), pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		/// <summary>
		/// start logging to OS clipboard<br/>
		/// </summary>
		internal static void LogToClipboardNative(int autoOpenDepth)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<int, void>)vt[309])(autoOpenDepth);
			#else
			((delegate* unmanaged[Cdecl]<int, void>)vt[309])(autoOpenDepth);
			#endif
		}

		/// <summary>
		/// start logging to OS clipboard<br/>
		/// </summary>
		public static void LogToClipboard(int autoOpenDepth)
		{
			LogToClipboardNative(autoOpenDepth);
		}

		/// <summary>
		/// start logging to OS clipboard<br/>
		/// </summary>
		public static void LogToClipboard()
		{
			LogToClipboardNative((int)(-1));
		}

		/// <summary>
		/// stop logging (close file, etc.)<br/>
		/// </summary>
		internal static void LogFinishNative()
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<void>)vt[310])();
			#else
			((delegate* unmanaged[Cdecl]<void>)vt[310])();
			#endif
		}

		/// <summary>
		/// stop logging (close file, etc.)<br/>
		/// </summary>
		public static void LogFinish()
		{
			LogFinishNative();
		}

		/// <summary>
		/// helper to display buttons for logging to ttyfileclipboard<br/>
		/// </summary>
		internal static void LogButtonsNative()
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<void>)vt[311])();
			#else
			((delegate* unmanaged[Cdecl]<void>)vt[311])();
			#endif
		}

		/// <summary>
		/// helper to display buttons for logging to ttyfileclipboard<br/>
		/// </summary>
		public static void LogButtons()
		{
			LogButtonsNative();
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		internal static void LogTextVNative(byte* fmt, nuint args)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<byte*, nuint, void>)vt[312])(fmt, args);
			#else
			((delegate* unmanaged[Cdecl]<nint, nuint, void>)vt[312])((nint)fmt, args);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void LogTextV(byte* fmt, nuint args)
		{
			LogTextVNative(fmt, args);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void LogTextV(ref byte fmt, nuint args)
		{
			fixed (byte* pfmt = &fmt)
			{
				LogTextVNative((byte*)pfmt, args);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void LogTextV(ReadOnlySpan<byte> fmt, nuint args)
		{
			fixed (byte* pfmt = fmt)
			{
				LogTextVNative((byte*)pfmt, args);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void LogTextV(string fmt, nuint args)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (fmt != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(fmt);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(fmt, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			LogTextVNative(pStr0, args);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		/// <summary>
		/// call after submitting an item which may be dragged. when this return true, you can call SetDragDropPayload() + EndDragDropSource()<br/>
		/// </summary>
		internal static byte BeginDragDropSourceNative(ImGuiDragDropFlags flags)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<ImGuiDragDropFlags, byte>)vt[313])(flags);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<ImGuiDragDropFlags, byte>)vt[313])(flags);
			#endif
		}

		/// <summary>
		/// call after submitting an item which may be dragged. when this return true, you can call SetDragDropPayload() + EndDragDropSource()<br/>
		/// </summary>
		public static bool BeginDragDropSource(ImGuiDragDropFlags flags)
		{
			byte ret = BeginDragDropSourceNative(flags);
			return ret != 0;
		}

		/// <summary>
		/// call after submitting an item which may be dragged. when this return true, you can call SetDragDropPayload() + EndDragDropSource()<br/>
		/// </summary>
		public static bool BeginDragDropSource()
		{
			byte ret = BeginDragDropSourceNative((ImGuiDragDropFlags)(0));
			return ret != 0;
		}

		/// <summary>
		/// type is a user defined string of maximum 32 characters. Strings starting with '_' are reserved for dear imgui internal types. Data is copied and held by imgui. Return true when payload has been accepted.<br/>
		/// </summary>
		internal static byte SetDragDropPayloadNative(byte* type, void* data, ulong sz, ImGuiCond cond)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<byte*, void*, ulong, ImGuiCond, byte>)vt[314])(type, data, sz, cond);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<nint, nint, ulong, ImGuiCond, byte>)vt[314])((nint)type, (nint)data, sz, cond);
			#endif
		}

		/// <summary>
		/// type is a user defined string of maximum 32 characters. Strings starting with '_' are reserved for dear imgui internal types. Data is copied and held by imgui. Return true when payload has been accepted.<br/>
		/// </summary>
		public static bool SetDragDropPayload(byte* type, void* data, ulong sz, ImGuiCond cond)
		{
			byte ret = SetDragDropPayloadNative(type, data, sz, cond);
			return ret != 0;
		}

		/// <summary>
		/// type is a user defined string of maximum 32 characters. Strings starting with '_' are reserved for dear imgui internal types. Data is copied and held by imgui. Return true when payload has been accepted.<br/>
		/// </summary>
		public static bool SetDragDropPayload(byte* type, void* data, ulong sz)
		{
			byte ret = SetDragDropPayloadNative(type, data, sz, (ImGuiCond)(0));
			return ret != 0;
		}

		/// <summary>
		/// type is a user defined string of maximum 32 characters. Strings starting with '_' are reserved for dear imgui internal types. Data is copied and held by imgui. Return true when payload has been accepted.<br/>
		/// </summary>
		public static bool SetDragDropPayload(ref byte type, void* data, ulong sz, ImGuiCond cond)
		{
			fixed (byte* ptype = &type)
			{
				byte ret = SetDragDropPayloadNative((byte*)ptype, data, sz, cond);
				return ret != 0;
			}
		}

		/// <summary>
		/// type is a user defined string of maximum 32 characters. Strings starting with '_' are reserved for dear imgui internal types. Data is copied and held by imgui. Return true when payload has been accepted.<br/>
		/// </summary>
		public static bool SetDragDropPayload(ref byte type, void* data, ulong sz)
		{
			fixed (byte* ptype = &type)
			{
				byte ret = SetDragDropPayloadNative((byte*)ptype, data, sz, (ImGuiCond)(0));
				return ret != 0;
			}
		}

		/// <summary>
		/// type is a user defined string of maximum 32 characters. Strings starting with '_' are reserved for dear imgui internal types. Data is copied and held by imgui. Return true when payload has been accepted.<br/>
		/// </summary>
		public static bool SetDragDropPayload(ReadOnlySpan<byte> type, void* data, ulong sz, ImGuiCond cond)
		{
			fixed (byte* ptype = type)
			{
				byte ret = SetDragDropPayloadNative((byte*)ptype, data, sz, cond);
				return ret != 0;
			}
		}

		/// <summary>
		/// type is a user defined string of maximum 32 characters. Strings starting with '_' are reserved for dear imgui internal types. Data is copied and held by imgui. Return true when payload has been accepted.<br/>
		/// </summary>
		public static bool SetDragDropPayload(ReadOnlySpan<byte> type, void* data, ulong sz)
		{
			fixed (byte* ptype = type)
			{
				byte ret = SetDragDropPayloadNative((byte*)ptype, data, sz, (ImGuiCond)(0));
				return ret != 0;
			}
		}

		/// <summary>
		/// type is a user defined string of maximum 32 characters. Strings starting with '_' are reserved for dear imgui internal types. Data is copied and held by imgui. Return true when payload has been accepted.<br/>
		/// </summary>
		public static bool SetDragDropPayload(string type, void* data, ulong sz, ImGuiCond cond)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (type != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(type);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(type, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = SetDragDropPayloadNative(pStr0, data, sz, cond);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		/// <summary>
		/// type is a user defined string of maximum 32 characters. Strings starting with '_' are reserved for dear imgui internal types. Data is copied and held by imgui. Return true when payload has been accepted.<br/>
		/// </summary>
		public static bool SetDragDropPayload(string type, void* data, ulong sz)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (type != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(type);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(type, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = SetDragDropPayloadNative(pStr0, data, sz, (ImGuiCond)(0));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		/// <summary>
		/// type is a user defined string of maximum 32 characters. Strings starting with '_' are reserved for dear imgui internal types. Data is copied and held by imgui. Return true when payload has been accepted.<br/>
		/// </summary>
		public static bool SetDragDropPayload(byte* type, void* data, nuint sz, ImGuiCond cond)
		{
			byte ret = SetDragDropPayloadNative(type, data, sz, cond);
			return ret != 0;
		}

		/// <summary>
		/// type is a user defined string of maximum 32 characters. Strings starting with '_' are reserved for dear imgui internal types. Data is copied and held by imgui. Return true when payload has been accepted.<br/>
		/// </summary>
		public static bool SetDragDropPayload(byte* type, void* data, nuint sz)
		{
			byte ret = SetDragDropPayloadNative(type, data, sz, (ImGuiCond)(0));
			return ret != 0;
		}

		/// <summary>
		/// type is a user defined string of maximum 32 characters. Strings starting with '_' are reserved for dear imgui internal types. Data is copied and held by imgui. Return true when payload has been accepted.<br/>
		/// </summary>
		public static bool SetDragDropPayload(ref byte type, void* data, nuint sz, ImGuiCond cond)
		{
			fixed (byte* ptype = &type)
			{
				byte ret = SetDragDropPayloadNative((byte*)ptype, data, sz, cond);
				return ret != 0;
			}
		}

		/// <summary>
		/// type is a user defined string of maximum 32 characters. Strings starting with '_' are reserved for dear imgui internal types. Data is copied and held by imgui. Return true when payload has been accepted.<br/>
		/// </summary>
		public static bool SetDragDropPayload(ref byte type, void* data, nuint sz)
		{
			fixed (byte* ptype = &type)
			{
				byte ret = SetDragDropPayloadNative((byte*)ptype, data, sz, (ImGuiCond)(0));
				return ret != 0;
			}
		}

		/// <summary>
		/// type is a user defined string of maximum 32 characters. Strings starting with '_' are reserved for dear imgui internal types. Data is copied and held by imgui. Return true when payload has been accepted.<br/>
		/// </summary>
		public static bool SetDragDropPayload(ReadOnlySpan<byte> type, void* data, nuint sz, ImGuiCond cond)
		{
			fixed (byte* ptype = type)
			{
				byte ret = SetDragDropPayloadNative((byte*)ptype, data, sz, cond);
				return ret != 0;
			}
		}

		/// <summary>
		/// type is a user defined string of maximum 32 characters. Strings starting with '_' are reserved for dear imgui internal types. Data is copied and held by imgui. Return true when payload has been accepted.<br/>
		/// </summary>
		public static bool SetDragDropPayload(ReadOnlySpan<byte> type, void* data, nuint sz)
		{
			fixed (byte* ptype = type)
			{
				byte ret = SetDragDropPayloadNative((byte*)ptype, data, sz, (ImGuiCond)(0));
				return ret != 0;
			}
		}

		/// <summary>
		/// type is a user defined string of maximum 32 characters. Strings starting with '_' are reserved for dear imgui internal types. Data is copied and held by imgui. Return true when payload has been accepted.<br/>
		/// </summary>
		public static bool SetDragDropPayload(string type, void* data, nuint sz, ImGuiCond cond)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (type != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(type);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(type, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = SetDragDropPayloadNative(pStr0, data, sz, cond);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		/// <summary>
		/// type is a user defined string of maximum 32 characters. Strings starting with '_' are reserved for dear imgui internal types. Data is copied and held by imgui. Return true when payload has been accepted.<br/>
		/// </summary>
		public static bool SetDragDropPayload(string type, void* data, nuint sz)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (type != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(type);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(type, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = SetDragDropPayloadNative(pStr0, data, sz, (ImGuiCond)(0));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		/// <summary>
		/// only call EndDragDropSource() if BeginDragDropSource() returns true!<br/>
		/// </summary>
		internal static void EndDragDropSourceNative()
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<void>)vt[315])();
			#else
			((delegate* unmanaged[Cdecl]<void>)vt[315])();
			#endif
		}

		/// <summary>
		/// only call EndDragDropSource() if BeginDragDropSource() returns true!<br/>
		/// </summary>
		public static void EndDragDropSource()
		{
			EndDragDropSourceNative();
		}

		/// <summary>
		/// call after submitting an item that may receive a payload. If this returns true, you can call AcceptDragDropPayload() + EndDragDropTarget()<br/>
		/// </summary>
		internal static byte BeginDragDropTargetNative()
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<byte>)vt[316])();
			#else
			return (byte)((delegate* unmanaged[Cdecl]<byte>)vt[316])();
			#endif
		}

		/// <summary>
		/// call after submitting an item that may receive a payload. If this returns true, you can call AcceptDragDropPayload() + EndDragDropTarget()<br/>
		/// </summary>
		public static bool BeginDragDropTarget()
		{
			byte ret = BeginDragDropTargetNative();
			return ret != 0;
		}

		/// <summary>
		/// accept contents of a given type. If ImGuiDragDropFlags_AcceptBeforeDelivery is set you can peek into the payload before the mouse button is released.<br/>
		/// </summary>
		internal static ImGuiPayload* AcceptDragDropPayloadNative(byte* type, ImGuiDragDropFlags flags)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<byte*, ImGuiDragDropFlags, ImGuiPayload*>)vt[317])(type, flags);
			#else
			return (ImGuiPayload*)((delegate* unmanaged[Cdecl]<nint, ImGuiDragDropFlags, nint>)vt[317])((nint)type, flags);
			#endif
		}

		/// <summary>
		/// accept contents of a given type. If ImGuiDragDropFlags_AcceptBeforeDelivery is set you can peek into the payload before the mouse button is released.<br/>
		/// </summary>
		public static ImGuiPayloadPtr AcceptDragDropPayload(byte* type, ImGuiDragDropFlags flags)
		{
			ImGuiPayloadPtr ret = AcceptDragDropPayloadNative(type, flags);
			return ret;
		}

		/// <summary>
		/// accept contents of a given type. If ImGuiDragDropFlags_AcceptBeforeDelivery is set you can peek into the payload before the mouse button is released.<br/>
		/// </summary>
		public static ImGuiPayloadPtr AcceptDragDropPayload(byte* type)
		{
			ImGuiPayloadPtr ret = AcceptDragDropPayloadNative(type, (ImGuiDragDropFlags)(0));
			return ret;
		}

		/// <summary>
		/// accept contents of a given type. If ImGuiDragDropFlags_AcceptBeforeDelivery is set you can peek into the payload before the mouse button is released.<br/>
		/// </summary>
		public static ImGuiPayloadPtr AcceptDragDropPayload(ref byte type, ImGuiDragDropFlags flags)
		{
			fixed (byte* ptype = &type)
			{
				ImGuiPayloadPtr ret = AcceptDragDropPayloadNative((byte*)ptype, flags);
				return ret;
			}
		}

		/// <summary>
		/// accept contents of a given type. If ImGuiDragDropFlags_AcceptBeforeDelivery is set you can peek into the payload before the mouse button is released.<br/>
		/// </summary>
		public static ImGuiPayloadPtr AcceptDragDropPayload(ref byte type)
		{
			fixed (byte* ptype = &type)
			{
				ImGuiPayloadPtr ret = AcceptDragDropPayloadNative((byte*)ptype, (ImGuiDragDropFlags)(0));
				return ret;
			}
		}

		/// <summary>
		/// accept contents of a given type. If ImGuiDragDropFlags_AcceptBeforeDelivery is set you can peek into the payload before the mouse button is released.<br/>
		/// </summary>
		public static ImGuiPayloadPtr AcceptDragDropPayload(ReadOnlySpan<byte> type, ImGuiDragDropFlags flags)
		{
			fixed (byte* ptype = type)
			{
				ImGuiPayloadPtr ret = AcceptDragDropPayloadNative((byte*)ptype, flags);
				return ret;
			}
		}

		/// <summary>
		/// accept contents of a given type. If ImGuiDragDropFlags_AcceptBeforeDelivery is set you can peek into the payload before the mouse button is released.<br/>
		/// </summary>
		public static ImGuiPayloadPtr AcceptDragDropPayload(ReadOnlySpan<byte> type)
		{
			fixed (byte* ptype = type)
			{
				ImGuiPayloadPtr ret = AcceptDragDropPayloadNative((byte*)ptype, (ImGuiDragDropFlags)(0));
				return ret;
			}
		}

		/// <summary>
		/// accept contents of a given type. If ImGuiDragDropFlags_AcceptBeforeDelivery is set you can peek into the payload before the mouse button is released.<br/>
		/// </summary>
		public static ImGuiPayloadPtr AcceptDragDropPayload(string type, ImGuiDragDropFlags flags)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (type != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(type);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(type, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			ImGuiPayloadPtr ret = AcceptDragDropPayloadNative(pStr0, flags);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>
		/// accept contents of a given type. If ImGuiDragDropFlags_AcceptBeforeDelivery is set you can peek into the payload before the mouse button is released.<br/>
		/// </summary>
		public static ImGuiPayloadPtr AcceptDragDropPayload(string type)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (type != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(type);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(type, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			ImGuiPayloadPtr ret = AcceptDragDropPayloadNative(pStr0, (ImGuiDragDropFlags)(0));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>
		/// only call EndDragDropTarget() if BeginDragDropTarget() returns true!<br/>
		/// </summary>
		internal static void EndDragDropTargetNative()
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<void>)vt[318])();
			#else
			((delegate* unmanaged[Cdecl]<void>)vt[318])();
			#endif
		}

		/// <summary>
		/// only call EndDragDropTarget() if BeginDragDropTarget() returns true!<br/>
		/// </summary>
		public static void EndDragDropTarget()
		{
			EndDragDropTargetNative();
		}

		/// <summary>
		/// peek directly into the current payload from anywhere. returns NULL when drag and drop is finished or inactive. use ImGuiPayload::IsDataType() to test for the payload type.<br/>
		/// </summary>
		internal static ImGuiPayload* GetDragDropPayloadNative()
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<ImGuiPayload*>)vt[319])();
			#else
			return (ImGuiPayload*)((delegate* unmanaged[Cdecl]<nint>)vt[319])();
			#endif
		}

		/// <summary>
		/// peek directly into the current payload from anywhere. returns NULL when drag and drop is finished or inactive. use ImGuiPayload::IsDataType() to test for the payload type.<br/>
		/// </summary>
		public static ImGuiPayloadPtr GetDragDropPayload()
		{
			ImGuiPayloadPtr ret = GetDragDropPayloadNative();
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		internal static void BeginDisabledNative(byte disabled)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<byte, void>)vt[320])(disabled);
			#else
			((delegate* unmanaged[Cdecl]<byte, void>)vt[320])(disabled);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void BeginDisabled(bool disabled)
		{
			BeginDisabledNative(disabled ? (byte)1 : (byte)0);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void BeginDisabled()
		{
			BeginDisabledNative((byte)(1));
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		internal static void EndDisabledNative()
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<void>)vt[321])();
			#else
			((delegate* unmanaged[Cdecl]<void>)vt[321])();
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void EndDisabled()
		{
			EndDisabledNative();
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		internal static void PushClipRectNative(Vector2 clipRectMin, Vector2 clipRectMax, byte intersectWithCurrentClipRect)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<Vector2, Vector2, byte, void>)vt[322])(clipRectMin, clipRectMax, intersectWithCurrentClipRect);
			#else
			((delegate* unmanaged[Cdecl]<Vector2, Vector2, byte, void>)vt[322])(clipRectMin, clipRectMax, intersectWithCurrentClipRect);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void PushClipRect(Vector2 clipRectMin, Vector2 clipRectMax, bool intersectWithCurrentClipRect)
		{
			PushClipRectNative(clipRectMin, clipRectMax, intersectWithCurrentClipRect ? (byte)1 : (byte)0);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		internal static void PopClipRectNative()
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<void>)vt[323])();
			#else
			((delegate* unmanaged[Cdecl]<void>)vt[323])();
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void PopClipRect()
		{
			PopClipRectNative();
		}

		/// <summary>
		/// make last item the default focused item of a window.<br/>
		/// </summary>
		internal static void SetItemDefaultFocusNative()
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<void>)vt[324])();
			#else
			((delegate* unmanaged[Cdecl]<void>)vt[324])();
			#endif
		}

		/// <summary>
		/// make last item the default focused item of a window.<br/>
		/// </summary>
		public static void SetItemDefaultFocus()
		{
			SetItemDefaultFocusNative();
		}

		/// <summary>
		/// focus keyboard on the next widget. Use positive 'offset' to access sub components of a multiple component widget. Use -1 to access previous widget.<br/>
		/// </summary>
		internal static void SetKeyboardFocusHereNative(int offset)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<int, void>)vt[325])(offset);
			#else
			((delegate* unmanaged[Cdecl]<int, void>)vt[325])(offset);
			#endif
		}

		/// <summary>
		/// focus keyboard on the next widget. Use positive 'offset' to access sub components of a multiple component widget. Use -1 to access previous widget.<br/>
		/// </summary>
		public static void SetKeyboardFocusHere(int offset)
		{
			SetKeyboardFocusHereNative(offset);
		}

		/// <summary>
		/// focus keyboard on the next widget. Use positive 'offset' to access sub components of a multiple component widget. Use -1 to access previous widget.<br/>
		/// </summary>
		public static void SetKeyboardFocusHere()
		{
			SetKeyboardFocusHereNative((int)(0));
		}

		/// <summary>
		/// allow next item to be overlapped by a subsequent item. Useful with invisible buttons, selectable, treenode covering an area where subsequent items may need to be added. Note that both Selectable() and TreeNode() have dedicated flags doing this.<br/>
		/// </summary>
		internal static void SetNextItemAllowOverlapNative()
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<void>)vt[326])();
			#else
			((delegate* unmanaged[Cdecl]<void>)vt[326])();
			#endif
		}

		/// <summary>
		/// allow next item to be overlapped by a subsequent item. Useful with invisible buttons, selectable, treenode covering an area where subsequent items may need to be added. Note that both Selectable() and TreeNode() have dedicated flags doing this.<br/>
		/// </summary>
		public static void SetNextItemAllowOverlap()
		{
			SetNextItemAllowOverlapNative();
		}

		/// <summary>
		/// is the last item hovered? (and usable, aka not blocked by a popup, etc.). See ImGuiHoveredFlags for more options.<br/>
		/// </summary>
		internal static byte IsItemHoveredNative(ImGuiHoveredFlags flags)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<ImGuiHoveredFlags, byte>)vt[327])(flags);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<ImGuiHoveredFlags, byte>)vt[327])(flags);
			#endif
		}

		/// <summary>
		/// is the last item hovered? (and usable, aka not blocked by a popup, etc.). See ImGuiHoveredFlags for more options.<br/>
		/// </summary>
		public static bool IsItemHovered(ImGuiHoveredFlags flags)
		{
			byte ret = IsItemHoveredNative(flags);
			return ret != 0;
		}

		/// <summary>
		/// is the last item hovered? (and usable, aka not blocked by a popup, etc.). See ImGuiHoveredFlags for more options.<br/>
		/// </summary>
		public static bool IsItemHovered()
		{
			byte ret = IsItemHoveredNative((ImGuiHoveredFlags)(0));
			return ret != 0;
		}

		/// <summary>
		/// is the last item active? (e.g. button being held, text field being edited. This will continuously return true while holding mouse button on an item. Items that don't interact will always return false)<br/>
		/// </summary>
		internal static byte IsItemActiveNative()
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<byte>)vt[328])();
			#else
			return (byte)((delegate* unmanaged[Cdecl]<byte>)vt[328])();
			#endif
		}

		/// <summary>
		/// is the last item active? (e.g. button being held, text field being edited. This will continuously return true while holding mouse button on an item. Items that don't interact will always return false)<br/>
		/// </summary>
		public static bool IsItemActive()
		{
			byte ret = IsItemActiveNative();
			return ret != 0;
		}

		/// <summary>
		/// is the last item focused for keyboardgamepad navigation?<br/>
		/// </summary>
		internal static byte IsItemFocusedNative()
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<byte>)vt[329])();
			#else
			return (byte)((delegate* unmanaged[Cdecl]<byte>)vt[329])();
			#endif
		}

		/// <summary>
		/// is the last item focused for keyboardgamepad navigation?<br/>
		/// </summary>
		public static bool IsItemFocused()
		{
			byte ret = IsItemFocusedNative();
			return ret != 0;
		}

		/// <summary>
		/// is the last item hovered and mouse clicked on? (**)  == IsMouseClicked(mouse_button) &amp;&amp; IsItemHovered()Important. (**) this is NOT equivalent to the behavior of e.g. Button(). Read comments in function definition.<br/>
		/// </summary>
		internal static byte IsItemClickedNative(ImGuiMouseButton mouseButton)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<ImGuiMouseButton, byte>)vt[330])(mouseButton);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<ImGuiMouseButton, byte>)vt[330])(mouseButton);
			#endif
		}

		/// <summary>
		/// is the last item hovered and mouse clicked on? (**)  == IsMouseClicked(mouse_button) &amp;&amp; IsItemHovered()Important. (**) this is NOT equivalent to the behavior of e.g. Button(). Read comments in function definition.<br/>
		/// </summary>
		public static bool IsItemClicked(ImGuiMouseButton mouseButton)
		{
			byte ret = IsItemClickedNative(mouseButton);
			return ret != 0;
		}

		/// <summary>
		/// is the last item hovered and mouse clicked on? (**)  == IsMouseClicked(mouse_button) &amp;&amp; IsItemHovered()Important. (**) this is NOT equivalent to the behavior of e.g. Button(). Read comments in function definition.<br/>
		/// </summary>
		public static bool IsItemClicked()
		{
			byte ret = IsItemClickedNative((ImGuiMouseButton)(0));
			return ret != 0;
		}

		/// <summary>
		/// is the last item visible? (items may be out of sight because of clippingscrolling)<br/>
		/// </summary>
		internal static byte IsItemVisibleNative()
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<byte>)vt[331])();
			#else
			return (byte)((delegate* unmanaged[Cdecl]<byte>)vt[331])();
			#endif
		}

		/// <summary>
		/// is the last item visible? (items may be out of sight because of clippingscrolling)<br/>
		/// </summary>
		public static bool IsItemVisible()
		{
			byte ret = IsItemVisibleNative();
			return ret != 0;
		}

		/// <summary>
		/// did the last item modify its underlying value this frame? or was pressed? This is generally the same as the "bool" return value of many widgets.<br/>
		/// </summary>
		internal static byte IsItemEditedNative()
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<byte>)vt[332])();
			#else
			return (byte)((delegate* unmanaged[Cdecl]<byte>)vt[332])();
			#endif
		}

		/// <summary>
		/// did the last item modify its underlying value this frame? or was pressed? This is generally the same as the "bool" return value of many widgets.<br/>
		/// </summary>
		public static bool IsItemEdited()
		{
			byte ret = IsItemEditedNative();
			return ret != 0;
		}

		/// <summary>
		/// was the last item just made active (item was previously inactive).<br/>
		/// </summary>
		internal static byte IsItemActivatedNative()
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<byte>)vt[333])();
			#else
			return (byte)((delegate* unmanaged[Cdecl]<byte>)vt[333])();
			#endif
		}

		/// <summary>
		/// was the last item just made active (item was previously inactive).<br/>
		/// </summary>
		public static bool IsItemActivated()
		{
			byte ret = IsItemActivatedNative();
			return ret != 0;
		}

		/// <summary>
		/// was the last item just made inactive (item was previously active). Useful for UndoRedo patterns with widgets that require continuous editing.<br/>
		/// </summary>
		internal static byte IsItemDeactivatedNative()
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<byte>)vt[334])();
			#else
			return (byte)((delegate* unmanaged[Cdecl]<byte>)vt[334])();
			#endif
		}

		/// <summary>
		/// was the last item just made inactive (item was previously active). Useful for UndoRedo patterns with widgets that require continuous editing.<br/>
		/// </summary>
		public static bool IsItemDeactivated()
		{
			byte ret = IsItemDeactivatedNative();
			return ret != 0;
		}

		/// <summary>
		/// was the last item just made inactive and made a value change when it was active? (e.g. SliderDrag moved). Useful for UndoRedo patterns with widgets that require continuous editing. Note that you may get false positives (some widgets such as Combo()ListBox()Selectable() will return true even when clicking an already selected item).<br/>
		/// </summary>
		internal static byte IsItemDeactivatedAfterEditNative()
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<byte>)vt[335])();
			#else
			return (byte)((delegate* unmanaged[Cdecl]<byte>)vt[335])();
			#endif
		}

		/// <summary>
		/// was the last item just made inactive and made a value change when it was active? (e.g. SliderDrag moved). Useful for UndoRedo patterns with widgets that require continuous editing. Note that you may get false positives (some widgets such as Combo()ListBox()Selectable() will return true even when clicking an already selected item).<br/>
		/// </summary>
		public static bool IsItemDeactivatedAfterEdit()
		{
			byte ret = IsItemDeactivatedAfterEditNative();
			return ret != 0;
		}

		/// <summary>
		/// was the last item open state toggled? set by TreeNode().<br/>
		/// </summary>
		internal static byte IsItemToggledOpenNative()
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<byte>)vt[336])();
			#else
			return (byte)((delegate* unmanaged[Cdecl]<byte>)vt[336])();
			#endif
		}

		/// <summary>
		/// was the last item open state toggled? set by TreeNode().<br/>
		/// </summary>
		public static bool IsItemToggledOpen()
		{
			byte ret = IsItemToggledOpenNative();
			return ret != 0;
		}

		/// <summary>
		/// is any item hovered?<br/>
		/// </summary>
		internal static byte IsAnyItemHoveredNative()
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<byte>)vt[337])();
			#else
			return (byte)((delegate* unmanaged[Cdecl]<byte>)vt[337])();
			#endif
		}

		/// <summary>
		/// is any item hovered?<br/>
		/// </summary>
		public static bool IsAnyItemHovered()
		{
			byte ret = IsAnyItemHoveredNative();
			return ret != 0;
		}

		/// <summary>
		/// is any item active?<br/>
		/// </summary>
		internal static byte IsAnyItemActiveNative()
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<byte>)vt[338])();
			#else
			return (byte)((delegate* unmanaged[Cdecl]<byte>)vt[338])();
			#endif
		}

		/// <summary>
		/// is any item active?<br/>
		/// </summary>
		public static bool IsAnyItemActive()
		{
			byte ret = IsAnyItemActiveNative();
			return ret != 0;
		}

		/// <summary>
		/// is any item focused?<br/>
		/// </summary>
		internal static byte IsAnyItemFocusedNative()
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<byte>)vt[339])();
			#else
			return (byte)((delegate* unmanaged[Cdecl]<byte>)vt[339])();
			#endif
		}

		/// <summary>
		/// is any item focused?<br/>
		/// </summary>
		public static bool IsAnyItemFocused()
		{
			byte ret = IsAnyItemFocusedNative();
			return ret != 0;
		}

		/// <summary>
		/// get ID of last item (~~ often same ImGui::GetID(label) beforehand)<br/>
		/// </summary>
		internal static uint GetItemIDNative()
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<uint>)vt[340])();
			#else
			return (uint)((delegate* unmanaged[Cdecl]<uint>)vt[340])();
			#endif
		}

		/// <summary>
		/// get ID of last item (~~ often same ImGui::GetID(label) beforehand)<br/>
		/// </summary>
		public static uint GetItemID()
		{
			uint ret = GetItemIDNative();
			return ret;
		}

		/// <summary>
		/// get upper-left bounding rectangle of the last item (screen space)<br/>
		/// </summary>
		internal static void GetItemRectMinNative(Vector2* pOut)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<Vector2*, void>)vt[341])(pOut);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)vt[341])((nint)pOut);
			#endif
		}

		/// <summary>
		/// get upper-left bounding rectangle of the last item (screen space)<br/>
		/// </summary>
		public static Vector2 GetItemRectMin()
		{
			Vector2 ret;
			GetItemRectMinNative(&ret);
			return ret;
		}

		/// <summary>
		/// get upper-left bounding rectangle of the last item (screen space)<br/>
		/// </summary>
		public static void GetItemRectMin(Vector2* pOut)
		{
			GetItemRectMinNative(pOut);
		}

		/// <summary>
		/// get upper-left bounding rectangle of the last item (screen space)<br/>
		/// </summary>
		public static void GetItemRectMin(ref Vector2 pOut)
		{
			fixed (Vector2* ppOut = &pOut)
			{
				GetItemRectMinNative((Vector2*)ppOut);
			}
		}

		/// <summary>
		/// get lower-right bounding rectangle of the last item (screen space)<br/>
		/// </summary>
		internal static void GetItemRectMaxNative(Vector2* pOut)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<Vector2*, void>)vt[342])(pOut);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)vt[342])((nint)pOut);
			#endif
		}

		/// <summary>
		/// get lower-right bounding rectangle of the last item (screen space)<br/>
		/// </summary>
		public static Vector2 GetItemRectMax()
		{
			Vector2 ret;
			GetItemRectMaxNative(&ret);
			return ret;
		}

		/// <summary>
		/// get lower-right bounding rectangle of the last item (screen space)<br/>
		/// </summary>
		public static void GetItemRectMax(Vector2* pOut)
		{
			GetItemRectMaxNative(pOut);
		}

		/// <summary>
		/// get lower-right bounding rectangle of the last item (screen space)<br/>
		/// </summary>
		public static void GetItemRectMax(ref Vector2 pOut)
		{
			fixed (Vector2* ppOut = &pOut)
			{
				GetItemRectMaxNative((Vector2*)ppOut);
			}
		}

		/// <summary>
		/// get size of last item<br/>
		/// </summary>
		internal static void GetItemRectSizeNative(Vector2* pOut)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<Vector2*, void>)vt[343])(pOut);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)vt[343])((nint)pOut);
			#endif
		}

		/// <summary>
		/// get size of last item<br/>
		/// </summary>
		public static Vector2 GetItemRectSize()
		{
			Vector2 ret;
			GetItemRectSizeNative(&ret);
			return ret;
		}

		/// <summary>
		/// get size of last item<br/>
		/// </summary>
		public static void GetItemRectSize(Vector2* pOut)
		{
			GetItemRectSizeNative(pOut);
		}

		/// <summary>
		/// get size of last item<br/>
		/// </summary>
		public static void GetItemRectSize(ref Vector2 pOut)
		{
			fixed (Vector2* ppOut = &pOut)
			{
				GetItemRectSizeNative((Vector2*)ppOut);
			}
		}

		/// <summary>
		/// return primarydefault viewport. This can never be NULL.<br/>
		/// </summary>
		internal static ImGuiViewport* GetMainViewportNative()
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<ImGuiViewport*>)vt[344])();
			#else
			return (ImGuiViewport*)((delegate* unmanaged[Cdecl]<nint>)vt[344])();
			#endif
		}

		/// <summary>
		/// return primarydefault viewport. This can never be NULL.<br/>
		/// </summary>
		public static ImGuiViewportPtr GetMainViewport()
		{
			ImGuiViewportPtr ret = GetMainViewportNative();
			return ret;
		}

		/// <summary>
		/// get background draw list for the given viewport or viewport associated to the current window. this draw list will be the first rendering one. Useful to quickly draw shapestext behind dear imgui contents.<br/>
		/// </summary>
		internal static ImDrawList* GetBackgroundDrawListNative(ImGuiViewport* viewport)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<ImGuiViewport*, ImDrawList*>)vt[345])(viewport);
			#else
			return (ImDrawList*)((delegate* unmanaged[Cdecl]<nint, nint>)vt[345])((nint)viewport);
			#endif
		}

		/// <summary>
		/// get background draw list for the given viewport or viewport associated to the current window. this draw list will be the first rendering one. Useful to quickly draw shapestext behind dear imgui contents.<br/>
		/// </summary>
		public static ImDrawListPtr GetBackgroundDrawList(ImGuiViewportPtr viewport)
		{
			ImDrawListPtr ret = GetBackgroundDrawListNative(viewport);
			return ret;
		}

		/// <summary>
		/// get background draw list for the given viewport or viewport associated to the current window. this draw list will be the first rendering one. Useful to quickly draw shapestext behind dear imgui contents.<br/>
		/// </summary>
		public static ImDrawListPtr GetBackgroundDrawList()
		{
			ImDrawListPtr ret = GetBackgroundDrawListNative((ImGuiViewport*)(default));
			return ret;
		}

		/// <summary>
		/// get background draw list for the given viewport or viewport associated to the current window. this draw list will be the first rendering one. Useful to quickly draw shapestext behind dear imgui contents.<br/>
		/// </summary>
		public static ImDrawListPtr GetBackgroundDrawList(ref ImGuiViewport viewport)
		{
			fixed (ImGuiViewport* pviewport = &viewport)
			{
				ImDrawListPtr ret = GetBackgroundDrawListNative((ImGuiViewport*)pviewport);
				return ret;
			}
		}

		/// <summary>
		/// get foreground draw list for the given viewport or viewport associated to the current window. this draw list will be the top-most rendered one. Useful to quickly draw shapestext over dear imgui contents.<br/>
		/// </summary>
		internal static ImDrawList* GetForegroundDrawListNative(ImGuiViewport* viewport)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<ImGuiViewport*, ImDrawList*>)vt[346])(viewport);
			#else
			return (ImDrawList*)((delegate* unmanaged[Cdecl]<nint, nint>)vt[346])((nint)viewport);
			#endif
		}

		/// <summary>
		/// get foreground draw list for the given viewport or viewport associated to the current window. this draw list will be the top-most rendered one. Useful to quickly draw shapestext over dear imgui contents.<br/>
		/// </summary>
		public static ImDrawListPtr GetForegroundDrawList(ImGuiViewportPtr viewport)
		{
			ImDrawListPtr ret = GetForegroundDrawListNative(viewport);
			return ret;
		}

		/// <summary>
		/// get foreground draw list for the given viewport or viewport associated to the current window. this draw list will be the top-most rendered one. Useful to quickly draw shapestext over dear imgui contents.<br/>
		/// </summary>
		public static ImDrawListPtr GetForegroundDrawList()
		{
			ImDrawListPtr ret = GetForegroundDrawListNative((ImGuiViewport*)(default));
			return ret;
		}

		/// <summary>
		/// get foreground draw list for the given viewport or viewport associated to the current window. this draw list will be the top-most rendered one. Useful to quickly draw shapestext over dear imgui contents.<br/>
		/// </summary>
		public static ImDrawListPtr GetForegroundDrawList(ref ImGuiViewport viewport)
		{
			fixed (ImGuiViewport* pviewport = &viewport)
			{
				ImDrawListPtr ret = GetForegroundDrawListNative((ImGuiViewport*)pviewport);
				return ret;
			}
		}

		/// <summary>
		/// test if rectangle (of given size, starting from cursor position) is visible  not clipped.<br/>
		/// </summary>
		internal static byte IsRectVisibleNative(Vector2 size)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<Vector2, byte>)vt[347])(size);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<Vector2, byte>)vt[347])(size);
			#endif
		}

		/// <summary>
		/// test if rectangle (of given size, starting from cursor position) is visible  not clipped.<br/>
		/// </summary>
		public static bool IsRectVisible(Vector2 size)
		{
			byte ret = IsRectVisibleNative(size);
			return ret != 0;
		}

		/// <summary>
		/// test if rectangle (of given size, starting from cursor position) is visible  not clipped.<br/>
		/// </summary>
		internal static byte IsRectVisibleNative(Vector2 rectMin, Vector2 rectMax)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<Vector2, Vector2, byte>)vt[348])(rectMin, rectMax);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<Vector2, Vector2, byte>)vt[348])(rectMin, rectMax);
			#endif
		}

		/// <summary>
		/// test if rectangle (in screen space) is visible  not clipped. to perform coarse clipping on user's side.<br/>
		/// </summary>
		public static bool IsRectVisible(Vector2 rectMin, Vector2 rectMax)
		{
			byte ret = IsRectVisibleNative(rectMin, rectMax);
			return ret != 0;
		}

		/// <summary>
		/// get global imgui time. incremented by io.DeltaTime every frame.<br/>
		/// </summary>
		internal static double GetTimeNative()
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<double>)vt[349])();
			#else
			return (double)((delegate* unmanaged[Cdecl]<double>)vt[349])();
			#endif
		}

		/// <summary>
		/// get global imgui time. incremented by io.DeltaTime every frame.<br/>
		/// </summary>
		public static double GetTime()
		{
			double ret = GetTimeNative();
			return ret;
		}

		/// <summary>
		/// get global imgui frame count. incremented by 1 every frame.<br/>
		/// </summary>
		internal static int GetFrameCountNative()
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<int>)vt[350])();
			#else
			return (int)((delegate* unmanaged[Cdecl]<int>)vt[350])();
			#endif
		}

		/// <summary>
		/// get global imgui frame count. incremented by 1 every frame.<br/>
		/// </summary>
		public static int GetFrameCount()
		{
			int ret = GetFrameCountNative();
			return ret;
		}

		/// <summary>
		/// you may use this when creating your own ImDrawList instances.<br/>
		/// </summary>
		internal static ImDrawListSharedData* GetDrawListSharedDataNative()
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<ImDrawListSharedData*>)vt[351])();
			#else
			return (ImDrawListSharedData*)((delegate* unmanaged[Cdecl]<nint>)vt[351])();
			#endif
		}

		/// <summary>
		/// you may use this when creating your own ImDrawList instances.<br/>
		/// </summary>
		public static ImDrawListSharedDataPtr GetDrawListSharedData()
		{
			ImDrawListSharedDataPtr ret = GetDrawListSharedDataNative();
			return ret;
		}

		/// <summary>
		/// get a string corresponding to the enum value (for display, saving, etc.).<br/>
		/// </summary>
		internal static byte* GetStyleColorNameNative(ImGuiCol idx)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<ImGuiCol, byte*>)vt[352])(idx);
			#else
			return (byte*)((delegate* unmanaged[Cdecl]<ImGuiCol, nint>)vt[352])(idx);
			#endif
		}

		/// <summary>
		/// get a string corresponding to the enum value (for display, saving, etc.).<br/>
		/// </summary>
		public static byte* GetStyleColorName(ImGuiCol idx)
		{
			byte* ret = GetStyleColorNameNative(idx);
			return ret;
		}

		/// <summary>
		/// get a string corresponding to the enum value (for display, saving, etc.).<br/>
		/// </summary>
		public static string GetStyleColorNameS(ImGuiCol idx)
		{
			string ret = Utils.DecodeStringUTF8(GetStyleColorNameNative(idx));
			return ret;
		}

		/// <summary>
		/// replace current window storage with our own (if you want to manipulate it yourself, typically clear subsection of it)<br/>
		/// </summary>
		internal static void SetStateStorageNative(ImGuiStorage* storage)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<ImGuiStorage*, void>)vt[353])(storage);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)vt[353])((nint)storage);
			#endif
		}

		/// <summary>
		/// replace current window storage with our own (if you want to manipulate it yourself, typically clear subsection of it)<br/>
		/// </summary>
		public static void SetStateStorage(ImGuiStoragePtr storage)
		{
			SetStateStorageNative(storage);
		}

		/// <summary>
		/// replace current window storage with our own (if you want to manipulate it yourself, typically clear subsection of it)<br/>
		/// </summary>
		public static void SetStateStorage(ref ImGuiStorage storage)
		{
			fixed (ImGuiStorage* pstorage = &storage)
			{
				SetStateStorageNative((ImGuiStorage*)pstorage);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		internal static ImGuiStorage* GetStateStorageNative()
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<ImGuiStorage*>)vt[354])();
			#else
			return (ImGuiStorage*)((delegate* unmanaged[Cdecl]<nint>)vt[354])();
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static ImGuiStoragePtr GetStateStorage()
		{
			ImGuiStoragePtr ret = GetStateStorageNative();
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		internal static void CalcTextSizeNative(Vector2* pOut, byte* text, byte* textEnd, byte hideTextAfterDoubleHash, float wrapWidth)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<Vector2*, byte*, byte*, byte, float, void>)vt[355])(pOut, text, textEnd, hideTextAfterDoubleHash, wrapWidth);
			#else
			((delegate* unmanaged[Cdecl]<nint, nint, nint, byte, float, void>)vt[355])((nint)pOut, (nint)text, (nint)textEnd, hideTextAfterDoubleHash, wrapWidth);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static Vector2 CalcTextSize(byte* text)
		{
			Vector2 ret;
			CalcTextSizeNative(&ret, text, (byte*)(default), (byte)(0), (float)(-1.0f));
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static Vector2 CalcTextSize(byte* text, byte* textEnd)
		{
			Vector2 ret;
			CalcTextSizeNative(&ret, text, textEnd, (byte)(0), (float)(-1.0f));
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void CalcTextSize(Vector2* pOut, byte* text)
		{
			CalcTextSizeNative(pOut, text, (byte*)(default), (byte)(0), (float)(-1.0f));
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static Vector2 CalcTextSize(byte* text, bool hideTextAfterDoubleHash)
		{
			Vector2 ret;
			CalcTextSizeNative(&ret, text, (byte*)(default), hideTextAfterDoubleHash ? (byte)1 : (byte)0, (float)(-1.0f));
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static Vector2 CalcTextSize(byte* text, byte* textEnd, bool hideTextAfterDoubleHash)
		{
			Vector2 ret;
			CalcTextSizeNative(&ret, text, textEnd, hideTextAfterDoubleHash ? (byte)1 : (byte)0, (float)(-1.0f));
			return ret;
		}
	}
}
