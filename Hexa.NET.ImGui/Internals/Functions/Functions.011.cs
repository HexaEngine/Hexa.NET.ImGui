// ------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
// ------------------------------------------------------------------------------

using System;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;
using HexaGen.Runtime;
using System.Numerics;

namespace Hexa.NET.ImGui
{
	public unsafe partial class ImGuiP
	{

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool IsMouseDown(ImGuiMouseButton button, uint ownerId)
		{
			byte ret = IsMouseDownNative(button, ownerId);
			return ret != 0;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte IsMouseClickedNative(ImGuiMouseButton button, ImGuiInputFlags flags, uint ownerId)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<ImGuiMouseButton, ImGuiInputFlags, uint, byte>)funcTable[1195])(button, flags, ownerId);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<ImGuiMouseButton, ImGuiInputFlags, uint, byte>)funcTable[1195])(button, flags, ownerId);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool IsMouseClicked(ImGuiMouseButton button, ImGuiInputFlags flags, uint ownerId)
		{
			byte ret = IsMouseClickedNative(button, flags, ownerId);
			return ret != 0;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool IsMouseClicked(ImGuiMouseButton button, ImGuiInputFlags flags)
		{
			byte ret = IsMouseClickedNative(button, flags, (uint)(0));
			return ret != 0;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte IsMouseReleasedNative(ImGuiMouseButton button, uint ownerId)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<ImGuiMouseButton, uint, byte>)funcTable[1196])(button, ownerId);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<ImGuiMouseButton, uint, byte>)funcTable[1196])(button, ownerId);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool IsMouseReleased(ImGuiMouseButton button, uint ownerId)
		{
			byte ret = IsMouseReleasedNative(button, ownerId);
			return ret != 0;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte IsMouseDoubleClickedNative(ImGuiMouseButton button, uint ownerId)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<ImGuiMouseButton, uint, byte>)funcTable[1197])(button, ownerId);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<ImGuiMouseButton, uint, byte>)funcTable[1197])(button, ownerId);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool IsMouseDoubleClicked(ImGuiMouseButton button, uint ownerId)
		{
			byte ret = IsMouseDoubleClickedNative(button, ownerId);
			return ret != 0;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte ShortcutNative(int keyChord, ImGuiInputFlags flags, uint ownerId)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<int, ImGuiInputFlags, uint, byte>)funcTable[1198])(keyChord, flags, ownerId);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<int, ImGuiInputFlags, uint, byte>)funcTable[1198])(keyChord, flags, ownerId);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool Shortcut(int keyChord, ImGuiInputFlags flags, uint ownerId)
		{
			byte ret = ShortcutNative(keyChord, flags, ownerId);
			return ret != 0;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte SetShortcutRoutingNative(int keyChord, ImGuiInputFlags flags, uint ownerId)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<int, ImGuiInputFlags, uint, byte>)funcTable[1199])(keyChord, flags, ownerId);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<int, ImGuiInputFlags, uint, byte>)funcTable[1199])(keyChord, flags, ownerId);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool SetShortcutRouting(int keyChord, ImGuiInputFlags flags, uint ownerId)
		{
			byte ret = SetShortcutRoutingNative(keyChord, flags, ownerId);
			return ret != 0;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte TestShortcutRoutingNative(int keyChord, uint ownerId)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<int, uint, byte>)funcTable[1200])(keyChord, ownerId);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<int, uint, byte>)funcTable[1200])(keyChord, ownerId);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool TestShortcutRouting(int keyChord, uint ownerId)
		{
			byte ret = TestShortcutRoutingNative(keyChord, ownerId);
			return ret != 0;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static ImGuiKeyRoutingData* GetShortcutRoutingDataNative(int keyChord)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<int, ImGuiKeyRoutingData*>)funcTable[1201])(keyChord);
			#else
			return (ImGuiKeyRoutingData*)((delegate* unmanaged[Cdecl]<int, nint>)funcTable[1201])(keyChord);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static ImGuiKeyRoutingDataPtr GetShortcutRoutingData(int keyChord)
		{
			ImGuiKeyRoutingDataPtr ret = GetShortcutRoutingDataNative(keyChord);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void DockContextInitializeNative(ImGuiContext* ctx)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<ImGuiContext*, void>)funcTable[1202])(ctx);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)funcTable[1202])((nint)ctx);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void DockContextInitialize(ImGuiContextPtr ctx)
		{
			DockContextInitializeNative(ctx);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void DockContextInitialize(ref ImGuiContext ctx)
		{
			fixed (ImGuiContext* pctx = &ctx)
			{
				DockContextInitializeNative((ImGuiContext*)pctx);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void DockContextShutdownNative(ImGuiContext* ctx)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<ImGuiContext*, void>)funcTable[1203])(ctx);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)funcTable[1203])((nint)ctx);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void DockContextShutdown(ImGuiContextPtr ctx)
		{
			DockContextShutdownNative(ctx);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void DockContextShutdown(ref ImGuiContext ctx)
		{
			fixed (ImGuiContext* pctx = &ctx)
			{
				DockContextShutdownNative((ImGuiContext*)pctx);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void DockContextClearNodesNative(ImGuiContext* ctx, uint rootId, byte clearSettingsRefs)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<ImGuiContext*, uint, byte, void>)funcTable[1204])(ctx, rootId, clearSettingsRefs);
			#else
			((delegate* unmanaged[Cdecl]<nint, uint, byte, void>)funcTable[1204])((nint)ctx, rootId, clearSettingsRefs);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void DockContextClearNodes(ImGuiContextPtr ctx, uint rootId, bool clearSettingsRefs)
		{
			DockContextClearNodesNative(ctx, rootId, clearSettingsRefs ? (byte)1 : (byte)0);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void DockContextClearNodes(ref ImGuiContext ctx, uint rootId, bool clearSettingsRefs)
		{
			fixed (ImGuiContext* pctx = &ctx)
			{
				DockContextClearNodesNative((ImGuiContext*)pctx, rootId, clearSettingsRefs ? (byte)1 : (byte)0);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void DockContextRebuildNodesNative(ImGuiContext* ctx)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<ImGuiContext*, void>)funcTable[1205])(ctx);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)funcTable[1205])((nint)ctx);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void DockContextRebuildNodes(ImGuiContextPtr ctx)
		{
			DockContextRebuildNodesNative(ctx);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void DockContextRebuildNodes(ref ImGuiContext ctx)
		{
			fixed (ImGuiContext* pctx = &ctx)
			{
				DockContextRebuildNodesNative((ImGuiContext*)pctx);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void DockContextNewFrameUpdateUndockingNative(ImGuiContext* ctx)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<ImGuiContext*, void>)funcTable[1206])(ctx);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)funcTable[1206])((nint)ctx);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void DockContextNewFrameUpdateUndocking(ImGuiContextPtr ctx)
		{
			DockContextNewFrameUpdateUndockingNative(ctx);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void DockContextNewFrameUpdateUndocking(ref ImGuiContext ctx)
		{
			fixed (ImGuiContext* pctx = &ctx)
			{
				DockContextNewFrameUpdateUndockingNative((ImGuiContext*)pctx);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void DockContextNewFrameUpdateDockingNative(ImGuiContext* ctx)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<ImGuiContext*, void>)funcTable[1207])(ctx);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)funcTable[1207])((nint)ctx);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void DockContextNewFrameUpdateDocking(ImGuiContextPtr ctx)
		{
			DockContextNewFrameUpdateDockingNative(ctx);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void DockContextNewFrameUpdateDocking(ref ImGuiContext ctx)
		{
			fixed (ImGuiContext* pctx = &ctx)
			{
				DockContextNewFrameUpdateDockingNative((ImGuiContext*)pctx);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void DockContextEndFrameNative(ImGuiContext* ctx)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<ImGuiContext*, void>)funcTable[1208])(ctx);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)funcTable[1208])((nint)ctx);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void DockContextEndFrame(ImGuiContextPtr ctx)
		{
			DockContextEndFrameNative(ctx);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void DockContextEndFrame(ref ImGuiContext ctx)
		{
			fixed (ImGuiContext* pctx = &ctx)
			{
				DockContextEndFrameNative((ImGuiContext*)pctx);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static uint DockContextGenNodeIDNative(ImGuiContext* ctx)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<ImGuiContext*, uint>)funcTable[1209])(ctx);
			#else
			return (uint)((delegate* unmanaged[Cdecl]<nint, uint>)funcTable[1209])((nint)ctx);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static uint DockContextGenNodeID(ImGuiContextPtr ctx)
		{
			uint ret = DockContextGenNodeIDNative(ctx);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static uint DockContextGenNodeID(ref ImGuiContext ctx)
		{
			fixed (ImGuiContext* pctx = &ctx)
			{
				uint ret = DockContextGenNodeIDNative((ImGuiContext*)pctx);
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void DockContextQueueDockNative(ImGuiContext* ctx, ImGuiWindow* target, ImGuiDockNode* targetNode, ImGuiWindow* payload, ImGuiDir splitDir, float splitRatio, byte splitOuter)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<ImGuiContext*, ImGuiWindow*, ImGuiDockNode*, ImGuiWindow*, ImGuiDir, float, byte, void>)funcTable[1210])(ctx, target, targetNode, payload, splitDir, splitRatio, splitOuter);
			#else
			((delegate* unmanaged[Cdecl]<nint, nint, nint, nint, ImGuiDir, float, byte, void>)funcTable[1210])((nint)ctx, (nint)target, (nint)targetNode, (nint)payload, splitDir, splitRatio, splitOuter);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void DockContextQueueDock(ImGuiContextPtr ctx, ImGuiWindowPtr target, ImGuiDockNodePtr targetNode, ImGuiWindowPtr payload, ImGuiDir splitDir, float splitRatio, bool splitOuter)
		{
			DockContextQueueDockNative(ctx, target, targetNode, payload, splitDir, splitRatio, splitOuter ? (byte)1 : (byte)0);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void DockContextQueueDock(ref ImGuiContext ctx, ImGuiWindowPtr target, ImGuiDockNodePtr targetNode, ImGuiWindowPtr payload, ImGuiDir splitDir, float splitRatio, bool splitOuter)
		{
			fixed (ImGuiContext* pctx = &ctx)
			{
				DockContextQueueDockNative((ImGuiContext*)pctx, target, targetNode, payload, splitDir, splitRatio, splitOuter ? (byte)1 : (byte)0);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void DockContextQueueDock(ImGuiContextPtr ctx, ref ImGuiWindow target, ImGuiDockNodePtr targetNode, ImGuiWindowPtr payload, ImGuiDir splitDir, float splitRatio, bool splitOuter)
		{
			fixed (ImGuiWindow* ptarget = &target)
			{
				DockContextQueueDockNative(ctx, (ImGuiWindow*)ptarget, targetNode, payload, splitDir, splitRatio, splitOuter ? (byte)1 : (byte)0);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void DockContextQueueDock(ref ImGuiContext ctx, ref ImGuiWindow target, ImGuiDockNodePtr targetNode, ImGuiWindowPtr payload, ImGuiDir splitDir, float splitRatio, bool splitOuter)
		{
			fixed (ImGuiContext* pctx = &ctx)
			{
				fixed (ImGuiWindow* ptarget = &target)
				{
					DockContextQueueDockNative((ImGuiContext*)pctx, (ImGuiWindow*)ptarget, targetNode, payload, splitDir, splitRatio, splitOuter ? (byte)1 : (byte)0);
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void DockContextQueueDock(ImGuiContextPtr ctx, ImGuiWindowPtr target, ref ImGuiDockNode targetNode, ImGuiWindowPtr payload, ImGuiDir splitDir, float splitRatio, bool splitOuter)
		{
			fixed (ImGuiDockNode* ptargetNode = &targetNode)
			{
				DockContextQueueDockNative(ctx, target, (ImGuiDockNode*)ptargetNode, payload, splitDir, splitRatio, splitOuter ? (byte)1 : (byte)0);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void DockContextQueueDock(ref ImGuiContext ctx, ImGuiWindowPtr target, ref ImGuiDockNode targetNode, ImGuiWindowPtr payload, ImGuiDir splitDir, float splitRatio, bool splitOuter)
		{
			fixed (ImGuiContext* pctx = &ctx)
			{
				fixed (ImGuiDockNode* ptargetNode = &targetNode)
				{
					DockContextQueueDockNative((ImGuiContext*)pctx, target, (ImGuiDockNode*)ptargetNode, payload, splitDir, splitRatio, splitOuter ? (byte)1 : (byte)0);
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void DockContextQueueDock(ImGuiContextPtr ctx, ref ImGuiWindow target, ref ImGuiDockNode targetNode, ImGuiWindowPtr payload, ImGuiDir splitDir, float splitRatio, bool splitOuter)
		{
			fixed (ImGuiWindow* ptarget = &target)
			{
				fixed (ImGuiDockNode* ptargetNode = &targetNode)
				{
					DockContextQueueDockNative(ctx, (ImGuiWindow*)ptarget, (ImGuiDockNode*)ptargetNode, payload, splitDir, splitRatio, splitOuter ? (byte)1 : (byte)0);
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void DockContextQueueDock(ref ImGuiContext ctx, ref ImGuiWindow target, ref ImGuiDockNode targetNode, ImGuiWindowPtr payload, ImGuiDir splitDir, float splitRatio, bool splitOuter)
		{
			fixed (ImGuiContext* pctx = &ctx)
			{
				fixed (ImGuiWindow* ptarget = &target)
				{
					fixed (ImGuiDockNode* ptargetNode = &targetNode)
					{
						DockContextQueueDockNative((ImGuiContext*)pctx, (ImGuiWindow*)ptarget, (ImGuiDockNode*)ptargetNode, payload, splitDir, splitRatio, splitOuter ? (byte)1 : (byte)0);
					}
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void DockContextQueueDock(ImGuiContextPtr ctx, ImGuiWindowPtr target, ImGuiDockNodePtr targetNode, ref ImGuiWindow payload, ImGuiDir splitDir, float splitRatio, bool splitOuter)
		{
			fixed (ImGuiWindow* ppayload = &payload)
			{
				DockContextQueueDockNative(ctx, target, targetNode, (ImGuiWindow*)ppayload, splitDir, splitRatio, splitOuter ? (byte)1 : (byte)0);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void DockContextQueueDock(ref ImGuiContext ctx, ImGuiWindowPtr target, ImGuiDockNodePtr targetNode, ref ImGuiWindow payload, ImGuiDir splitDir, float splitRatio, bool splitOuter)
		{
			fixed (ImGuiContext* pctx = &ctx)
			{
				fixed (ImGuiWindow* ppayload = &payload)
				{
					DockContextQueueDockNative((ImGuiContext*)pctx, target, targetNode, (ImGuiWindow*)ppayload, splitDir, splitRatio, splitOuter ? (byte)1 : (byte)0);
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void DockContextQueueDock(ImGuiContextPtr ctx, ref ImGuiWindow target, ImGuiDockNodePtr targetNode, ref ImGuiWindow payload, ImGuiDir splitDir, float splitRatio, bool splitOuter)
		{
			fixed (ImGuiWindow* ptarget = &target)
			{
				fixed (ImGuiWindow* ppayload = &payload)
				{
					DockContextQueueDockNative(ctx, (ImGuiWindow*)ptarget, targetNode, (ImGuiWindow*)ppayload, splitDir, splitRatio, splitOuter ? (byte)1 : (byte)0);
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void DockContextQueueDock(ref ImGuiContext ctx, ref ImGuiWindow target, ImGuiDockNodePtr targetNode, ref ImGuiWindow payload, ImGuiDir splitDir, float splitRatio, bool splitOuter)
		{
			fixed (ImGuiContext* pctx = &ctx)
			{
				fixed (ImGuiWindow* ptarget = &target)
				{
					fixed (ImGuiWindow* ppayload = &payload)
					{
						DockContextQueueDockNative((ImGuiContext*)pctx, (ImGuiWindow*)ptarget, targetNode, (ImGuiWindow*)ppayload, splitDir, splitRatio, splitOuter ? (byte)1 : (byte)0);
					}
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void DockContextQueueDock(ImGuiContextPtr ctx, ImGuiWindowPtr target, ref ImGuiDockNode targetNode, ref ImGuiWindow payload, ImGuiDir splitDir, float splitRatio, bool splitOuter)
		{
			fixed (ImGuiDockNode* ptargetNode = &targetNode)
			{
				fixed (ImGuiWindow* ppayload = &payload)
				{
					DockContextQueueDockNative(ctx, target, (ImGuiDockNode*)ptargetNode, (ImGuiWindow*)ppayload, splitDir, splitRatio, splitOuter ? (byte)1 : (byte)0);
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void DockContextQueueDock(ref ImGuiContext ctx, ImGuiWindowPtr target, ref ImGuiDockNode targetNode, ref ImGuiWindow payload, ImGuiDir splitDir, float splitRatio, bool splitOuter)
		{
			fixed (ImGuiContext* pctx = &ctx)
			{
				fixed (ImGuiDockNode* ptargetNode = &targetNode)
				{
					fixed (ImGuiWindow* ppayload = &payload)
					{
						DockContextQueueDockNative((ImGuiContext*)pctx, target, (ImGuiDockNode*)ptargetNode, (ImGuiWindow*)ppayload, splitDir, splitRatio, splitOuter ? (byte)1 : (byte)0);
					}
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void DockContextQueueDock(ImGuiContextPtr ctx, ref ImGuiWindow target, ref ImGuiDockNode targetNode, ref ImGuiWindow payload, ImGuiDir splitDir, float splitRatio, bool splitOuter)
		{
			fixed (ImGuiWindow* ptarget = &target)
			{
				fixed (ImGuiDockNode* ptargetNode = &targetNode)
				{
					fixed (ImGuiWindow* ppayload = &payload)
					{
						DockContextQueueDockNative(ctx, (ImGuiWindow*)ptarget, (ImGuiDockNode*)ptargetNode, (ImGuiWindow*)ppayload, splitDir, splitRatio, splitOuter ? (byte)1 : (byte)0);
					}
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void DockContextQueueDock(ref ImGuiContext ctx, ref ImGuiWindow target, ref ImGuiDockNode targetNode, ref ImGuiWindow payload, ImGuiDir splitDir, float splitRatio, bool splitOuter)
		{
			fixed (ImGuiContext* pctx = &ctx)
			{
				fixed (ImGuiWindow* ptarget = &target)
				{
					fixed (ImGuiDockNode* ptargetNode = &targetNode)
					{
						fixed (ImGuiWindow* ppayload = &payload)
						{
							DockContextQueueDockNative((ImGuiContext*)pctx, (ImGuiWindow*)ptarget, (ImGuiDockNode*)ptargetNode, (ImGuiWindow*)ppayload, splitDir, splitRatio, splitOuter ? (byte)1 : (byte)0);
						}
					}
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void DockContextQueueUndockWindowNative(ImGuiContext* ctx, ImGuiWindow* window)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<ImGuiContext*, ImGuiWindow*, void>)funcTable[1211])(ctx, window);
			#else
			((delegate* unmanaged[Cdecl]<nint, nint, void>)funcTable[1211])((nint)ctx, (nint)window);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void DockContextQueueUndockWindow(ImGuiContextPtr ctx, ImGuiWindowPtr window)
		{
			DockContextQueueUndockWindowNative(ctx, window);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void DockContextQueueUndockWindow(ref ImGuiContext ctx, ImGuiWindowPtr window)
		{
			fixed (ImGuiContext* pctx = &ctx)
			{
				DockContextQueueUndockWindowNative((ImGuiContext*)pctx, window);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void DockContextQueueUndockWindow(ImGuiContextPtr ctx, ref ImGuiWindow window)
		{
			fixed (ImGuiWindow* pwindow = &window)
			{
				DockContextQueueUndockWindowNative(ctx, (ImGuiWindow*)pwindow);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void DockContextQueueUndockWindow(ref ImGuiContext ctx, ref ImGuiWindow window)
		{
			fixed (ImGuiContext* pctx = &ctx)
			{
				fixed (ImGuiWindow* pwindow = &window)
				{
					DockContextQueueUndockWindowNative((ImGuiContext*)pctx, (ImGuiWindow*)pwindow);
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void DockContextQueueUndockNodeNative(ImGuiContext* ctx, ImGuiDockNode* node)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<ImGuiContext*, ImGuiDockNode*, void>)funcTable[1212])(ctx, node);
			#else
			((delegate* unmanaged[Cdecl]<nint, nint, void>)funcTable[1212])((nint)ctx, (nint)node);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void DockContextQueueUndockNode(ImGuiContextPtr ctx, ImGuiDockNodePtr node)
		{
			DockContextQueueUndockNodeNative(ctx, node);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void DockContextQueueUndockNode(ref ImGuiContext ctx, ImGuiDockNodePtr node)
		{
			fixed (ImGuiContext* pctx = &ctx)
			{
				DockContextQueueUndockNodeNative((ImGuiContext*)pctx, node);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void DockContextQueueUndockNode(ImGuiContextPtr ctx, ref ImGuiDockNode node)
		{
			fixed (ImGuiDockNode* pnode = &node)
			{
				DockContextQueueUndockNodeNative(ctx, (ImGuiDockNode*)pnode);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void DockContextQueueUndockNode(ref ImGuiContext ctx, ref ImGuiDockNode node)
		{
			fixed (ImGuiContext* pctx = &ctx)
			{
				fixed (ImGuiDockNode* pnode = &node)
				{
					DockContextQueueUndockNodeNative((ImGuiContext*)pctx, (ImGuiDockNode*)pnode);
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void DockContextProcessUndockWindowNative(ImGuiContext* ctx, ImGuiWindow* window, byte clearPersistentDockingRef)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<ImGuiContext*, ImGuiWindow*, byte, void>)funcTable[1213])(ctx, window, clearPersistentDockingRef);
			#else
			((delegate* unmanaged[Cdecl]<nint, nint, byte, void>)funcTable[1213])((nint)ctx, (nint)window, clearPersistentDockingRef);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void DockContextProcessUndockWindow(ImGuiContextPtr ctx, ImGuiWindowPtr window, bool clearPersistentDockingRef)
		{
			DockContextProcessUndockWindowNative(ctx, window, clearPersistentDockingRef ? (byte)1 : (byte)0);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void DockContextProcessUndockWindow(ImGuiContextPtr ctx, ImGuiWindowPtr window)
		{
			DockContextProcessUndockWindowNative(ctx, window, (byte)(1));
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void DockContextProcessUndockWindow(ref ImGuiContext ctx, ImGuiWindowPtr window, bool clearPersistentDockingRef)
		{
			fixed (ImGuiContext* pctx = &ctx)
			{
				DockContextProcessUndockWindowNative((ImGuiContext*)pctx, window, clearPersistentDockingRef ? (byte)1 : (byte)0);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void DockContextProcessUndockWindow(ref ImGuiContext ctx, ImGuiWindowPtr window)
		{
			fixed (ImGuiContext* pctx = &ctx)
			{
				DockContextProcessUndockWindowNative((ImGuiContext*)pctx, window, (byte)(1));
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void DockContextProcessUndockWindow(ImGuiContextPtr ctx, ref ImGuiWindow window, bool clearPersistentDockingRef)
		{
			fixed (ImGuiWindow* pwindow = &window)
			{
				DockContextProcessUndockWindowNative(ctx, (ImGuiWindow*)pwindow, clearPersistentDockingRef ? (byte)1 : (byte)0);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void DockContextProcessUndockWindow(ImGuiContextPtr ctx, ref ImGuiWindow window)
		{
			fixed (ImGuiWindow* pwindow = &window)
			{
				DockContextProcessUndockWindowNative(ctx, (ImGuiWindow*)pwindow, (byte)(1));
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void DockContextProcessUndockWindow(ref ImGuiContext ctx, ref ImGuiWindow window, bool clearPersistentDockingRef)
		{
			fixed (ImGuiContext* pctx = &ctx)
			{
				fixed (ImGuiWindow* pwindow = &window)
				{
					DockContextProcessUndockWindowNative((ImGuiContext*)pctx, (ImGuiWindow*)pwindow, clearPersistentDockingRef ? (byte)1 : (byte)0);
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void DockContextProcessUndockWindow(ref ImGuiContext ctx, ref ImGuiWindow window)
		{
			fixed (ImGuiContext* pctx = &ctx)
			{
				fixed (ImGuiWindow* pwindow = &window)
				{
					DockContextProcessUndockWindowNative((ImGuiContext*)pctx, (ImGuiWindow*)pwindow, (byte)(1));
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void DockContextProcessUndockNodeNative(ImGuiContext* ctx, ImGuiDockNode* node)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<ImGuiContext*, ImGuiDockNode*, void>)funcTable[1214])(ctx, node);
			#else
			((delegate* unmanaged[Cdecl]<nint, nint, void>)funcTable[1214])((nint)ctx, (nint)node);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void DockContextProcessUndockNode(ImGuiContextPtr ctx, ImGuiDockNodePtr node)
		{
			DockContextProcessUndockNodeNative(ctx, node);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void DockContextProcessUndockNode(ref ImGuiContext ctx, ImGuiDockNodePtr node)
		{
			fixed (ImGuiContext* pctx = &ctx)
			{
				DockContextProcessUndockNodeNative((ImGuiContext*)pctx, node);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void DockContextProcessUndockNode(ImGuiContextPtr ctx, ref ImGuiDockNode node)
		{
			fixed (ImGuiDockNode* pnode = &node)
			{
				DockContextProcessUndockNodeNative(ctx, (ImGuiDockNode*)pnode);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void DockContextProcessUndockNode(ref ImGuiContext ctx, ref ImGuiDockNode node)
		{
			fixed (ImGuiContext* pctx = &ctx)
			{
				fixed (ImGuiDockNode* pnode = &node)
				{
					DockContextProcessUndockNodeNative((ImGuiContext*)pctx, (ImGuiDockNode*)pnode);
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte DockContextCalcDropPosForDockingNative(ImGuiWindow* target, ImGuiDockNode* targetNode, ImGuiWindow* payloadWindow, ImGuiDockNode* payloadNode, ImGuiDir splitDir, byte splitOuter, Vector2* outPos)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<ImGuiWindow*, ImGuiDockNode*, ImGuiWindow*, ImGuiDockNode*, ImGuiDir, byte, Vector2*, byte>)funcTable[1215])(target, targetNode, payloadWindow, payloadNode, splitDir, splitOuter, outPos);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<nint, nint, nint, nint, ImGuiDir, byte, nint, byte>)funcTable[1215])((nint)target, (nint)targetNode, (nint)payloadWindow, (nint)payloadNode, splitDir, splitOuter, (nint)outPos);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool DockContextCalcDropPosForDocking(ImGuiWindowPtr target, ImGuiDockNodePtr targetNode, ImGuiWindowPtr payloadWindow, ImGuiDockNodePtr payloadNode, ImGuiDir splitDir, bool splitOuter, Vector2* outPos)
		{
			byte ret = DockContextCalcDropPosForDockingNative(target, targetNode, payloadWindow, payloadNode, splitDir, splitOuter ? (byte)1 : (byte)0, outPos);
			return ret != 0;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool DockContextCalcDropPosForDocking(ref ImGuiWindow target, ImGuiDockNodePtr targetNode, ImGuiWindowPtr payloadWindow, ImGuiDockNodePtr payloadNode, ImGuiDir splitDir, bool splitOuter, Vector2* outPos)
		{
			fixed (ImGuiWindow* ptarget = &target)
			{
				byte ret = DockContextCalcDropPosForDockingNative((ImGuiWindow*)ptarget, targetNode, payloadWindow, payloadNode, splitDir, splitOuter ? (byte)1 : (byte)0, outPos);
				return ret != 0;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool DockContextCalcDropPosForDocking(ImGuiWindowPtr target, ref ImGuiDockNode targetNode, ImGuiWindowPtr payloadWindow, ImGuiDockNodePtr payloadNode, ImGuiDir splitDir, bool splitOuter, Vector2* outPos)
		{
			fixed (ImGuiDockNode* ptargetNode = &targetNode)
			{
				byte ret = DockContextCalcDropPosForDockingNative(target, (ImGuiDockNode*)ptargetNode, payloadWindow, payloadNode, splitDir, splitOuter ? (byte)1 : (byte)0, outPos);
				return ret != 0;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool DockContextCalcDropPosForDocking(ref ImGuiWindow target, ref ImGuiDockNode targetNode, ImGuiWindowPtr payloadWindow, ImGuiDockNodePtr payloadNode, ImGuiDir splitDir, bool splitOuter, Vector2* outPos)
		{
			fixed (ImGuiWindow* ptarget = &target)
			{
				fixed (ImGuiDockNode* ptargetNode = &targetNode)
				{
					byte ret = DockContextCalcDropPosForDockingNative((ImGuiWindow*)ptarget, (ImGuiDockNode*)ptargetNode, payloadWindow, payloadNode, splitDir, splitOuter ? (byte)1 : (byte)0, outPos);
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool DockContextCalcDropPosForDocking(ImGuiWindowPtr target, ImGuiDockNodePtr targetNode, ref ImGuiWindow payloadWindow, ImGuiDockNodePtr payloadNode, ImGuiDir splitDir, bool splitOuter, Vector2* outPos)
		{
			fixed (ImGuiWindow* ppayloadWindow = &payloadWindow)
			{
				byte ret = DockContextCalcDropPosForDockingNative(target, targetNode, (ImGuiWindow*)ppayloadWindow, payloadNode, splitDir, splitOuter ? (byte)1 : (byte)0, outPos);
				return ret != 0;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool DockContextCalcDropPosForDocking(ref ImGuiWindow target, ImGuiDockNodePtr targetNode, ref ImGuiWindow payloadWindow, ImGuiDockNodePtr payloadNode, ImGuiDir splitDir, bool splitOuter, Vector2* outPos)
		{
			fixed (ImGuiWindow* ptarget = &target)
			{
				fixed (ImGuiWindow* ppayloadWindow = &payloadWindow)
				{
					byte ret = DockContextCalcDropPosForDockingNative((ImGuiWindow*)ptarget, targetNode, (ImGuiWindow*)ppayloadWindow, payloadNode, splitDir, splitOuter ? (byte)1 : (byte)0, outPos);
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool DockContextCalcDropPosForDocking(ImGuiWindowPtr target, ref ImGuiDockNode targetNode, ref ImGuiWindow payloadWindow, ImGuiDockNodePtr payloadNode, ImGuiDir splitDir, bool splitOuter, Vector2* outPos)
		{
			fixed (ImGuiDockNode* ptargetNode = &targetNode)
			{
				fixed (ImGuiWindow* ppayloadWindow = &payloadWindow)
				{
					byte ret = DockContextCalcDropPosForDockingNative(target, (ImGuiDockNode*)ptargetNode, (ImGuiWindow*)ppayloadWindow, payloadNode, splitDir, splitOuter ? (byte)1 : (byte)0, outPos);
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool DockContextCalcDropPosForDocking(ref ImGuiWindow target, ref ImGuiDockNode targetNode, ref ImGuiWindow payloadWindow, ImGuiDockNodePtr payloadNode, ImGuiDir splitDir, bool splitOuter, Vector2* outPos)
		{
			fixed (ImGuiWindow* ptarget = &target)
			{
				fixed (ImGuiDockNode* ptargetNode = &targetNode)
				{
					fixed (ImGuiWindow* ppayloadWindow = &payloadWindow)
					{
						byte ret = DockContextCalcDropPosForDockingNative((ImGuiWindow*)ptarget, (ImGuiDockNode*)ptargetNode, (ImGuiWindow*)ppayloadWindow, payloadNode, splitDir, splitOuter ? (byte)1 : (byte)0, outPos);
						return ret != 0;
					}
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool DockContextCalcDropPosForDocking(ImGuiWindowPtr target, ImGuiDockNodePtr targetNode, ImGuiWindowPtr payloadWindow, ref ImGuiDockNode payloadNode, ImGuiDir splitDir, bool splitOuter, Vector2* outPos)
		{
			fixed (ImGuiDockNode* ppayloadNode = &payloadNode)
			{
				byte ret = DockContextCalcDropPosForDockingNative(target, targetNode, payloadWindow, (ImGuiDockNode*)ppayloadNode, splitDir, splitOuter ? (byte)1 : (byte)0, outPos);
				return ret != 0;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool DockContextCalcDropPosForDocking(ref ImGuiWindow target, ImGuiDockNodePtr targetNode, ImGuiWindowPtr payloadWindow, ref ImGuiDockNode payloadNode, ImGuiDir splitDir, bool splitOuter, Vector2* outPos)
		{
			fixed (ImGuiWindow* ptarget = &target)
			{
				fixed (ImGuiDockNode* ppayloadNode = &payloadNode)
				{
					byte ret = DockContextCalcDropPosForDockingNative((ImGuiWindow*)ptarget, targetNode, payloadWindow, (ImGuiDockNode*)ppayloadNode, splitDir, splitOuter ? (byte)1 : (byte)0, outPos);
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool DockContextCalcDropPosForDocking(ImGuiWindowPtr target, ref ImGuiDockNode targetNode, ImGuiWindowPtr payloadWindow, ref ImGuiDockNode payloadNode, ImGuiDir splitDir, bool splitOuter, Vector2* outPos)
		{
			fixed (ImGuiDockNode* ptargetNode = &targetNode)
			{
				fixed (ImGuiDockNode* ppayloadNode = &payloadNode)
				{
					byte ret = DockContextCalcDropPosForDockingNative(target, (ImGuiDockNode*)ptargetNode, payloadWindow, (ImGuiDockNode*)ppayloadNode, splitDir, splitOuter ? (byte)1 : (byte)0, outPos);
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool DockContextCalcDropPosForDocking(ref ImGuiWindow target, ref ImGuiDockNode targetNode, ImGuiWindowPtr payloadWindow, ref ImGuiDockNode payloadNode, ImGuiDir splitDir, bool splitOuter, Vector2* outPos)
		{
			fixed (ImGuiWindow* ptarget = &target)
			{
				fixed (ImGuiDockNode* ptargetNode = &targetNode)
				{
					fixed (ImGuiDockNode* ppayloadNode = &payloadNode)
					{
						byte ret = DockContextCalcDropPosForDockingNative((ImGuiWindow*)ptarget, (ImGuiDockNode*)ptargetNode, payloadWindow, (ImGuiDockNode*)ppayloadNode, splitDir, splitOuter ? (byte)1 : (byte)0, outPos);
						return ret != 0;
					}
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool DockContextCalcDropPosForDocking(ImGuiWindowPtr target, ImGuiDockNodePtr targetNode, ref ImGuiWindow payloadWindow, ref ImGuiDockNode payloadNode, ImGuiDir splitDir, bool splitOuter, Vector2* outPos)
		{
			fixed (ImGuiWindow* ppayloadWindow = &payloadWindow)
			{
				fixed (ImGuiDockNode* ppayloadNode = &payloadNode)
				{
					byte ret = DockContextCalcDropPosForDockingNative(target, targetNode, (ImGuiWindow*)ppayloadWindow, (ImGuiDockNode*)ppayloadNode, splitDir, splitOuter ? (byte)1 : (byte)0, outPos);
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool DockContextCalcDropPosForDocking(ref ImGuiWindow target, ImGuiDockNodePtr targetNode, ref ImGuiWindow payloadWindow, ref ImGuiDockNode payloadNode, ImGuiDir splitDir, bool splitOuter, Vector2* outPos)
		{
			fixed (ImGuiWindow* ptarget = &target)
			{
				fixed (ImGuiWindow* ppayloadWindow = &payloadWindow)
				{
					fixed (ImGuiDockNode* ppayloadNode = &payloadNode)
					{
						byte ret = DockContextCalcDropPosForDockingNative((ImGuiWindow*)ptarget, targetNode, (ImGuiWindow*)ppayloadWindow, (ImGuiDockNode*)ppayloadNode, splitDir, splitOuter ? (byte)1 : (byte)0, outPos);
						return ret != 0;
					}
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool DockContextCalcDropPosForDocking(ImGuiWindowPtr target, ref ImGuiDockNode targetNode, ref ImGuiWindow payloadWindow, ref ImGuiDockNode payloadNode, ImGuiDir splitDir, bool splitOuter, Vector2* outPos)
		{
			fixed (ImGuiDockNode* ptargetNode = &targetNode)
			{
				fixed (ImGuiWindow* ppayloadWindow = &payloadWindow)
				{
					fixed (ImGuiDockNode* ppayloadNode = &payloadNode)
					{
						byte ret = DockContextCalcDropPosForDockingNative(target, (ImGuiDockNode*)ptargetNode, (ImGuiWindow*)ppayloadWindow, (ImGuiDockNode*)ppayloadNode, splitDir, splitOuter ? (byte)1 : (byte)0, outPos);
						return ret != 0;
					}
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool DockContextCalcDropPosForDocking(ref ImGuiWindow target, ref ImGuiDockNode targetNode, ref ImGuiWindow payloadWindow, ref ImGuiDockNode payloadNode, ImGuiDir splitDir, bool splitOuter, Vector2* outPos)
		{
			fixed (ImGuiWindow* ptarget = &target)
			{
				fixed (ImGuiDockNode* ptargetNode = &targetNode)
				{
					fixed (ImGuiWindow* ppayloadWindow = &payloadWindow)
					{
						fixed (ImGuiDockNode* ppayloadNode = &payloadNode)
						{
							byte ret = DockContextCalcDropPosForDockingNative((ImGuiWindow*)ptarget, (ImGuiDockNode*)ptargetNode, (ImGuiWindow*)ppayloadWindow, (ImGuiDockNode*)ppayloadNode, splitDir, splitOuter ? (byte)1 : (byte)0, outPos);
							return ret != 0;
						}
					}
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool DockContextCalcDropPosForDocking(ImGuiWindowPtr target, ImGuiDockNodePtr targetNode, ImGuiWindowPtr payloadWindow, ImGuiDockNodePtr payloadNode, ImGuiDir splitDir, bool splitOuter, ref Vector2 outPos)
		{
			fixed (Vector2* poutPos = &outPos)
			{
				byte ret = DockContextCalcDropPosForDockingNative(target, targetNode, payloadWindow, payloadNode, splitDir, splitOuter ? (byte)1 : (byte)0, (Vector2*)poutPos);
				return ret != 0;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool DockContextCalcDropPosForDocking(ref ImGuiWindow target, ImGuiDockNodePtr targetNode, ImGuiWindowPtr payloadWindow, ImGuiDockNodePtr payloadNode, ImGuiDir splitDir, bool splitOuter, ref Vector2 outPos)
		{
			fixed (ImGuiWindow* ptarget = &target)
			{
				fixed (Vector2* poutPos = &outPos)
				{
					byte ret = DockContextCalcDropPosForDockingNative((ImGuiWindow*)ptarget, targetNode, payloadWindow, payloadNode, splitDir, splitOuter ? (byte)1 : (byte)0, (Vector2*)poutPos);
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool DockContextCalcDropPosForDocking(ImGuiWindowPtr target, ref ImGuiDockNode targetNode, ImGuiWindowPtr payloadWindow, ImGuiDockNodePtr payloadNode, ImGuiDir splitDir, bool splitOuter, ref Vector2 outPos)
		{
			fixed (ImGuiDockNode* ptargetNode = &targetNode)
			{
				fixed (Vector2* poutPos = &outPos)
				{
					byte ret = DockContextCalcDropPosForDockingNative(target, (ImGuiDockNode*)ptargetNode, payloadWindow, payloadNode, splitDir, splitOuter ? (byte)1 : (byte)0, (Vector2*)poutPos);
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool DockContextCalcDropPosForDocking(ref ImGuiWindow target, ref ImGuiDockNode targetNode, ImGuiWindowPtr payloadWindow, ImGuiDockNodePtr payloadNode, ImGuiDir splitDir, bool splitOuter, ref Vector2 outPos)
		{
			fixed (ImGuiWindow* ptarget = &target)
			{
				fixed (ImGuiDockNode* ptargetNode = &targetNode)
				{
					fixed (Vector2* poutPos = &outPos)
					{
						byte ret = DockContextCalcDropPosForDockingNative((ImGuiWindow*)ptarget, (ImGuiDockNode*)ptargetNode, payloadWindow, payloadNode, splitDir, splitOuter ? (byte)1 : (byte)0, (Vector2*)poutPos);
						return ret != 0;
					}
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool DockContextCalcDropPosForDocking(ImGuiWindowPtr target, ImGuiDockNodePtr targetNode, ref ImGuiWindow payloadWindow, ImGuiDockNodePtr payloadNode, ImGuiDir splitDir, bool splitOuter, ref Vector2 outPos)
		{
			fixed (ImGuiWindow* ppayloadWindow = &payloadWindow)
			{
				fixed (Vector2* poutPos = &outPos)
				{
					byte ret = DockContextCalcDropPosForDockingNative(target, targetNode, (ImGuiWindow*)ppayloadWindow, payloadNode, splitDir, splitOuter ? (byte)1 : (byte)0, (Vector2*)poutPos);
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool DockContextCalcDropPosForDocking(ref ImGuiWindow target, ImGuiDockNodePtr targetNode, ref ImGuiWindow payloadWindow, ImGuiDockNodePtr payloadNode, ImGuiDir splitDir, bool splitOuter, ref Vector2 outPos)
		{
			fixed (ImGuiWindow* ptarget = &target)
			{
				fixed (ImGuiWindow* ppayloadWindow = &payloadWindow)
				{
					fixed (Vector2* poutPos = &outPos)
					{
						byte ret = DockContextCalcDropPosForDockingNative((ImGuiWindow*)ptarget, targetNode, (ImGuiWindow*)ppayloadWindow, payloadNode, splitDir, splitOuter ? (byte)1 : (byte)0, (Vector2*)poutPos);
						return ret != 0;
					}
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool DockContextCalcDropPosForDocking(ImGuiWindowPtr target, ref ImGuiDockNode targetNode, ref ImGuiWindow payloadWindow, ImGuiDockNodePtr payloadNode, ImGuiDir splitDir, bool splitOuter, ref Vector2 outPos)
		{
			fixed (ImGuiDockNode* ptargetNode = &targetNode)
			{
				fixed (ImGuiWindow* ppayloadWindow = &payloadWindow)
				{
					fixed (Vector2* poutPos = &outPos)
					{
						byte ret = DockContextCalcDropPosForDockingNative(target, (ImGuiDockNode*)ptargetNode, (ImGuiWindow*)ppayloadWindow, payloadNode, splitDir, splitOuter ? (byte)1 : (byte)0, (Vector2*)poutPos);
						return ret != 0;
					}
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool DockContextCalcDropPosForDocking(ref ImGuiWindow target, ref ImGuiDockNode targetNode, ref ImGuiWindow payloadWindow, ImGuiDockNodePtr payloadNode, ImGuiDir splitDir, bool splitOuter, ref Vector2 outPos)
		{
			fixed (ImGuiWindow* ptarget = &target)
			{
				fixed (ImGuiDockNode* ptargetNode = &targetNode)
				{
					fixed (ImGuiWindow* ppayloadWindow = &payloadWindow)
					{
						fixed (Vector2* poutPos = &outPos)
						{
							byte ret = DockContextCalcDropPosForDockingNative((ImGuiWindow*)ptarget, (ImGuiDockNode*)ptargetNode, (ImGuiWindow*)ppayloadWindow, payloadNode, splitDir, splitOuter ? (byte)1 : (byte)0, (Vector2*)poutPos);
							return ret != 0;
						}
					}
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool DockContextCalcDropPosForDocking(ImGuiWindowPtr target, ImGuiDockNodePtr targetNode, ImGuiWindowPtr payloadWindow, ref ImGuiDockNode payloadNode, ImGuiDir splitDir, bool splitOuter, ref Vector2 outPos)
		{
			fixed (ImGuiDockNode* ppayloadNode = &payloadNode)
			{
				fixed (Vector2* poutPos = &outPos)
				{
					byte ret = DockContextCalcDropPosForDockingNative(target, targetNode, payloadWindow, (ImGuiDockNode*)ppayloadNode, splitDir, splitOuter ? (byte)1 : (byte)0, (Vector2*)poutPos);
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool DockContextCalcDropPosForDocking(ref ImGuiWindow target, ImGuiDockNodePtr targetNode, ImGuiWindowPtr payloadWindow, ref ImGuiDockNode payloadNode, ImGuiDir splitDir, bool splitOuter, ref Vector2 outPos)
		{
			fixed (ImGuiWindow* ptarget = &target)
			{
				fixed (ImGuiDockNode* ppayloadNode = &payloadNode)
				{
					fixed (Vector2* poutPos = &outPos)
					{
						byte ret = DockContextCalcDropPosForDockingNative((ImGuiWindow*)ptarget, targetNode, payloadWindow, (ImGuiDockNode*)ppayloadNode, splitDir, splitOuter ? (byte)1 : (byte)0, (Vector2*)poutPos);
						return ret != 0;
					}
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool DockContextCalcDropPosForDocking(ImGuiWindowPtr target, ref ImGuiDockNode targetNode, ImGuiWindowPtr payloadWindow, ref ImGuiDockNode payloadNode, ImGuiDir splitDir, bool splitOuter, ref Vector2 outPos)
		{
			fixed (ImGuiDockNode* ptargetNode = &targetNode)
			{
				fixed (ImGuiDockNode* ppayloadNode = &payloadNode)
				{
					fixed (Vector2* poutPos = &outPos)
					{
						byte ret = DockContextCalcDropPosForDockingNative(target, (ImGuiDockNode*)ptargetNode, payloadWindow, (ImGuiDockNode*)ppayloadNode, splitDir, splitOuter ? (byte)1 : (byte)0, (Vector2*)poutPos);
						return ret != 0;
					}
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool DockContextCalcDropPosForDocking(ref ImGuiWindow target, ref ImGuiDockNode targetNode, ImGuiWindowPtr payloadWindow, ref ImGuiDockNode payloadNode, ImGuiDir splitDir, bool splitOuter, ref Vector2 outPos)
		{
			fixed (ImGuiWindow* ptarget = &target)
			{
				fixed (ImGuiDockNode* ptargetNode = &targetNode)
				{
					fixed (ImGuiDockNode* ppayloadNode = &payloadNode)
					{
						fixed (Vector2* poutPos = &outPos)
						{
							byte ret = DockContextCalcDropPosForDockingNative((ImGuiWindow*)ptarget, (ImGuiDockNode*)ptargetNode, payloadWindow, (ImGuiDockNode*)ppayloadNode, splitDir, splitOuter ? (byte)1 : (byte)0, (Vector2*)poutPos);
							return ret != 0;
						}
					}
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool DockContextCalcDropPosForDocking(ImGuiWindowPtr target, ImGuiDockNodePtr targetNode, ref ImGuiWindow payloadWindow, ref ImGuiDockNode payloadNode, ImGuiDir splitDir, bool splitOuter, ref Vector2 outPos)
		{
			fixed (ImGuiWindow* ppayloadWindow = &payloadWindow)
			{
				fixed (ImGuiDockNode* ppayloadNode = &payloadNode)
				{
					fixed (Vector2* poutPos = &outPos)
					{
						byte ret = DockContextCalcDropPosForDockingNative(target, targetNode, (ImGuiWindow*)ppayloadWindow, (ImGuiDockNode*)ppayloadNode, splitDir, splitOuter ? (byte)1 : (byte)0, (Vector2*)poutPos);
						return ret != 0;
					}
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool DockContextCalcDropPosForDocking(ref ImGuiWindow target, ImGuiDockNodePtr targetNode, ref ImGuiWindow payloadWindow, ref ImGuiDockNode payloadNode, ImGuiDir splitDir, bool splitOuter, ref Vector2 outPos)
		{
			fixed (ImGuiWindow* ptarget = &target)
			{
				fixed (ImGuiWindow* ppayloadWindow = &payloadWindow)
				{
					fixed (ImGuiDockNode* ppayloadNode = &payloadNode)
					{
						fixed (Vector2* poutPos = &outPos)
						{
							byte ret = DockContextCalcDropPosForDockingNative((ImGuiWindow*)ptarget, targetNode, (ImGuiWindow*)ppayloadWindow, (ImGuiDockNode*)ppayloadNode, splitDir, splitOuter ? (byte)1 : (byte)0, (Vector2*)poutPos);
							return ret != 0;
						}
					}
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool DockContextCalcDropPosForDocking(ImGuiWindowPtr target, ref ImGuiDockNode targetNode, ref ImGuiWindow payloadWindow, ref ImGuiDockNode payloadNode, ImGuiDir splitDir, bool splitOuter, ref Vector2 outPos)
		{
			fixed (ImGuiDockNode* ptargetNode = &targetNode)
			{
				fixed (ImGuiWindow* ppayloadWindow = &payloadWindow)
				{
					fixed (ImGuiDockNode* ppayloadNode = &payloadNode)
					{
						fixed (Vector2* poutPos = &outPos)
						{
							byte ret = DockContextCalcDropPosForDockingNative(target, (ImGuiDockNode*)ptargetNode, (ImGuiWindow*)ppayloadWindow, (ImGuiDockNode*)ppayloadNode, splitDir, splitOuter ? (byte)1 : (byte)0, (Vector2*)poutPos);
							return ret != 0;
						}
					}
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool DockContextCalcDropPosForDocking(ref ImGuiWindow target, ref ImGuiDockNode targetNode, ref ImGuiWindow payloadWindow, ref ImGuiDockNode payloadNode, ImGuiDir splitDir, bool splitOuter, ref Vector2 outPos)
		{
			fixed (ImGuiWindow* ptarget = &target)
			{
				fixed (ImGuiDockNode* ptargetNode = &targetNode)
				{
					fixed (ImGuiWindow* ppayloadWindow = &payloadWindow)
					{
						fixed (ImGuiDockNode* ppayloadNode = &payloadNode)
						{
							fixed (Vector2* poutPos = &outPos)
							{
								byte ret = DockContextCalcDropPosForDockingNative((ImGuiWindow*)ptarget, (ImGuiDockNode*)ptargetNode, (ImGuiWindow*)ppayloadWindow, (ImGuiDockNode*)ppayloadNode, splitDir, splitOuter ? (byte)1 : (byte)0, (Vector2*)poutPos);
								return ret != 0;
							}
						}
					}
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static ImGuiDockNode* DockContextFindNodeByIDNative(ImGuiContext* ctx, uint id)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<ImGuiContext*, uint, ImGuiDockNode*>)funcTable[1216])(ctx, id);
			#else
			return (ImGuiDockNode*)((delegate* unmanaged[Cdecl]<nint, uint, nint>)funcTable[1216])((nint)ctx, id);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static ImGuiDockNodePtr DockContextFindNodeByID(ImGuiContextPtr ctx, uint id)
		{
			ImGuiDockNodePtr ret = DockContextFindNodeByIDNative(ctx, id);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static ImGuiDockNodePtr DockContextFindNodeByID(ref ImGuiContext ctx, uint id)
		{
			fixed (ImGuiContext* pctx = &ctx)
			{
				ImGuiDockNodePtr ret = DockContextFindNodeByIDNative((ImGuiContext*)pctx, id);
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void DockNodeWindowMenuHandler_DefaultNative(ImGuiContext* ctx, ImGuiDockNode* node, ImGuiTabBar* tabBar)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<ImGuiContext*, ImGuiDockNode*, ImGuiTabBar*, void>)funcTable[1217])(ctx, node, tabBar);
			#else
			((delegate* unmanaged[Cdecl]<nint, nint, nint, void>)funcTable[1217])((nint)ctx, (nint)node, (nint)tabBar);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void DockNodeWindowMenuHandler_Default(ImGuiContextPtr ctx, ImGuiDockNodePtr node, ImGuiTabBarPtr tabBar)
		{
			DockNodeWindowMenuHandler_DefaultNative(ctx, node, tabBar);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void DockNodeWindowMenuHandler_Default(ref ImGuiContext ctx, ImGuiDockNodePtr node, ImGuiTabBarPtr tabBar)
		{
			fixed (ImGuiContext* pctx = &ctx)
			{
				DockNodeWindowMenuHandler_DefaultNative((ImGuiContext*)pctx, node, tabBar);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void DockNodeWindowMenuHandler_Default(ImGuiContextPtr ctx, ref ImGuiDockNode node, ImGuiTabBarPtr tabBar)
		{
			fixed (ImGuiDockNode* pnode = &node)
			{
				DockNodeWindowMenuHandler_DefaultNative(ctx, (ImGuiDockNode*)pnode, tabBar);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void DockNodeWindowMenuHandler_Default(ref ImGuiContext ctx, ref ImGuiDockNode node, ImGuiTabBarPtr tabBar)
		{
			fixed (ImGuiContext* pctx = &ctx)
			{
				fixed (ImGuiDockNode* pnode = &node)
				{
					DockNodeWindowMenuHandler_DefaultNative((ImGuiContext*)pctx, (ImGuiDockNode*)pnode, tabBar);
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void DockNodeWindowMenuHandler_Default(ImGuiContextPtr ctx, ImGuiDockNodePtr node, ref ImGuiTabBar tabBar)
		{
			fixed (ImGuiTabBar* ptabBar = &tabBar)
			{
				DockNodeWindowMenuHandler_DefaultNative(ctx, node, (ImGuiTabBar*)ptabBar);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void DockNodeWindowMenuHandler_Default(ref ImGuiContext ctx, ImGuiDockNodePtr node, ref ImGuiTabBar tabBar)
		{
			fixed (ImGuiContext* pctx = &ctx)
			{
				fixed (ImGuiTabBar* ptabBar = &tabBar)
				{
					DockNodeWindowMenuHandler_DefaultNative((ImGuiContext*)pctx, node, (ImGuiTabBar*)ptabBar);
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void DockNodeWindowMenuHandler_Default(ImGuiContextPtr ctx, ref ImGuiDockNode node, ref ImGuiTabBar tabBar)
		{
			fixed (ImGuiDockNode* pnode = &node)
			{
				fixed (ImGuiTabBar* ptabBar = &tabBar)
				{
					DockNodeWindowMenuHandler_DefaultNative(ctx, (ImGuiDockNode*)pnode, (ImGuiTabBar*)ptabBar);
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void DockNodeWindowMenuHandler_Default(ref ImGuiContext ctx, ref ImGuiDockNode node, ref ImGuiTabBar tabBar)
		{
			fixed (ImGuiContext* pctx = &ctx)
			{
				fixed (ImGuiDockNode* pnode = &node)
				{
					fixed (ImGuiTabBar* ptabBar = &tabBar)
					{
						DockNodeWindowMenuHandler_DefaultNative((ImGuiContext*)pctx, (ImGuiDockNode*)pnode, (ImGuiTabBar*)ptabBar);
					}
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte DockNodeBeginAmendTabBarNative(ImGuiDockNode* node)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<ImGuiDockNode*, byte>)funcTable[1218])(node);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<nint, byte>)funcTable[1218])((nint)node);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool DockNodeBeginAmendTabBar(ImGuiDockNodePtr node)
		{
			byte ret = DockNodeBeginAmendTabBarNative(node);
			return ret != 0;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool DockNodeBeginAmendTabBar(ref ImGuiDockNode node)
		{
			fixed (ImGuiDockNode* pnode = &node)
			{
				byte ret = DockNodeBeginAmendTabBarNative((ImGuiDockNode*)pnode);
				return ret != 0;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void DockNodeEndAmendTabBarNative()
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<void>)funcTable[1219])();
			#else
			((delegate* unmanaged[Cdecl]<void>)funcTable[1219])();
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void DockNodeEndAmendTabBar()
		{
			DockNodeEndAmendTabBarNative();
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static ImGuiDockNode* DockNodeGetRootNodeNative(ImGuiDockNode* node)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<ImGuiDockNode*, ImGuiDockNode*>)funcTable[1220])(node);
			#else
			return (ImGuiDockNode*)((delegate* unmanaged[Cdecl]<nint, nint>)funcTable[1220])((nint)node);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static ImGuiDockNodePtr DockNodeGetRootNode(ImGuiDockNodePtr node)
		{
			ImGuiDockNodePtr ret = DockNodeGetRootNodeNative(node);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static ImGuiDockNodePtr DockNodeGetRootNode(ref ImGuiDockNode node)
		{
			fixed (ImGuiDockNode* pnode = &node)
			{
				ImGuiDockNodePtr ret = DockNodeGetRootNodeNative((ImGuiDockNode*)pnode);
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte DockNodeIsInHierarchyOfNative(ImGuiDockNode* node, ImGuiDockNode* parent)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<ImGuiDockNode*, ImGuiDockNode*, byte>)funcTable[1221])(node, parent);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<nint, nint, byte>)funcTable[1221])((nint)node, (nint)parent);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool DockNodeIsInHierarchyOf(ImGuiDockNodePtr node, ImGuiDockNodePtr parent)
		{
			byte ret = DockNodeIsInHierarchyOfNative(node, parent);
			return ret != 0;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool DockNodeIsInHierarchyOf(ref ImGuiDockNode node, ImGuiDockNodePtr parent)
		{
			fixed (ImGuiDockNode* pnode = &node)
			{
				byte ret = DockNodeIsInHierarchyOfNative((ImGuiDockNode*)pnode, parent);
				return ret != 0;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool DockNodeIsInHierarchyOf(ImGuiDockNodePtr node, ref ImGuiDockNode parent)
		{
			fixed (ImGuiDockNode* pparent = &parent)
			{
				byte ret = DockNodeIsInHierarchyOfNative(node, (ImGuiDockNode*)pparent);
				return ret != 0;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool DockNodeIsInHierarchyOf(ref ImGuiDockNode node, ref ImGuiDockNode parent)
		{
			fixed (ImGuiDockNode* pnode = &node)
			{
				fixed (ImGuiDockNode* pparent = &parent)
				{
					byte ret = DockNodeIsInHierarchyOfNative((ImGuiDockNode*)pnode, (ImGuiDockNode*)pparent);
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int DockNodeGetDepthNative(ImGuiDockNode* node)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<ImGuiDockNode*, int>)funcTable[1222])(node);
			#else
			return (int)((delegate* unmanaged[Cdecl]<nint, int>)funcTable[1222])((nint)node);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static int DockNodeGetDepth(ImGuiDockNodePtr node)
		{
			int ret = DockNodeGetDepthNative(node);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static int DockNodeGetDepth(ref ImGuiDockNode node)
		{
			fixed (ImGuiDockNode* pnode = &node)
			{
				int ret = DockNodeGetDepthNative((ImGuiDockNode*)pnode);
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static uint DockNodeGetWindowMenuButtonIdNative(ImGuiDockNode* node)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<ImGuiDockNode*, uint>)funcTable[1223])(node);
			#else
			return (uint)((delegate* unmanaged[Cdecl]<nint, uint>)funcTable[1223])((nint)node);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static uint DockNodeGetWindowMenuButtonId(ImGuiDockNodePtr node)
		{
			uint ret = DockNodeGetWindowMenuButtonIdNative(node);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static uint DockNodeGetWindowMenuButtonId(ref ImGuiDockNode node)
		{
			fixed (ImGuiDockNode* pnode = &node)
			{
				uint ret = DockNodeGetWindowMenuButtonIdNative((ImGuiDockNode*)pnode);
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static ImGuiDockNode* GetWindowDockNodeNative()
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<ImGuiDockNode*>)funcTable[1224])();
			#else
			return (ImGuiDockNode*)((delegate* unmanaged[Cdecl]<nint>)funcTable[1224])();
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static ImGuiDockNodePtr GetWindowDockNode()
		{
			ImGuiDockNodePtr ret = GetWindowDockNodeNative();
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte GetWindowAlwaysWantOwnTabBarNative(ImGuiWindow* window)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<ImGuiWindow*, byte>)funcTable[1225])(window);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<nint, byte>)funcTable[1225])((nint)window);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool GetWindowAlwaysWantOwnTabBar(ImGuiWindowPtr window)
		{
			byte ret = GetWindowAlwaysWantOwnTabBarNative(window);
			return ret != 0;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool GetWindowAlwaysWantOwnTabBar(ref ImGuiWindow window)
		{
			fixed (ImGuiWindow* pwindow = &window)
			{
				byte ret = GetWindowAlwaysWantOwnTabBarNative((ImGuiWindow*)pwindow);
				return ret != 0;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void BeginDockedNative(ImGuiWindow* window, bool* pOpen)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<ImGuiWindow*, bool*, void>)funcTable[1226])(window, pOpen);
			#else
			((delegate* unmanaged[Cdecl]<nint, nint, void>)funcTable[1226])((nint)window, (nint)pOpen);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void BeginDocked(ImGuiWindowPtr window, bool* pOpen)
		{
			BeginDockedNative(window, pOpen);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void BeginDocked(ref ImGuiWindow window, bool* pOpen)
		{
			fixed (ImGuiWindow* pwindow = &window)
			{
				BeginDockedNative((ImGuiWindow*)pwindow, pOpen);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void BeginDocked(ImGuiWindowPtr window, ref bool pOpen)
		{
			fixed (bool* ppOpen = &pOpen)
			{
				BeginDockedNative(window, (bool*)ppOpen);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void BeginDocked(ref ImGuiWindow window, ref bool pOpen)
		{
			fixed (ImGuiWindow* pwindow = &window)
			{
				fixed (bool* ppOpen = &pOpen)
				{
					BeginDockedNative((ImGuiWindow*)pwindow, (bool*)ppOpen);
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void BeginDockableDragDropSourceNative(ImGuiWindow* window)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<ImGuiWindow*, void>)funcTable[1227])(window);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)funcTable[1227])((nint)window);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void BeginDockableDragDropSource(ImGuiWindowPtr window)
		{
			BeginDockableDragDropSourceNative(window);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void BeginDockableDragDropSource(ref ImGuiWindow window)
		{
			fixed (ImGuiWindow* pwindow = &window)
			{
				BeginDockableDragDropSourceNative((ImGuiWindow*)pwindow);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void BeginDockableDragDropTargetNative(ImGuiWindow* window)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<ImGuiWindow*, void>)funcTable[1228])(window);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)funcTable[1228])((nint)window);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void BeginDockableDragDropTarget(ImGuiWindowPtr window)
		{
			BeginDockableDragDropTargetNative(window);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void BeginDockableDragDropTarget(ref ImGuiWindow window)
		{
			fixed (ImGuiWindow* pwindow = &window)
			{
				BeginDockableDragDropTargetNative((ImGuiWindow*)pwindow);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void SetWindowDockNative(ImGuiWindow* window, uint dockId, ImGuiCond cond)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<ImGuiWindow*, uint, ImGuiCond, void>)funcTable[1229])(window, dockId, cond);
			#else
			((delegate* unmanaged[Cdecl]<nint, uint, ImGuiCond, void>)funcTable[1229])((nint)window, dockId, cond);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void SetWindowDock(ImGuiWindowPtr window, uint dockId, ImGuiCond cond)
		{
			SetWindowDockNative(window, dockId, cond);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void SetWindowDock(ref ImGuiWindow window, uint dockId, ImGuiCond cond)
		{
			fixed (ImGuiWindow* pwindow = &window)
			{
				SetWindowDockNative((ImGuiWindow*)pwindow, dockId, cond);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void DockBuilderDockWindowNative(byte* windowName, uint nodeId)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<byte*, uint, void>)funcTable[1230])(windowName, nodeId);
			#else
			((delegate* unmanaged[Cdecl]<nint, uint, void>)funcTable[1230])((nint)windowName, nodeId);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void DockBuilderDockWindow(byte* windowName, uint nodeId)
		{
			DockBuilderDockWindowNative(windowName, nodeId);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void DockBuilderDockWindow(ref byte windowName, uint nodeId)
		{
			fixed (byte* pwindowName = &windowName)
			{
				DockBuilderDockWindowNative((byte*)pwindowName, nodeId);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void DockBuilderDockWindow(ReadOnlySpan<byte> windowName, uint nodeId)
		{
			fixed (byte* pwindowName = windowName)
			{
				DockBuilderDockWindowNative((byte*)pwindowName, nodeId);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void DockBuilderDockWindow(string windowName, uint nodeId)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (windowName != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(windowName);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(windowName, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			DockBuilderDockWindowNative(pStr0, nodeId);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static ImGuiDockNode* DockBuilderGetNodeNative(uint nodeId)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<uint, ImGuiDockNode*>)funcTable[1231])(nodeId);
			#else
			return (ImGuiDockNode*)((delegate* unmanaged[Cdecl]<uint, nint>)funcTable[1231])(nodeId);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static ImGuiDockNodePtr DockBuilderGetNode(uint nodeId)
		{
			ImGuiDockNodePtr ret = DockBuilderGetNodeNative(nodeId);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static ImGuiDockNode* DockBuilderGetCentralNodeNative(uint nodeId)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<uint, ImGuiDockNode*>)funcTable[1232])(nodeId);
			#else
			return (ImGuiDockNode*)((delegate* unmanaged[Cdecl]<uint, nint>)funcTable[1232])(nodeId);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static ImGuiDockNodePtr DockBuilderGetCentralNode(uint nodeId)
		{
			ImGuiDockNodePtr ret = DockBuilderGetCentralNodeNative(nodeId);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static uint DockBuilderAddNodeNative(uint nodeId, ImGuiDockNodeFlags flags)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<uint, ImGuiDockNodeFlags, uint>)funcTable[1233])(nodeId, flags);
			#else
			return (uint)((delegate* unmanaged[Cdecl]<uint, ImGuiDockNodeFlags, uint>)funcTable[1233])(nodeId, flags);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static uint DockBuilderAddNode(uint nodeId, ImGuiDockNodeFlags flags)
		{
			uint ret = DockBuilderAddNodeNative(nodeId, flags);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static uint DockBuilderAddNode(uint nodeId)
		{
			uint ret = DockBuilderAddNodeNative(nodeId, (ImGuiDockNodeFlags)(0));
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static uint DockBuilderAddNode()
		{
			uint ret = DockBuilderAddNodeNative((uint)(0), (ImGuiDockNodeFlags)(0));
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static uint DockBuilderAddNode(ImGuiDockNodeFlags flags)
		{
			uint ret = DockBuilderAddNodeNative((uint)(0), flags);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void DockBuilderRemoveNodeNative(uint nodeId)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, void>)funcTable[1234])(nodeId);
			#else
			((delegate* unmanaged[Cdecl]<uint, void>)funcTable[1234])(nodeId);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void DockBuilderRemoveNode(uint nodeId)
		{
			DockBuilderRemoveNodeNative(nodeId);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void DockBuilderRemoveNodeDockedWindowsNative(uint nodeId, byte clearSettingsRefs)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, byte, void>)funcTable[1235])(nodeId, clearSettingsRefs);
			#else
			((delegate* unmanaged[Cdecl]<uint, byte, void>)funcTable[1235])(nodeId, clearSettingsRefs);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void DockBuilderRemoveNodeDockedWindows(uint nodeId, bool clearSettingsRefs)
		{
			DockBuilderRemoveNodeDockedWindowsNative(nodeId, clearSettingsRefs ? (byte)1 : (byte)0);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void DockBuilderRemoveNodeDockedWindows(uint nodeId)
		{
			DockBuilderRemoveNodeDockedWindowsNative(nodeId, (byte)(1));
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void DockBuilderRemoveNodeChildNodesNative(uint nodeId)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, void>)funcTable[1236])(nodeId);
			#else
			((delegate* unmanaged[Cdecl]<uint, void>)funcTable[1236])(nodeId);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void DockBuilderRemoveNodeChildNodes(uint nodeId)
		{
			DockBuilderRemoveNodeChildNodesNative(nodeId);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void DockBuilderSetNodePosNative(uint nodeId, Vector2 pos)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, Vector2, void>)funcTable[1237])(nodeId, pos);
			#else
			((delegate* unmanaged[Cdecl]<uint, Vector2, void>)funcTable[1237])(nodeId, pos);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void DockBuilderSetNodePos(uint nodeId, Vector2 pos)
		{
			DockBuilderSetNodePosNative(nodeId, pos);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void DockBuilderSetNodeSizeNative(uint nodeId, Vector2 size)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, Vector2, void>)funcTable[1238])(nodeId, size);
			#else
			((delegate* unmanaged[Cdecl]<uint, Vector2, void>)funcTable[1238])(nodeId, size);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void DockBuilderSetNodeSize(uint nodeId, Vector2 size)
		{
			DockBuilderSetNodeSizeNative(nodeId, size);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static uint DockBuilderSplitNodeNative(uint nodeId, ImGuiDir splitDir, float sizeRatioForNodeAtDir, uint* outIdAtDir, uint* outIdAtOppositeDir)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<uint, ImGuiDir, float, uint*, uint*, uint>)funcTable[1239])(nodeId, splitDir, sizeRatioForNodeAtDir, outIdAtDir, outIdAtOppositeDir);
			#else
			return (uint)((delegate* unmanaged[Cdecl]<uint, ImGuiDir, float, nint, nint, uint>)funcTable[1239])(nodeId, splitDir, sizeRatioForNodeAtDir, (nint)outIdAtDir, (nint)outIdAtOppositeDir);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static uint DockBuilderSplitNode(uint nodeId, ImGuiDir splitDir, float sizeRatioForNodeAtDir, uint* outIdAtDir, uint* outIdAtOppositeDir)
		{
			uint ret = DockBuilderSplitNodeNative(nodeId, splitDir, sizeRatioForNodeAtDir, outIdAtDir, outIdAtOppositeDir);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void DockBuilderCopyDockSpaceNative(uint srcDockspaceId, uint dstDockspaceId, ImVector<ConstPointer<byte>>* inWindowRemapPairs)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, uint, ImVector<ConstPointer<byte>>*, void>)funcTable[1240])(srcDockspaceId, dstDockspaceId, inWindowRemapPairs);
			#else
			((delegate* unmanaged[Cdecl]<uint, uint, nint, void>)funcTable[1240])(srcDockspaceId, dstDockspaceId, (nint)inWindowRemapPairs);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void DockBuilderCopyDockSpace(uint srcDockspaceId, uint dstDockspaceId, ImVector<ConstPointer<byte>>* inWindowRemapPairs)
		{
			DockBuilderCopyDockSpaceNative(srcDockspaceId, dstDockspaceId, inWindowRemapPairs);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void DockBuilderCopyDockSpace(uint srcDockspaceId, uint dstDockspaceId, ref ImVector<ConstPointer<byte>> inWindowRemapPairs)
		{
			fixed (ImVector<ConstPointer<byte>>* pinWindowRemapPairs = &inWindowRemapPairs)
			{
				DockBuilderCopyDockSpaceNative(srcDockspaceId, dstDockspaceId, (ImVector<ConstPointer<byte>>*)pinWindowRemapPairs);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void DockBuilderCopyNodeNative(uint srcNodeId, uint dstNodeId, ImVector<uint>* outNodeRemapPairs)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, uint, ImVector<uint>*, void>)funcTable[1241])(srcNodeId, dstNodeId, outNodeRemapPairs);
			#else
			((delegate* unmanaged[Cdecl]<uint, uint, nint, void>)funcTable[1241])(srcNodeId, dstNodeId, (nint)outNodeRemapPairs);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void DockBuilderCopyNode(uint srcNodeId, uint dstNodeId, ImVector<uint>* outNodeRemapPairs)
		{
			DockBuilderCopyNodeNative(srcNodeId, dstNodeId, outNodeRemapPairs);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void DockBuilderCopyNode(uint srcNodeId, uint dstNodeId, ref ImVector<uint> outNodeRemapPairs)
		{
			fixed (ImVector<uint>* poutNodeRemapPairs = &outNodeRemapPairs)
			{
				DockBuilderCopyNodeNative(srcNodeId, dstNodeId, (ImVector<uint>*)poutNodeRemapPairs);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void DockBuilderCopyWindowSettingsNative(byte* srcName, byte* dstName)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<byte*, byte*, void>)funcTable[1242])(srcName, dstName);
			#else
			((delegate* unmanaged[Cdecl]<nint, nint, void>)funcTable[1242])((nint)srcName, (nint)dstName);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void DockBuilderCopyWindowSettings(byte* srcName, byte* dstName)
		{
			DockBuilderCopyWindowSettingsNative(srcName, dstName);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void DockBuilderCopyWindowSettings(ref byte srcName, byte* dstName)
		{
			fixed (byte* psrcName = &srcName)
			{
				DockBuilderCopyWindowSettingsNative((byte*)psrcName, dstName);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void DockBuilderCopyWindowSettings(ReadOnlySpan<byte> srcName, byte* dstName)
		{
			fixed (byte* psrcName = srcName)
			{
				DockBuilderCopyWindowSettingsNative((byte*)psrcName, dstName);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void DockBuilderCopyWindowSettings(string srcName, byte* dstName)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (srcName != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(srcName);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(srcName, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			DockBuilderCopyWindowSettingsNative(pStr0, dstName);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void DockBuilderCopyWindowSettings(byte* srcName, ref byte dstName)
		{
			fixed (byte* pdstName = &dstName)
			{
				DockBuilderCopyWindowSettingsNative(srcName, (byte*)pdstName);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void DockBuilderCopyWindowSettings(byte* srcName, ReadOnlySpan<byte> dstName)
		{
			fixed (byte* pdstName = dstName)
			{
				DockBuilderCopyWindowSettingsNative(srcName, (byte*)pdstName);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void DockBuilderCopyWindowSettings(byte* srcName, string dstName)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (dstName != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(dstName);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(dstName, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			DockBuilderCopyWindowSettingsNative(srcName, pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void DockBuilderCopyWindowSettings(ref byte srcName, ref byte dstName)
		{
			fixed (byte* psrcName = &srcName)
			{
				fixed (byte* pdstName = &dstName)
				{
					DockBuilderCopyWindowSettingsNative((byte*)psrcName, (byte*)pdstName);
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void DockBuilderCopyWindowSettings(ReadOnlySpan<byte> srcName, ReadOnlySpan<byte> dstName)
		{
			fixed (byte* psrcName = srcName)
			{
				fixed (byte* pdstName = dstName)
				{
					DockBuilderCopyWindowSettingsNative((byte*)psrcName, (byte*)pdstName);
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void DockBuilderCopyWindowSettings(string srcName, string dstName)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (srcName != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(srcName);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(srcName, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (dstName != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(dstName);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(dstName, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			DockBuilderCopyWindowSettingsNative(pStr0, pStr1);
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void DockBuilderCopyWindowSettings(ref byte srcName, ReadOnlySpan<byte> dstName)
		{
			fixed (byte* psrcName = &srcName)
			{
				fixed (byte* pdstName = dstName)
				{
					DockBuilderCopyWindowSettingsNative((byte*)psrcName, (byte*)pdstName);
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void DockBuilderCopyWindowSettings(ref byte srcName, string dstName)
		{
			fixed (byte* psrcName = &srcName)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (dstName != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(dstName);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(dstName, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				DockBuilderCopyWindowSettingsNative((byte*)psrcName, pStr0);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void DockBuilderCopyWindowSettings(ReadOnlySpan<byte> srcName, ref byte dstName)
		{
			fixed (byte* psrcName = srcName)
			{
				fixed (byte* pdstName = &dstName)
				{
					DockBuilderCopyWindowSettingsNative((byte*)psrcName, (byte*)pdstName);
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void DockBuilderCopyWindowSettings(ReadOnlySpan<byte> srcName, string dstName)
		{
			fixed (byte* psrcName = srcName)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (dstName != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(dstName);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(dstName, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				DockBuilderCopyWindowSettingsNative((byte*)psrcName, pStr0);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void DockBuilderCopyWindowSettings(string srcName, ref byte dstName)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (srcName != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(srcName);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(srcName, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (byte* pdstName = &dstName)
			{
				DockBuilderCopyWindowSettingsNative(pStr0, (byte*)pdstName);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void DockBuilderCopyWindowSettings(string srcName, ReadOnlySpan<byte> dstName)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (srcName != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(srcName);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(srcName, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (byte* pdstName = dstName)
			{
				DockBuilderCopyWindowSettingsNative(pStr0, (byte*)pdstName);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void DockBuilderFinishNative(uint nodeId)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, void>)funcTable[1243])(nodeId);
			#else
			((delegate* unmanaged[Cdecl]<uint, void>)funcTable[1243])(nodeId);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void DockBuilderFinish(uint nodeId)
		{
			DockBuilderFinishNative(nodeId);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void PushFocusScopeNative(uint id)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, void>)funcTable[1244])(id);
			#else
			((delegate* unmanaged[Cdecl]<uint, void>)funcTable[1244])(id);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void PushFocusScope(uint id)
		{
			PushFocusScopeNative(id);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void PopFocusScopeNative()
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<void>)funcTable[1245])();
			#else
			((delegate* unmanaged[Cdecl]<void>)funcTable[1245])();
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void PopFocusScope()
		{
			PopFocusScopeNative();
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static uint GetCurrentFocusScopeNative()
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<uint>)funcTable[1246])();
			#else
			return (uint)((delegate* unmanaged[Cdecl]<uint>)funcTable[1246])();
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static uint GetCurrentFocusScope()
		{
			uint ret = GetCurrentFocusScopeNative();
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte IsDragDropActiveNative()
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<byte>)funcTable[1247])();
			#else
			return (byte)((delegate* unmanaged[Cdecl]<byte>)funcTable[1247])();
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool IsDragDropActive()
		{
			byte ret = IsDragDropActiveNative();
			return ret != 0;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte BeginDragDropTargetCustomNative(ImRect bb, uint id)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<ImRect, uint, byte>)funcTable[1248])(bb, id);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<ImRect, uint, byte>)funcTable[1248])(bb, id);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool BeginDragDropTargetCustom(ImRect bb, uint id)
		{
			byte ret = BeginDragDropTargetCustomNative(bb, id);
			return ret != 0;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void ClearDragDropNative()
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<void>)funcTable[1249])();
			#else
			((delegate* unmanaged[Cdecl]<void>)funcTable[1249])();
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void ClearDragDrop()
		{
			ClearDragDropNative();
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte IsDragDropPayloadBeingAcceptedNative()
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<byte>)funcTable[1250])();
			#else
			return (byte)((delegate* unmanaged[Cdecl]<byte>)funcTable[1250])();
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool IsDragDropPayloadBeingAccepted()
		{
			byte ret = IsDragDropPayloadBeingAcceptedNative();
			return ret != 0;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void RenderDragDropTargetRectNative(ImRect bb, ImRect itemClipRect)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<ImRect, ImRect, void>)funcTable[1251])(bb, itemClipRect);
			#else
			((delegate* unmanaged[Cdecl]<ImRect, ImRect, void>)funcTable[1251])(bb, itemClipRect);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void RenderDragDropTargetRect(ImRect bb, ImRect itemClipRect)
		{
			RenderDragDropTargetRectNative(bb, itemClipRect);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static ImGuiTypingSelectRequest* GetTypingSelectRequestNative(ImGuiTypingSelectFlags flags)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<ImGuiTypingSelectFlags, ImGuiTypingSelectRequest*>)funcTable[1252])(flags);
			#else
			return (ImGuiTypingSelectRequest*)((delegate* unmanaged[Cdecl]<ImGuiTypingSelectFlags, nint>)funcTable[1252])(flags);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static ImGuiTypingSelectRequestPtr GetTypingSelectRequest(ImGuiTypingSelectFlags flags)
		{
			ImGuiTypingSelectRequestPtr ret = GetTypingSelectRequestNative(flags);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static ImGuiTypingSelectRequestPtr GetTypingSelectRequest()
		{
			ImGuiTypingSelectRequestPtr ret = GetTypingSelectRequestNative((ImGuiTypingSelectFlags)(ImGuiTypingSelectFlags.None));
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int TypingSelectFindMatchNative(ImGuiTypingSelectRequest* req, int itemsCount, delegate*<ImGuiTypingSelectRequest*, int, delegate*<void*, int, byte*>, void*, int, byte*> getItemNameFunc, void* userData, int navItemIdx)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<ImGuiTypingSelectRequest*, int, delegate*<ImGuiTypingSelectRequest*, int, delegate*<void*, int, byte*>, void*, int, byte*>, void*, int, int>)funcTable[1253])(req, itemsCount, getItemNameFunc, userData, navItemIdx);
			#else
			return (int)((delegate* unmanaged[Cdecl]<nint, int, nint, nint, int, int>)funcTable[1253])((nint)req, itemsCount, (nint)getItemNameFunc, (nint)userData, navItemIdx);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static int TypingSelectFindMatch(ImGuiTypingSelectRequestPtr req, int itemsCount, delegate*<ImGuiTypingSelectRequest*, int, delegate*<void*, int, byte*>, void*, int, byte*> getItemNameFunc, void* userData, int navItemIdx)
		{
			int ret = TypingSelectFindMatchNative(req, itemsCount, getItemNameFunc, userData, navItemIdx);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static int TypingSelectFindMatch(ref ImGuiTypingSelectRequest req, int itemsCount, delegate*<ImGuiTypingSelectRequest*, int, delegate*<void*, int, byte*>, void*, int, byte*> getItemNameFunc, void* userData, int navItemIdx)
		{
			fixed (ImGuiTypingSelectRequest* preq = &req)
			{
				int ret = TypingSelectFindMatchNative((ImGuiTypingSelectRequest*)preq, itemsCount, getItemNameFunc, userData, navItemIdx);
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int TypingSelectFindNextSingleCharMatchNative(ImGuiTypingSelectRequest* req, int itemsCount, delegate*<ImGuiTypingSelectRequest*, int, delegate*<void*, int, byte*>, void*, int, byte*> getItemNameFunc, void* userData, int navItemIdx)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<ImGuiTypingSelectRequest*, int, delegate*<ImGuiTypingSelectRequest*, int, delegate*<void*, int, byte*>, void*, int, byte*>, void*, int, int>)funcTable[1254])(req, itemsCount, getItemNameFunc, userData, navItemIdx);
			#else
			return (int)((delegate* unmanaged[Cdecl]<nint, int, nint, nint, int, int>)funcTable[1254])((nint)req, itemsCount, (nint)getItemNameFunc, (nint)userData, navItemIdx);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static int TypingSelectFindNextSingleCharMatch(ImGuiTypingSelectRequestPtr req, int itemsCount, delegate*<ImGuiTypingSelectRequest*, int, delegate*<void*, int, byte*>, void*, int, byte*> getItemNameFunc, void* userData, int navItemIdx)
		{
			int ret = TypingSelectFindNextSingleCharMatchNative(req, itemsCount, getItemNameFunc, userData, navItemIdx);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static int TypingSelectFindNextSingleCharMatch(ref ImGuiTypingSelectRequest req, int itemsCount, delegate*<ImGuiTypingSelectRequest*, int, delegate*<void*, int, byte*>, void*, int, byte*> getItemNameFunc, void* userData, int navItemIdx)
		{
			fixed (ImGuiTypingSelectRequest* preq = &req)
			{
				int ret = TypingSelectFindNextSingleCharMatchNative((ImGuiTypingSelectRequest*)preq, itemsCount, getItemNameFunc, userData, navItemIdx);
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int TypingSelectFindBestLeadingMatchNative(ImGuiTypingSelectRequest* req, int itemsCount, delegate*<ImGuiTypingSelectRequest*, int, delegate*<void*, int, byte*>, void*, byte*> getItemNameFunc, void* userData)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<ImGuiTypingSelectRequest*, int, delegate*<ImGuiTypingSelectRequest*, int, delegate*<void*, int, byte*>, void*, byte*>, void*, int>)funcTable[1255])(req, itemsCount, getItemNameFunc, userData);
			#else
			return (int)((delegate* unmanaged[Cdecl]<nint, int, nint, nint, int>)funcTable[1255])((nint)req, itemsCount, (nint)getItemNameFunc, (nint)userData);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static int TypingSelectFindBestLeadingMatch(ImGuiTypingSelectRequestPtr req, int itemsCount, delegate*<ImGuiTypingSelectRequest*, int, delegate*<void*, int, byte*>, void*, byte*> getItemNameFunc, void* userData)
		{
			int ret = TypingSelectFindBestLeadingMatchNative(req, itemsCount, getItemNameFunc, userData);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static int TypingSelectFindBestLeadingMatch(ref ImGuiTypingSelectRequest req, int itemsCount, delegate*<ImGuiTypingSelectRequest*, int, delegate*<void*, int, byte*>, void*, byte*> getItemNameFunc, void* userData)
		{
			fixed (ImGuiTypingSelectRequest* preq = &req)
			{
				int ret = TypingSelectFindBestLeadingMatchNative((ImGuiTypingSelectRequest*)preq, itemsCount, getItemNameFunc, userData);
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte BeginBoxSelectNative(ImRect scopeRect, ImGuiWindow* window, uint boxSelectId, ImGuiMultiSelectFlags msFlags)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<ImRect, ImGuiWindow*, uint, ImGuiMultiSelectFlags, byte>)funcTable[1256])(scopeRect, window, boxSelectId, msFlags);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<ImRect, nint, uint, ImGuiMultiSelectFlags, byte>)funcTable[1256])(scopeRect, (nint)window, boxSelectId, msFlags);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool BeginBoxSelect(ImRect scopeRect, ImGuiWindowPtr window, uint boxSelectId, ImGuiMultiSelectFlags msFlags)
		{
			byte ret = BeginBoxSelectNative(scopeRect, window, boxSelectId, msFlags);
			return ret != 0;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool BeginBoxSelect(ImRect scopeRect, ref ImGuiWindow window, uint boxSelectId, ImGuiMultiSelectFlags msFlags)
		{
			fixed (ImGuiWindow* pwindow = &window)
			{
				byte ret = BeginBoxSelectNative(scopeRect, (ImGuiWindow*)pwindow, boxSelectId, msFlags);
				return ret != 0;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void EndBoxSelectNative(ImRect scopeRect, ImGuiMultiSelectFlags msFlags)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<ImRect, ImGuiMultiSelectFlags, void>)funcTable[1257])(scopeRect, msFlags);
			#else
			((delegate* unmanaged[Cdecl]<ImRect, ImGuiMultiSelectFlags, void>)funcTable[1257])(scopeRect, msFlags);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void EndBoxSelect(ImRect scopeRect, ImGuiMultiSelectFlags msFlags)
		{
			EndBoxSelectNative(scopeRect, msFlags);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void MultiSelectItemHeaderNative(uint id, bool* pSelected, ImGuiButtonFlags* pButtonFlags)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, bool*, ImGuiButtonFlags*, void>)funcTable[1258])(id, pSelected, pButtonFlags);
			#else
			((delegate* unmanaged[Cdecl]<uint, nint, nint, void>)funcTable[1258])(id, (nint)pSelected, (nint)pButtonFlags);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void MultiSelectItemHeader(uint id, bool* pSelected, ImGuiButtonFlags* pButtonFlags)
		{
			MultiSelectItemHeaderNative(id, pSelected, pButtonFlags);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void MultiSelectItemHeader(uint id, ref bool pSelected, ImGuiButtonFlags* pButtonFlags)
		{
			fixed (bool* ppSelected = &pSelected)
			{
				MultiSelectItemHeaderNative(id, (bool*)ppSelected, pButtonFlags);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void MultiSelectItemFooterNative(uint id, bool* pSelected, bool* pPressed)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, bool*, bool*, void>)funcTable[1259])(id, pSelected, pPressed);
			#else
			((delegate* unmanaged[Cdecl]<uint, nint, nint, void>)funcTable[1259])(id, (nint)pSelected, (nint)pPressed);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void MultiSelectItemFooter(uint id, bool* pSelected, bool* pPressed)
		{
			MultiSelectItemFooterNative(id, pSelected, pPressed);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void MultiSelectItemFooter(uint id, ref bool pSelected, bool* pPressed)
		{
			fixed (bool* ppSelected = &pSelected)
			{
				MultiSelectItemFooterNative(id, (bool*)ppSelected, pPressed);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void MultiSelectItemFooter(uint id, bool* pSelected, ref bool pPressed)
		{
			fixed (bool* ppPressed = &pPressed)
			{
				MultiSelectItemFooterNative(id, pSelected, (bool*)ppPressed);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void MultiSelectItemFooter(uint id, ref bool pSelected, ref bool pPressed)
		{
			fixed (bool* ppSelected = &pSelected)
			{
				fixed (bool* ppPressed = &pPressed)
				{
					MultiSelectItemFooterNative(id, (bool*)ppSelected, (bool*)ppPressed);
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void MultiSelectAddSetAllNative(ImGuiMultiSelectTempData* ms, byte selected)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<ImGuiMultiSelectTempData*, byte, void>)funcTable[1260])(ms, selected);
			#else
			((delegate* unmanaged[Cdecl]<nint, byte, void>)funcTable[1260])((nint)ms, selected);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void MultiSelectAddSetAll(ImGuiMultiSelectTempDataPtr ms, bool selected)
		{
			MultiSelectAddSetAllNative(ms, selected ? (byte)1 : (byte)0);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void MultiSelectAddSetAll(ref ImGuiMultiSelectTempData ms, bool selected)
		{
			fixed (ImGuiMultiSelectTempData* pms = &ms)
			{
				MultiSelectAddSetAllNative((ImGuiMultiSelectTempData*)pms, selected ? (byte)1 : (byte)0);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void MultiSelectAddSetRangeNative(ImGuiMultiSelectTempData* ms, byte selected, int rangeDir, long firstItem, long lastItem)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<ImGuiMultiSelectTempData*, byte, int, long, long, void>)funcTable[1261])(ms, selected, rangeDir, firstItem, lastItem);
			#else
			((delegate* unmanaged[Cdecl]<nint, byte, int, long, long, void>)funcTable[1261])((nint)ms, selected, rangeDir, firstItem, lastItem);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void MultiSelectAddSetRange(ImGuiMultiSelectTempDataPtr ms, bool selected, int rangeDir, long firstItem, long lastItem)
		{
			MultiSelectAddSetRangeNative(ms, selected ? (byte)1 : (byte)0, rangeDir, firstItem, lastItem);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void MultiSelectAddSetRange(ref ImGuiMultiSelectTempData ms, bool selected, int rangeDir, long firstItem, long lastItem)
		{
			fixed (ImGuiMultiSelectTempData* pms = &ms)
			{
				MultiSelectAddSetRangeNative((ImGuiMultiSelectTempData*)pms, selected ? (byte)1 : (byte)0, rangeDir, firstItem, lastItem);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static ImGuiBoxSelectState* GetBoxSelectStateNative(uint id)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<uint, ImGuiBoxSelectState*>)funcTable[1262])(id);
			#else
			return (ImGuiBoxSelectState*)((delegate* unmanaged[Cdecl]<uint, nint>)funcTable[1262])(id);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static ImGuiBoxSelectStatePtr GetBoxSelectState(uint id)
		{
			ImGuiBoxSelectStatePtr ret = GetBoxSelectStateNative(id);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static ImGuiMultiSelectState* GetMultiSelectStateNative(uint id)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<uint, ImGuiMultiSelectState*>)funcTable[1263])(id);
			#else
			return (ImGuiMultiSelectState*)((delegate* unmanaged[Cdecl]<uint, nint>)funcTable[1263])(id);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static ImGuiMultiSelectStatePtr GetMultiSelectState(uint id)
		{
			ImGuiMultiSelectStatePtr ret = GetMultiSelectStateNative(id);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void SetWindowClipRectBeforeSetChannelNative(ImGuiWindow* window, ImRect clipRect)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<ImGuiWindow*, ImRect, void>)funcTable[1264])(window, clipRect);
			#else
			((delegate* unmanaged[Cdecl]<nint, ImRect, void>)funcTable[1264])((nint)window, clipRect);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void SetWindowClipRectBeforeSetChannel(ImGuiWindowPtr window, ImRect clipRect)
		{
			SetWindowClipRectBeforeSetChannelNative(window, clipRect);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void SetWindowClipRectBeforeSetChannel(ref ImGuiWindow window, ImRect clipRect)
		{
			fixed (ImGuiWindow* pwindow = &window)
			{
				SetWindowClipRectBeforeSetChannelNative((ImGuiWindow*)pwindow, clipRect);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void BeginColumnsNative(byte* strId, int count, ImGuiOldColumnFlags flags)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<byte*, int, ImGuiOldColumnFlags, void>)funcTable[1265])(strId, count, flags);
			#else
			((delegate* unmanaged[Cdecl]<nint, int, ImGuiOldColumnFlags, void>)funcTable[1265])((nint)strId, count, flags);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void BeginColumns(byte* strId, int count, ImGuiOldColumnFlags flags)
		{
			BeginColumnsNative(strId, count, flags);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void BeginColumns(byte* strId, int count)
		{
			BeginColumnsNative(strId, count, (ImGuiOldColumnFlags)(0));
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void BeginColumns(ref byte strId, int count, ImGuiOldColumnFlags flags)
		{
			fixed (byte* pstrId = &strId)
			{
				BeginColumnsNative((byte*)pstrId, count, flags);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void BeginColumns(ref byte strId, int count)
		{
			fixed (byte* pstrId = &strId)
			{
				BeginColumnsNative((byte*)pstrId, count, (ImGuiOldColumnFlags)(0));
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void BeginColumns(ReadOnlySpan<byte> strId, int count, ImGuiOldColumnFlags flags)
		{
			fixed (byte* pstrId = strId)
			{
				BeginColumnsNative((byte*)pstrId, count, flags);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void BeginColumns(ReadOnlySpan<byte> strId, int count)
		{
			fixed (byte* pstrId = strId)
			{
				BeginColumnsNative((byte*)pstrId, count, (ImGuiOldColumnFlags)(0));
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void BeginColumns(string strId, int count, ImGuiOldColumnFlags flags)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (strId != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(strId);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(strId, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			BeginColumnsNative(pStr0, count, flags);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void BeginColumns(string strId, int count)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (strId != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(strId);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(strId, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			BeginColumnsNative(pStr0, count, (ImGuiOldColumnFlags)(0));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void EndColumnsNative()
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<void>)funcTable[1266])();
			#else
			((delegate* unmanaged[Cdecl]<void>)funcTable[1266])();
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void EndColumns()
		{
			EndColumnsNative();
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void PushColumnClipRectNative(int columnIndex)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<int, void>)funcTable[1267])(columnIndex);
			#else
			((delegate* unmanaged[Cdecl]<int, void>)funcTable[1267])(columnIndex);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void PushColumnClipRect(int columnIndex)
		{
			PushColumnClipRectNative(columnIndex);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void PushColumnsBackgroundNative()
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<void>)funcTable[1268])();
			#else
			((delegate* unmanaged[Cdecl]<void>)funcTable[1268])();
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void PushColumnsBackground()
		{
			PushColumnsBackgroundNative();
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void PopColumnsBackgroundNative()
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<void>)funcTable[1269])();
			#else
			((delegate* unmanaged[Cdecl]<void>)funcTable[1269])();
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void PopColumnsBackground()
		{
			PopColumnsBackgroundNative();
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static uint GetColumnsIDNative(byte* strId, int count)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<byte*, int, uint>)funcTable[1270])(strId, count);
			#else
			return (uint)((delegate* unmanaged[Cdecl]<nint, int, uint>)funcTable[1270])((nint)strId, count);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static uint GetColumnsID(byte* strId, int count)
		{
			uint ret = GetColumnsIDNative(strId, count);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static uint GetColumnsID(ref byte strId, int count)
		{
			fixed (byte* pstrId = &strId)
			{
				uint ret = GetColumnsIDNative((byte*)pstrId, count);
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static uint GetColumnsID(ReadOnlySpan<byte> strId, int count)
		{
			fixed (byte* pstrId = strId)
			{
				uint ret = GetColumnsIDNative((byte*)pstrId, count);
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static uint GetColumnsID(string strId, int count)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (strId != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(strId);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(strId, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			uint ret = GetColumnsIDNative(pStr0, count);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static ImGuiOldColumns* FindOrCreateColumnsNative(ImGuiWindow* window, uint id)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<ImGuiWindow*, uint, ImGuiOldColumns*>)funcTable[1271])(window, id);
			#else
			return (ImGuiOldColumns*)((delegate* unmanaged[Cdecl]<nint, uint, nint>)funcTable[1271])((nint)window, id);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static ImGuiOldColumnsPtr FindOrCreateColumns(ImGuiWindowPtr window, uint id)
		{
			ImGuiOldColumnsPtr ret = FindOrCreateColumnsNative(window, id);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static ImGuiOldColumnsPtr FindOrCreateColumns(ref ImGuiWindow window, uint id)
		{
			fixed (ImGuiWindow* pwindow = &window)
			{
				ImGuiOldColumnsPtr ret = FindOrCreateColumnsNative((ImGuiWindow*)pwindow, id);
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static float GetColumnOffsetFromNormNative(ImGuiOldColumns* columns, float offsetNorm)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<ImGuiOldColumns*, float, float>)funcTable[1272])(columns, offsetNorm);
			#else
			return (float)((delegate* unmanaged[Cdecl]<nint, float, float>)funcTable[1272])((nint)columns, offsetNorm);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static float GetColumnOffsetFromNorm(ImGuiOldColumnsPtr columns, float offsetNorm)
		{
			float ret = GetColumnOffsetFromNormNative(columns, offsetNorm);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static float GetColumnOffsetFromNorm(ref ImGuiOldColumns columns, float offsetNorm)
		{
			fixed (ImGuiOldColumns* pcolumns = &columns)
			{
				float ret = GetColumnOffsetFromNormNative((ImGuiOldColumns*)pcolumns, offsetNorm);
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static float GetColumnNormFromOffsetNative(ImGuiOldColumns* columns, float offset)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<ImGuiOldColumns*, float, float>)funcTable[1273])(columns, offset);
			#else
			return (float)((delegate* unmanaged[Cdecl]<nint, float, float>)funcTable[1273])((nint)columns, offset);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static float GetColumnNormFromOffset(ImGuiOldColumnsPtr columns, float offset)
		{
			float ret = GetColumnNormFromOffsetNative(columns, offset);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static float GetColumnNormFromOffset(ref ImGuiOldColumns columns, float offset)
		{
			fixed (ImGuiOldColumns* pcolumns = &columns)
			{
				float ret = GetColumnNormFromOffsetNative((ImGuiOldColumns*)pcolumns, offset);
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void TableOpenContextMenuNative(int columnN)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<int, void>)funcTable[1274])(columnN);
			#else
			((delegate* unmanaged[Cdecl]<int, void>)funcTable[1274])(columnN);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void TableOpenContextMenu(int columnN)
		{
			TableOpenContextMenuNative(columnN);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void TableOpenContextMenu()
		{
			TableOpenContextMenuNative((int)(-1));
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void TableSetColumnWidthNative(int columnN, float width)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<int, float, void>)funcTable[1275])(columnN, width);
			#else
			((delegate* unmanaged[Cdecl]<int, float, void>)funcTable[1275])(columnN, width);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void TableSetColumnWidth(int columnN, float width)
		{
			TableSetColumnWidthNative(columnN, width);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void TableSetColumnSortDirectionNative(int columnN, ImGuiSortDirection sortDirection, byte appendToSortSpecs)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<int, ImGuiSortDirection, byte, void>)funcTable[1276])(columnN, sortDirection, appendToSortSpecs);
			#else
			((delegate* unmanaged[Cdecl]<int, ImGuiSortDirection, byte, void>)funcTable[1276])(columnN, sortDirection, appendToSortSpecs);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void TableSetColumnSortDirection(int columnN, ImGuiSortDirection sortDirection, bool appendToSortSpecs)
		{
			TableSetColumnSortDirectionNative(columnN, sortDirection, appendToSortSpecs ? (byte)1 : (byte)0);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int TableGetHoveredRowNative()
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<int>)funcTable[1277])();
			#else
			return (int)((delegate* unmanaged[Cdecl]<int>)funcTable[1277])();
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static int TableGetHoveredRow()
		{
			int ret = TableGetHoveredRowNative();
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static float TableGetHeaderRowHeightNative()
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<float>)funcTable[1278])();
			#else
			return (float)((delegate* unmanaged[Cdecl]<float>)funcTable[1278])();
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static float TableGetHeaderRowHeight()
		{
			float ret = TableGetHeaderRowHeightNative();
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static float TableGetHeaderAngledMaxLabelWidthNative()
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<float>)funcTable[1279])();
			#else
			return (float)((delegate* unmanaged[Cdecl]<float>)funcTable[1279])();
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static float TableGetHeaderAngledMaxLabelWidth()
		{
			float ret = TableGetHeaderAngledMaxLabelWidthNative();
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void TablePushBackgroundChannelNative()
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<void>)funcTable[1280])();
			#else
			((delegate* unmanaged[Cdecl]<void>)funcTable[1280])();
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void TablePushBackgroundChannel()
		{
			TablePushBackgroundChannelNative();
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void TablePopBackgroundChannelNative()
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<void>)funcTable[1281])();
			#else
			((delegate* unmanaged[Cdecl]<void>)funcTable[1281])();
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void TablePopBackgroundChannel()
		{
			TablePopBackgroundChannelNative();
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void TablePushColumnChannelNative(int columnN)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<int, void>)funcTable[1282])(columnN);
			#else
			((delegate* unmanaged[Cdecl]<int, void>)funcTable[1282])(columnN);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void TablePushColumnChannel(int columnN)
		{
			TablePushColumnChannelNative(columnN);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void TablePopColumnChannelNative()
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<void>)funcTable[1283])();
			#else
			((delegate* unmanaged[Cdecl]<void>)funcTable[1283])();
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void TablePopColumnChannel()
		{
			TablePopColumnChannelNative();
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void TableAngledHeadersRowExNative(uint rowId, float angle, float maxLabelWidth, ImGuiTableHeaderData* data, int dataCount)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, float, float, ImGuiTableHeaderData*, int, void>)funcTable[1284])(rowId, angle, maxLabelWidth, data, dataCount);
			#else
			((delegate* unmanaged[Cdecl]<uint, float, float, nint, int, void>)funcTable[1284])(rowId, angle, maxLabelWidth, (nint)data, dataCount);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void TableAngledHeadersRowEx(uint rowId, float angle, float maxLabelWidth, ImGuiTableHeaderDataPtr data, int dataCount)
		{
			TableAngledHeadersRowExNative(rowId, angle, maxLabelWidth, data, dataCount);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void TableAngledHeadersRowEx(uint rowId, float angle, float maxLabelWidth, ref ImGuiTableHeaderData data, int dataCount)
		{
			fixed (ImGuiTableHeaderData* pdata = &data)
			{
				TableAngledHeadersRowExNative(rowId, angle, maxLabelWidth, (ImGuiTableHeaderData*)pdata, dataCount);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static ImGuiTable* GetCurrentTableNative()
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<ImGuiTable*>)funcTable[1285])();
			#else
			return (ImGuiTable*)((delegate* unmanaged[Cdecl]<nint>)funcTable[1285])();
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static ImGuiTablePtr GetCurrentTable()
		{
			ImGuiTablePtr ret = GetCurrentTableNative();
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static ImGuiTable* TableFindByIDNative(uint id)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<uint, ImGuiTable*>)funcTable[1286])(id);
			#else
			return (ImGuiTable*)((delegate* unmanaged[Cdecl]<uint, nint>)funcTable[1286])(id);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static ImGuiTablePtr TableFindByID(uint id)
		{
			ImGuiTablePtr ret = TableFindByIDNative(id);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte BeginTableExNative(byte* name, uint id, int columnsCount, ImGuiTableFlags flags, Vector2 outerSize, float innerWidth)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<byte*, uint, int, ImGuiTableFlags, Vector2, float, byte>)funcTable[1287])(name, id, columnsCount, flags, outerSize, innerWidth);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<nint, uint, int, ImGuiTableFlags, Vector2, float, byte>)funcTable[1287])((nint)name, id, columnsCount, flags, outerSize, innerWidth);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool BeginTableEx(byte* name, uint id, int columnsCount, ImGuiTableFlags flags, Vector2 outerSize, float innerWidth)
		{
			byte ret = BeginTableExNative(name, id, columnsCount, flags, outerSize, innerWidth);
			return ret != 0;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool BeginTableEx(byte* name, uint id, int columnsCount, ImGuiTableFlags flags, Vector2 outerSize)
		{
			byte ret = BeginTableExNative(name, id, columnsCount, flags, outerSize, (float)(0.0f));
			return ret != 0;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool BeginTableEx(byte* name, uint id, int columnsCount, ImGuiTableFlags flags)
		{
			byte ret = BeginTableExNative(name, id, columnsCount, flags, (Vector2)(new Vector2(0,0)), (float)(0.0f));
			return ret != 0;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool BeginTableEx(byte* name, uint id, int columnsCount)
		{
			byte ret = BeginTableExNative(name, id, columnsCount, (ImGuiTableFlags)(0), (Vector2)(new Vector2(0,0)), (float)(0.0f));
			return ret != 0;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool BeginTableEx(byte* name, uint id, int columnsCount, Vector2 outerSize)
		{
			byte ret = BeginTableExNative(name, id, columnsCount, (ImGuiTableFlags)(0), outerSize, (float)(0.0f));
			return ret != 0;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool BeginTableEx(byte* name, uint id, int columnsCount, ImGuiTableFlags flags, float innerWidth)
		{
			byte ret = BeginTableExNative(name, id, columnsCount, flags, (Vector2)(new Vector2(0,0)), innerWidth);
			return ret != 0;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool BeginTableEx(byte* name, uint id, int columnsCount, float innerWidth)
		{
			byte ret = BeginTableExNative(name, id, columnsCount, (ImGuiTableFlags)(0), (Vector2)(new Vector2(0,0)), innerWidth);
			return ret != 0;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool BeginTableEx(byte* name, uint id, int columnsCount, Vector2 outerSize, float innerWidth)
		{
			byte ret = BeginTableExNative(name, id, columnsCount, (ImGuiTableFlags)(0), outerSize, innerWidth);
			return ret != 0;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool BeginTableEx(ref byte name, uint id, int columnsCount, ImGuiTableFlags flags, Vector2 outerSize, float innerWidth)
		{
			fixed (byte* pname = &name)
			{
				byte ret = BeginTableExNative((byte*)pname, id, columnsCount, flags, outerSize, innerWidth);
				return ret != 0;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool BeginTableEx(ref byte name, uint id, int columnsCount, ImGuiTableFlags flags, Vector2 outerSize)
		{
			fixed (byte* pname = &name)
			{
				byte ret = BeginTableExNative((byte*)pname, id, columnsCount, flags, outerSize, (float)(0.0f));
				return ret != 0;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool BeginTableEx(ref byte name, uint id, int columnsCount, ImGuiTableFlags flags)
		{
			fixed (byte* pname = &name)
			{
				byte ret = BeginTableExNative((byte*)pname, id, columnsCount, flags, (Vector2)(new Vector2(0,0)), (float)(0.0f));
				return ret != 0;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool BeginTableEx(ref byte name, uint id, int columnsCount)
		{
			fixed (byte* pname = &name)
			{
				byte ret = BeginTableExNative((byte*)pname, id, columnsCount, (ImGuiTableFlags)(0), (Vector2)(new Vector2(0,0)), (float)(0.0f));
				return ret != 0;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool BeginTableEx(ref byte name, uint id, int columnsCount, Vector2 outerSize)
		{
			fixed (byte* pname = &name)
			{
				byte ret = BeginTableExNative((byte*)pname, id, columnsCount, (ImGuiTableFlags)(0), outerSize, (float)(0.0f));
				return ret != 0;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool BeginTableEx(ref byte name, uint id, int columnsCount, ImGuiTableFlags flags, float innerWidth)
		{
			fixed (byte* pname = &name)
			{
				byte ret = BeginTableExNative((byte*)pname, id, columnsCount, flags, (Vector2)(new Vector2(0,0)), innerWidth);
				return ret != 0;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool BeginTableEx(ref byte name, uint id, int columnsCount, float innerWidth)
		{
			fixed (byte* pname = &name)
			{
				byte ret = BeginTableExNative((byte*)pname, id, columnsCount, (ImGuiTableFlags)(0), (Vector2)(new Vector2(0,0)), innerWidth);
				return ret != 0;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool BeginTableEx(ref byte name, uint id, int columnsCount, Vector2 outerSize, float innerWidth)
		{
			fixed (byte* pname = &name)
			{
				byte ret = BeginTableExNative((byte*)pname, id, columnsCount, (ImGuiTableFlags)(0), outerSize, innerWidth);
				return ret != 0;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool BeginTableEx(ReadOnlySpan<byte> name, uint id, int columnsCount, ImGuiTableFlags flags, Vector2 outerSize, float innerWidth)
		{
			fixed (byte* pname = name)
			{
				byte ret = BeginTableExNative((byte*)pname, id, columnsCount, flags, outerSize, innerWidth);
				return ret != 0;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool BeginTableEx(ReadOnlySpan<byte> name, uint id, int columnsCount, ImGuiTableFlags flags, Vector2 outerSize)
		{
			fixed (byte* pname = name)
			{
				byte ret = BeginTableExNative((byte*)pname, id, columnsCount, flags, outerSize, (float)(0.0f));
				return ret != 0;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool BeginTableEx(ReadOnlySpan<byte> name, uint id, int columnsCount, ImGuiTableFlags flags)
		{
			fixed (byte* pname = name)
			{
				byte ret = BeginTableExNative((byte*)pname, id, columnsCount, flags, (Vector2)(new Vector2(0,0)), (float)(0.0f));
				return ret != 0;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool BeginTableEx(ReadOnlySpan<byte> name, uint id, int columnsCount)
		{
			fixed (byte* pname = name)
			{
				byte ret = BeginTableExNative((byte*)pname, id, columnsCount, (ImGuiTableFlags)(0), (Vector2)(new Vector2(0,0)), (float)(0.0f));
				return ret != 0;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool BeginTableEx(ReadOnlySpan<byte> name, uint id, int columnsCount, Vector2 outerSize)
		{
			fixed (byte* pname = name)
			{
				byte ret = BeginTableExNative((byte*)pname, id, columnsCount, (ImGuiTableFlags)(0), outerSize, (float)(0.0f));
				return ret != 0;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool BeginTableEx(ReadOnlySpan<byte> name, uint id, int columnsCount, ImGuiTableFlags flags, float innerWidth)
		{
			fixed (byte* pname = name)
			{
				byte ret = BeginTableExNative((byte*)pname, id, columnsCount, flags, (Vector2)(new Vector2(0,0)), innerWidth);
				return ret != 0;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool BeginTableEx(ReadOnlySpan<byte> name, uint id, int columnsCount, float innerWidth)
		{
			fixed (byte* pname = name)
			{
				byte ret = BeginTableExNative((byte*)pname, id, columnsCount, (ImGuiTableFlags)(0), (Vector2)(new Vector2(0,0)), innerWidth);
				return ret != 0;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool BeginTableEx(ReadOnlySpan<byte> name, uint id, int columnsCount, Vector2 outerSize, float innerWidth)
		{
			fixed (byte* pname = name)
			{
				byte ret = BeginTableExNative((byte*)pname, id, columnsCount, (ImGuiTableFlags)(0), outerSize, innerWidth);
				return ret != 0;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool BeginTableEx(string name, uint id, int columnsCount, ImGuiTableFlags flags, Vector2 outerSize, float innerWidth)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (name != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(name);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(name, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = BeginTableExNative(pStr0, id, columnsCount, flags, outerSize, innerWidth);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool BeginTableEx(string name, uint id, int columnsCount, ImGuiTableFlags flags, Vector2 outerSize)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (name != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(name);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(name, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = BeginTableExNative(pStr0, id, columnsCount, flags, outerSize, (float)(0.0f));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool BeginTableEx(string name, uint id, int columnsCount, ImGuiTableFlags flags)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (name != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(name);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(name, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = BeginTableExNative(pStr0, id, columnsCount, flags, (Vector2)(new Vector2(0,0)), (float)(0.0f));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool BeginTableEx(string name, uint id, int columnsCount)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (name != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(name);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(name, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = BeginTableExNative(pStr0, id, columnsCount, (ImGuiTableFlags)(0), (Vector2)(new Vector2(0,0)), (float)(0.0f));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool BeginTableEx(string name, uint id, int columnsCount, Vector2 outerSize)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (name != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(name);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(name, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = BeginTableExNative(pStr0, id, columnsCount, (ImGuiTableFlags)(0), outerSize, (float)(0.0f));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool BeginTableEx(string name, uint id, int columnsCount, ImGuiTableFlags flags, float innerWidth)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (name != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(name);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(name, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = BeginTableExNative(pStr0, id, columnsCount, flags, (Vector2)(new Vector2(0,0)), innerWidth);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool BeginTableEx(string name, uint id, int columnsCount, float innerWidth)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (name != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(name);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(name, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = BeginTableExNative(pStr0, id, columnsCount, (ImGuiTableFlags)(0), (Vector2)(new Vector2(0,0)), innerWidth);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool BeginTableEx(string name, uint id, int columnsCount, Vector2 outerSize, float innerWidth)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (name != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(name);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(name, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = BeginTableExNative(pStr0, id, columnsCount, (ImGuiTableFlags)(0), outerSize, innerWidth);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void TableBeginInitMemoryNative(ImGuiTable* table, int columnsCount)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<ImGuiTable*, int, void>)funcTable[1288])(table, columnsCount);
			#else
			((delegate* unmanaged[Cdecl]<nint, int, void>)funcTable[1288])((nint)table, columnsCount);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void TableBeginInitMemory(ImGuiTablePtr table, int columnsCount)
		{
			TableBeginInitMemoryNative(table, columnsCount);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void TableBeginInitMemory(ref ImGuiTable table, int columnsCount)
		{
			fixed (ImGuiTable* ptable = &table)
			{
				TableBeginInitMemoryNative((ImGuiTable*)ptable, columnsCount);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void TableBeginApplyRequestsNative(ImGuiTable* table)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<ImGuiTable*, void>)funcTable[1289])(table);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)funcTable[1289])((nint)table);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void TableBeginApplyRequests(ImGuiTablePtr table)
		{
			TableBeginApplyRequestsNative(table);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void TableBeginApplyRequests(ref ImGuiTable table)
		{
			fixed (ImGuiTable* ptable = &table)
			{
				TableBeginApplyRequestsNative((ImGuiTable*)ptable);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void TableSetupDrawChannelsNative(ImGuiTable* table)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<ImGuiTable*, void>)funcTable[1290])(table);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)funcTable[1290])((nint)table);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void TableSetupDrawChannels(ImGuiTablePtr table)
		{
			TableSetupDrawChannelsNative(table);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void TableSetupDrawChannels(ref ImGuiTable table)
		{
			fixed (ImGuiTable* ptable = &table)
			{
				TableSetupDrawChannelsNative((ImGuiTable*)ptable);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void TableUpdateLayoutNative(ImGuiTable* table)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<ImGuiTable*, void>)funcTable[1291])(table);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)funcTable[1291])((nint)table);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void TableUpdateLayout(ImGuiTablePtr table)
		{
			TableUpdateLayoutNative(table);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void TableUpdateLayout(ref ImGuiTable table)
		{
			fixed (ImGuiTable* ptable = &table)
			{
				TableUpdateLayoutNative((ImGuiTable*)ptable);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void TableUpdateBordersNative(ImGuiTable* table)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<ImGuiTable*, void>)funcTable[1292])(table);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)funcTable[1292])((nint)table);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void TableUpdateBorders(ImGuiTablePtr table)
		{
			TableUpdateBordersNative(table);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void TableUpdateBorders(ref ImGuiTable table)
		{
			fixed (ImGuiTable* ptable = &table)
			{
				TableUpdateBordersNative((ImGuiTable*)ptable);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void TableUpdateColumnsWeightFromWidthNative(ImGuiTable* table)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<ImGuiTable*, void>)funcTable[1293])(table);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)funcTable[1293])((nint)table);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void TableUpdateColumnsWeightFromWidth(ImGuiTablePtr table)
		{
			TableUpdateColumnsWeightFromWidthNative(table);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void TableUpdateColumnsWeightFromWidth(ref ImGuiTable table)
		{
			fixed (ImGuiTable* ptable = &table)
			{
				TableUpdateColumnsWeightFromWidthNative((ImGuiTable*)ptable);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void TableDrawBordersNative(ImGuiTable* table)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<ImGuiTable*, void>)funcTable[1294])(table);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)funcTable[1294])((nint)table);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void TableDrawBorders(ImGuiTablePtr table)
		{
			TableDrawBordersNative(table);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void TableDrawBorders(ref ImGuiTable table)
		{
			fixed (ImGuiTable* ptable = &table)
			{
				TableDrawBordersNative((ImGuiTable*)ptable);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void TableDrawDefaultContextMenuNative(ImGuiTable* table, ImGuiTableFlags flagsForSectionToDisplay)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<ImGuiTable*, ImGuiTableFlags, void>)funcTable[1295])(table, flagsForSectionToDisplay);
			#else
			((delegate* unmanaged[Cdecl]<nint, ImGuiTableFlags, void>)funcTable[1295])((nint)table, flagsForSectionToDisplay);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void TableDrawDefaultContextMenu(ImGuiTablePtr table, ImGuiTableFlags flagsForSectionToDisplay)
		{
			TableDrawDefaultContextMenuNative(table, flagsForSectionToDisplay);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void TableDrawDefaultContextMenu(ref ImGuiTable table, ImGuiTableFlags flagsForSectionToDisplay)
		{
			fixed (ImGuiTable* ptable = &table)
			{
				TableDrawDefaultContextMenuNative((ImGuiTable*)ptable, flagsForSectionToDisplay);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte TableBeginContextMenuPopupNative(ImGuiTable* table)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<ImGuiTable*, byte>)funcTable[1296])(table);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<nint, byte>)funcTable[1296])((nint)table);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool TableBeginContextMenuPopup(ImGuiTablePtr table)
		{
			byte ret = TableBeginContextMenuPopupNative(table);
			return ret != 0;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool TableBeginContextMenuPopup(ref ImGuiTable table)
		{
			fixed (ImGuiTable* ptable = &table)
			{
				byte ret = TableBeginContextMenuPopupNative((ImGuiTable*)ptable);
				return ret != 0;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void TableMergeDrawChannelsNative(ImGuiTable* table)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<ImGuiTable*, void>)funcTable[1297])(table);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)funcTable[1297])((nint)table);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void TableMergeDrawChannels(ImGuiTablePtr table)
		{
			TableMergeDrawChannelsNative(table);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void TableMergeDrawChannels(ref ImGuiTable table)
		{
			fixed (ImGuiTable* ptable = &table)
			{
				TableMergeDrawChannelsNative((ImGuiTable*)ptable);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static ImGuiTableInstanceData* TableGetInstanceDataNative(ImGuiTable* table, int instanceNo)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<ImGuiTable*, int, ImGuiTableInstanceData*>)funcTable[1298])(table, instanceNo);
			#else
			return (ImGuiTableInstanceData*)((delegate* unmanaged[Cdecl]<nint, int, nint>)funcTable[1298])((nint)table, instanceNo);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static ImGuiTableInstanceDataPtr TableGetInstanceData(ImGuiTablePtr table, int instanceNo)
		{
			ImGuiTableInstanceDataPtr ret = TableGetInstanceDataNative(table, instanceNo);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static ImGuiTableInstanceDataPtr TableGetInstanceData(ref ImGuiTable table, int instanceNo)
		{
			fixed (ImGuiTable* ptable = &table)
			{
				ImGuiTableInstanceDataPtr ret = TableGetInstanceDataNative((ImGuiTable*)ptable, instanceNo);
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static uint TableGetInstanceIDNative(ImGuiTable* table, int instanceNo)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<ImGuiTable*, int, uint>)funcTable[1299])(table, instanceNo);
			#else
			return (uint)((delegate* unmanaged[Cdecl]<nint, int, uint>)funcTable[1299])((nint)table, instanceNo);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static uint TableGetInstanceID(ImGuiTablePtr table, int instanceNo)
		{
			uint ret = TableGetInstanceIDNative(table, instanceNo);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static uint TableGetInstanceID(ref ImGuiTable table, int instanceNo)
		{
			fixed (ImGuiTable* ptable = &table)
			{
				uint ret = TableGetInstanceIDNative((ImGuiTable*)ptable, instanceNo);
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void TableSortSpecsSanitizeNative(ImGuiTable* table)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<ImGuiTable*, void>)funcTable[1300])(table);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)funcTable[1300])((nint)table);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void TableSortSpecsSanitize(ImGuiTablePtr table)
		{
			TableSortSpecsSanitizeNative(table);
		}
	}
}
