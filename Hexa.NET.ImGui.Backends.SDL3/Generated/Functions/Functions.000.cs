// ------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
// ------------------------------------------------------------------------------

using System;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;
using HexaGen.Runtime;
using System.Numerics;
using Hexa.NET.ImGui;

namespace Hexa.NET.ImGui.Backends.SDL3
{
	public unsafe partial class ImGuiImplSDL3
	{
		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void SetCurrentContextNative(ImGuiContext* ctx)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<ImGuiContext*, void>)funcTable[0])(ctx);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)funcTable[0])((nint)ctx);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void SetCurrentContext(ImGuiContextPtr ctx)
		{
			SetCurrentContextNative((ImGuiContext*)ctx);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void SetCurrentContext(ref ImGuiContext ctx)
		{
			fixed (ImGuiContext* pctx = &ctx)
			{
				SetCurrentContextNative((ImGuiContext*)pctx);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static ImGuiContext* GetCurrentContextNative()
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<ImGuiContext*>)funcTable[1])();
			#else
			return (ImGuiContext*)((delegate* unmanaged[Cdecl]<nint>)funcTable[1])();
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static ImGuiContextPtr GetCurrentContext()
		{
			ImGuiContextPtr ret = GetCurrentContextNative();
			return ret;
		}

		/// <summary>
		/// Follow "Getting Started" link and check examples/ folder to learn about using backends!<br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte InitForOpenGLNative(SDLWindow* window, void* sdlGlContext)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLWindow*, void*, byte>)funcTable[2])(window, sdlGlContext);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<nint, nint, byte>)funcTable[2])((nint)window, (nint)sdlGlContext);
			#endif
		}

		/// <summary>
		/// Follow "Getting Started" link and check examples/ folder to learn about using backends!<br/>
		/// </summary>
		public static bool InitForOpenGL(SDLWindowPtr window, void* sdlGlContext)
		{
			byte ret = InitForOpenGLNative((SDLWindow*)window, sdlGlContext);
			return ret != 0;
		}

		/// <summary>
		/// Follow "Getting Started" link and check examples/ folder to learn about using backends!<br/>
		/// </summary>
		public static bool InitForOpenGL(ref SDLWindow window, void* sdlGlContext)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				byte ret = InitForOpenGLNative((SDLWindow*)pwindow, sdlGlContext);
				return ret != 0;
			}
		}

		/// <summary>
		/// Follow "Getting Started" link and check examples/ folder to learn about using backends!<br/>
		/// </summary>
		public static bool InitForOpenGL(SDLWindowPtr window, nint sdlGlContext)
		{
			byte ret = InitForOpenGLNative((SDLWindow*)window, (void*)sdlGlContext);
			return ret != 0;
		}

		/// <summary>
		/// Follow "Getting Started" link and check examples/ folder to learn about using backends!<br/>
		/// </summary>
		public static bool InitForOpenGL(ref SDLWindow window, nint sdlGlContext)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				byte ret = InitForOpenGLNative((SDLWindow*)pwindow, (void*)sdlGlContext);
				return ret != 0;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte InitForVulkanNative(SDLWindow* window)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLWindow*, byte>)funcTable[3])(window);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<nint, byte>)funcTable[3])((nint)window);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool InitForVulkan(SDLWindowPtr window)
		{
			byte ret = InitForVulkanNative((SDLWindow*)window);
			return ret != 0;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool InitForVulkan(ref SDLWindow window)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				byte ret = InitForVulkanNative((SDLWindow*)pwindow);
				return ret != 0;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte InitForD3DNative(SDLWindow* window)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLWindow*, byte>)funcTable[4])(window);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<nint, byte>)funcTable[4])((nint)window);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool InitForD3D(SDLWindowPtr window)
		{
			byte ret = InitForD3DNative((SDLWindow*)window);
			return ret != 0;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool InitForD3D(ref SDLWindow window)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				byte ret = InitForD3DNative((SDLWindow*)pwindow);
				return ret != 0;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte InitForMetalNative(SDLWindow* window)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLWindow*, byte>)funcTable[5])(window);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<nint, byte>)funcTable[5])((nint)window);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool InitForMetal(SDLWindowPtr window)
		{
			byte ret = InitForMetalNative((SDLWindow*)window);
			return ret != 0;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool InitForMetal(ref SDLWindow window)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				byte ret = InitForMetalNative((SDLWindow*)pwindow);
				return ret != 0;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte InitForSDLRendererNative(SDLWindow* window, SDLRenderer* renderer)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLWindow*, SDLRenderer*, byte>)funcTable[6])(window, renderer);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<nint, nint, byte>)funcTable[6])((nint)window, (nint)renderer);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool InitForSDLRenderer(SDLWindowPtr window, SDLRendererPtr renderer)
		{
			byte ret = InitForSDLRendererNative((SDLWindow*)window, (SDLRenderer*)renderer);
			return ret != 0;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool InitForSDLRenderer(ref SDLWindow window, SDLRendererPtr renderer)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				byte ret = InitForSDLRendererNative((SDLWindow*)pwindow, (SDLRenderer*)renderer);
				return ret != 0;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool InitForSDLRenderer(SDLWindowPtr window, ref SDLRenderer renderer)
		{
			fixed (SDLRenderer* prenderer = &renderer)
			{
				byte ret = InitForSDLRendererNative((SDLWindow*)window, (SDLRenderer*)prenderer);
				return ret != 0;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool InitForSDLRenderer(ref SDLWindow window, ref SDLRenderer renderer)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				fixed (SDLRenderer* prenderer = &renderer)
				{
					byte ret = InitForSDLRendererNative((SDLWindow*)pwindow, (SDLRenderer*)prenderer);
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte InitForSDLGPUNative(SDLWindow* window)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLWindow*, byte>)funcTable[7])(window);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<nint, byte>)funcTable[7])((nint)window);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool InitForSDLGPU(SDLWindowPtr window)
		{
			byte ret = InitForSDLGPUNative((SDLWindow*)window);
			return ret != 0;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool InitForSDLGPU(ref SDLWindow window)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				byte ret = InitForSDLGPUNative((SDLWindow*)pwindow);
				return ret != 0;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte InitForOtherNative(SDLWindow* window)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLWindow*, byte>)funcTable[8])(window);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<nint, byte>)funcTable[8])((nint)window);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool InitForOther(SDLWindowPtr window)
		{
			byte ret = InitForOtherNative((SDLWindow*)window);
			return ret != 0;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool InitForOther(ref SDLWindow window)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				byte ret = InitForOtherNative((SDLWindow*)pwindow);
				return ret != 0;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void ShutdownNative()
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<void>)funcTable[9])();
			#else
			((delegate* unmanaged[Cdecl]<void>)funcTable[9])();
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void Shutdown()
		{
			ShutdownNative();
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void NewFrameNative()
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<void>)funcTable[10])();
			#else
			((delegate* unmanaged[Cdecl]<void>)funcTable[10])();
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void NewFrame()
		{
			NewFrameNative();
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte ProcessEventNative(SDLEvent* evnt)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLEvent*, byte>)funcTable[11])(evnt);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<nint, byte>)funcTable[11])((nint)evnt);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool ProcessEvent(SDLEventPtr evnt)
		{
			byte ret = ProcessEventNative((SDLEvent*)evnt);
			return ret != 0;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool ProcessEvent(in SDLEvent evnt)
		{
			fixed (SDLEvent* pevnt = &evnt)
			{
				byte ret = ProcessEventNative((SDLEvent*)pevnt);
				return ret != 0;
			}
		}

		/// <summary>
		/// Gamepad selection automatically starts in AutoFirst mode, picking first available SDL_Gamepad. You may override this.<br/>
		/// When using manual mode, caller is responsible for opening/closing gamepad.<br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void SetGamepadModeNative(ImGuiImplSDL3GamepadMode mode, SDLGamepad** manualGamepadsArray, int manualGamepadsCount)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<ImGuiImplSDL3GamepadMode, SDLGamepad**, int, void>)funcTable[12])(mode, manualGamepadsArray, manualGamepadsCount);
			#else
			((delegate* unmanaged[Cdecl]<ImGuiImplSDL3GamepadMode, nint, int, void>)funcTable[12])(mode, (nint)manualGamepadsArray, manualGamepadsCount);
			#endif
		}

		/// <summary>
		/// Gamepad selection automatically starts in AutoFirst mode, picking first available SDL_Gamepad. You may override this.<br/>
		/// When using manual mode, caller is responsible for opening/closing gamepad.<br/>
		/// </summary>
		public static void SetGamepadMode(ImGuiImplSDL3GamepadMode mode, SDLGamepadPtrPtr manualGamepadsArray, int manualGamepadsCount)
		{
			SetGamepadModeNative(mode, (SDLGamepad**)manualGamepadsArray, manualGamepadsCount);
		}

		/// <summary>
		/// Gamepad selection automatically starts in AutoFirst mode, picking first available SDL_Gamepad. You may override this.<br/>
		/// When using manual mode, caller is responsible for opening/closing gamepad.<br/>
		/// </summary>
		public static void SetGamepadMode(ImGuiImplSDL3GamepadMode mode, ref SDLGamepad* manualGamepadsArray, int manualGamepadsCount)
		{
			fixed (SDLGamepad** pmanualGamepadsArray = &manualGamepadsArray)
			{
				SetGamepadModeNative(mode, (SDLGamepad**)pmanualGamepadsArray, manualGamepadsCount);
			}
		}

		/// <summary>
		/// Follow "Getting Started" link and check examples/ folder to learn about using backends!<br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte SDLRenderer3InitNative(SDLRenderer* renderer)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLRenderer*, byte>)funcTable[13])(renderer);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<nint, byte>)funcTable[13])((nint)renderer);
			#endif
		}

		/// <summary>
		/// Follow "Getting Started" link and check examples/ folder to learn about using backends!<br/>
		/// </summary>
		public static bool SDLRenderer3Init(SDLRendererPtr renderer)
		{
			byte ret = SDLRenderer3InitNative((SDLRenderer*)renderer);
			return ret != 0;
		}

		/// <summary>
		/// Follow "Getting Started" link and check examples/ folder to learn about using backends!<br/>
		/// </summary>
		public static bool SDLRenderer3Init(ref SDLRenderer renderer)
		{
			fixed (SDLRenderer* prenderer = &renderer)
			{
				byte ret = SDLRenderer3InitNative((SDLRenderer*)prenderer);
				return ret != 0;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void SDLRenderer3ShutdownNative()
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<void>)funcTable[14])();
			#else
			((delegate* unmanaged[Cdecl]<void>)funcTable[14])();
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void SDLRenderer3Shutdown()
		{
			SDLRenderer3ShutdownNative();
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void SDLRenderer3NewFrameNative()
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<void>)funcTable[15])();
			#else
			((delegate* unmanaged[Cdecl]<void>)funcTable[15])();
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void SDLRenderer3NewFrame()
		{
			SDLRenderer3NewFrameNative();
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void SDLRenderer3RenderDrawDataNative(ImDrawData* drawData, SDLRenderer* renderer)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<ImDrawData*, SDLRenderer*, void>)funcTable[16])(drawData, renderer);
			#else
			((delegate* unmanaged[Cdecl]<nint, nint, void>)funcTable[16])((nint)drawData, (nint)renderer);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void SDLRenderer3RenderDrawData(ImDrawDataPtr drawData, SDLRendererPtr renderer)
		{
			SDLRenderer3RenderDrawDataNative((ImDrawData*)drawData, (SDLRenderer*)renderer);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void SDLRenderer3RenderDrawData(ref ImDrawData drawData, SDLRendererPtr renderer)
		{
			fixed (ImDrawData* pdrawData = &drawData)
			{
				SDLRenderer3RenderDrawDataNative((ImDrawData*)pdrawData, (SDLRenderer*)renderer);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void SDLRenderer3RenderDrawData(ImDrawDataPtr drawData, ref SDLRenderer renderer)
		{
			fixed (SDLRenderer* prenderer = &renderer)
			{
				SDLRenderer3RenderDrawDataNative((ImDrawData*)drawData, (SDLRenderer*)prenderer);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void SDLRenderer3RenderDrawData(ref ImDrawData drawData, ref SDLRenderer renderer)
		{
			fixed (ImDrawData* pdrawData = &drawData)
			{
				fixed (SDLRenderer* prenderer = &renderer)
				{
					SDLRenderer3RenderDrawDataNative((ImDrawData*)pdrawData, (SDLRenderer*)prenderer);
				}
			}
		}

		/// <summary>
		/// Called by Init/NewFrame/Shutdown<br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void SDLRenderer3CreateDeviceObjectsNative()
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<void>)funcTable[17])();
			#else
			((delegate* unmanaged[Cdecl]<void>)funcTable[17])();
			#endif
		}

		/// <summary>
		/// Called by Init/NewFrame/Shutdown<br/>
		/// </summary>
		public static void SDLRenderer3CreateDeviceObjects()
		{
			SDLRenderer3CreateDeviceObjectsNative();
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void SDLRenderer3DestroyDeviceObjectsNative()
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<void>)funcTable[18])();
			#else
			((delegate* unmanaged[Cdecl]<void>)funcTable[18])();
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void SDLRenderer3DestroyDeviceObjects()
		{
			SDLRenderer3DestroyDeviceObjectsNative();
		}

		/// <summary>
		/// (Advanced) Use e.g. if you need to precisely control the timing of texture updates (e.g. for staged rendering), by setting ImDrawData::Textures = NULL to handle this manually.<br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void SDLRenderer3UpdateTextureNative(ImTextureData* tex)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<ImTextureData*, void>)funcTable[19])(tex);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)funcTable[19])((nint)tex);
			#endif
		}

		/// <summary>
		/// (Advanced) Use e.g. if you need to precisely control the timing of texture updates (e.g. for staged rendering), by setting ImDrawData::Textures = NULL to handle this manually.<br/>
		/// </summary>
		public static void SDLRenderer3UpdateTexture(ImTextureDataPtr tex)
		{
			SDLRenderer3UpdateTextureNative((ImTextureData*)tex);
		}

		/// <summary>
		/// (Advanced) Use e.g. if you need to precisely control the timing of texture updates (e.g. for staged rendering), by setting ImDrawData::Textures = NULL to handle this manually.<br/>
		/// </summary>
		public static void SDLRenderer3UpdateTexture(ref ImTextureData tex)
		{
			fixed (ImTextureData* ptex = &tex)
			{
				SDLRenderer3UpdateTextureNative((ImTextureData*)ptex);
			}
		}

		/// <summary>
		/// Initialization data, for ImGui_ImplSDLGPU_Init()<br/>
		/// - Remember to set ColorTargetFormat to the correct format. If you're rendering to the swapchain, call SDL_GetGPUSwapchainTextureFormat to query the right value<br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte SDLGPU3InitNative(ImGuiImplSDLGPU3InitInfo* info)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<ImGuiImplSDLGPU3InitInfo*, byte>)funcTable[20])(info);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<nint, byte>)funcTable[20])((nint)info);
			#endif
		}

		/// <summary>
		/// Initialization data, for ImGui_ImplSDLGPU_Init()<br/>
		/// - Remember to set ColorTargetFormat to the correct format. If you're rendering to the swapchain, call SDL_GetGPUSwapchainTextureFormat to query the right value<br/>
		/// </summary>
		public static bool SDLGPU3Init(ImGuiImplSDLGPU3InitInfoPtr info)
		{
			byte ret = SDLGPU3InitNative((ImGuiImplSDLGPU3InitInfo*)info);
			return ret != 0;
		}

		/// <summary>
		/// Initialization data, for ImGui_ImplSDLGPU_Init()<br/>
		/// - Remember to set ColorTargetFormat to the correct format. If you're rendering to the swapchain, call SDL_GetGPUSwapchainTextureFormat to query the right value<br/>
		/// </summary>
		public static bool SDLGPU3Init(ref ImGuiImplSDLGPU3InitInfo info)
		{
			fixed (ImGuiImplSDLGPU3InitInfo* pinfo = &info)
			{
				byte ret = SDLGPU3InitNative((ImGuiImplSDLGPU3InitInfo*)pinfo);
				return ret != 0;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void SDLGPU3ShutdownNative()
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<void>)funcTable[21])();
			#else
			((delegate* unmanaged[Cdecl]<void>)funcTable[21])();
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void SDLGPU3Shutdown()
		{
			SDLGPU3ShutdownNative();
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void SDLGPU3NewFrameNative()
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<void>)funcTable[22])();
			#else
			((delegate* unmanaged[Cdecl]<void>)funcTable[22])();
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void SDLGPU3NewFrame()
		{
			SDLGPU3NewFrameNative();
		}

		/// <summary>
		/// - Unlike other backends, the user must call the function ImGui_ImplSDLGPU_PrepareDrawData BEFORE issuing a SDL_GPURenderPass containing ImGui_ImplSDLGPU_RenderDrawData.<br/>
		/// Calling the function is MANDATORY, otherwise the ImGui will not upload neither the vertex nor the index buffer for the GPU. See imgui_impl_sdlgpu3.cpp for more info.<br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void SDLGPU3PrepareDrawDataNative(ImDrawData* drawData, SDLGPUCommandBuffer* commandBuffer)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<ImDrawData*, SDLGPUCommandBuffer*, void>)funcTable[23])(drawData, commandBuffer);
			#else
			((delegate* unmanaged[Cdecl]<nint, nint, void>)funcTable[23])((nint)drawData, (nint)commandBuffer);
			#endif
		}

		/// <summary>
		/// - Unlike other backends, the user must call the function ImGui_ImplSDLGPU_PrepareDrawData BEFORE issuing a SDL_GPURenderPass containing ImGui_ImplSDLGPU_RenderDrawData.<br/>
		/// Calling the function is MANDATORY, otherwise the ImGui will not upload neither the vertex nor the index buffer for the GPU. See imgui_impl_sdlgpu3.cpp for more info.<br/>
		/// </summary>
		public static void SDLGPU3PrepareDrawData(ImDrawDataPtr drawData, SDLGPUCommandBufferPtr commandBuffer)
		{
			SDLGPU3PrepareDrawDataNative((ImDrawData*)drawData, (SDLGPUCommandBuffer*)commandBuffer);
		}

		/// <summary>
		/// - Unlike other backends, the user must call the function ImGui_ImplSDLGPU_PrepareDrawData BEFORE issuing a SDL_GPURenderPass containing ImGui_ImplSDLGPU_RenderDrawData.<br/>
		/// Calling the function is MANDATORY, otherwise the ImGui will not upload neither the vertex nor the index buffer for the GPU. See imgui_impl_sdlgpu3.cpp for more info.<br/>
		/// </summary>
		public static void SDLGPU3PrepareDrawData(ref ImDrawData drawData, SDLGPUCommandBufferPtr commandBuffer)
		{
			fixed (ImDrawData* pdrawData = &drawData)
			{
				SDLGPU3PrepareDrawDataNative((ImDrawData*)pdrawData, (SDLGPUCommandBuffer*)commandBuffer);
			}
		}

		/// <summary>
		/// - Unlike other backends, the user must call the function ImGui_ImplSDLGPU_PrepareDrawData BEFORE issuing a SDL_GPURenderPass containing ImGui_ImplSDLGPU_RenderDrawData.<br/>
		/// Calling the function is MANDATORY, otherwise the ImGui will not upload neither the vertex nor the index buffer for the GPU. See imgui_impl_sdlgpu3.cpp for more info.<br/>
		/// </summary>
		public static void SDLGPU3PrepareDrawData(ImDrawDataPtr drawData, ref SDLGPUCommandBuffer commandBuffer)
		{
			fixed (SDLGPUCommandBuffer* pcommandBuffer = &commandBuffer)
			{
				SDLGPU3PrepareDrawDataNative((ImDrawData*)drawData, (SDLGPUCommandBuffer*)pcommandBuffer);
			}
		}

		/// <summary>
		/// - Unlike other backends, the user must call the function ImGui_ImplSDLGPU_PrepareDrawData BEFORE issuing a SDL_GPURenderPass containing ImGui_ImplSDLGPU_RenderDrawData.<br/>
		/// Calling the function is MANDATORY, otherwise the ImGui will not upload neither the vertex nor the index buffer for the GPU. See imgui_impl_sdlgpu3.cpp for more info.<br/>
		/// </summary>
		public static void SDLGPU3PrepareDrawData(ref ImDrawData drawData, ref SDLGPUCommandBuffer commandBuffer)
		{
			fixed (ImDrawData* pdrawData = &drawData)
			{
				fixed (SDLGPUCommandBuffer* pcommandBuffer = &commandBuffer)
				{
					SDLGPU3PrepareDrawDataNative((ImDrawData*)pdrawData, (SDLGPUCommandBuffer*)pcommandBuffer);
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void SDLGPU3RenderDrawDataNative(ImDrawData* drawData, SDLGPUCommandBuffer* commandBuffer, SDLGPURenderPass* renderPass, SDLGPUGraphicsPipeline* pipeline)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<ImDrawData*, SDLGPUCommandBuffer*, SDLGPURenderPass*, SDLGPUGraphicsPipeline*, void>)funcTable[24])(drawData, commandBuffer, renderPass, pipeline);
			#else
			((delegate* unmanaged[Cdecl]<nint, nint, nint, nint, void>)funcTable[24])((nint)drawData, (nint)commandBuffer, (nint)renderPass, (nint)pipeline);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void SDLGPU3RenderDrawData(ImDrawDataPtr drawData, SDLGPUCommandBufferPtr commandBuffer, SDLGPURenderPassPtr renderPass, SDLGPUGraphicsPipelinePtr pipeline)
		{
			SDLGPU3RenderDrawDataNative((ImDrawData*)drawData, (SDLGPUCommandBuffer*)commandBuffer, (SDLGPURenderPass*)renderPass, (SDLGPUGraphicsPipeline*)pipeline);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void SDLGPU3RenderDrawData(ref ImDrawData drawData, SDLGPUCommandBufferPtr commandBuffer, SDLGPURenderPassPtr renderPass, SDLGPUGraphicsPipelinePtr pipeline)
		{
			fixed (ImDrawData* pdrawData = &drawData)
			{
				SDLGPU3RenderDrawDataNative((ImDrawData*)pdrawData, (SDLGPUCommandBuffer*)commandBuffer, (SDLGPURenderPass*)renderPass, (SDLGPUGraphicsPipeline*)pipeline);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void SDLGPU3RenderDrawData(ImDrawDataPtr drawData, ref SDLGPUCommandBuffer commandBuffer, SDLGPURenderPassPtr renderPass, SDLGPUGraphicsPipelinePtr pipeline)
		{
			fixed (SDLGPUCommandBuffer* pcommandBuffer = &commandBuffer)
			{
				SDLGPU3RenderDrawDataNative((ImDrawData*)drawData, (SDLGPUCommandBuffer*)pcommandBuffer, (SDLGPURenderPass*)renderPass, (SDLGPUGraphicsPipeline*)pipeline);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void SDLGPU3RenderDrawData(ref ImDrawData drawData, ref SDLGPUCommandBuffer commandBuffer, SDLGPURenderPassPtr renderPass, SDLGPUGraphicsPipelinePtr pipeline)
		{
			fixed (ImDrawData* pdrawData = &drawData)
			{
				fixed (SDLGPUCommandBuffer* pcommandBuffer = &commandBuffer)
				{
					SDLGPU3RenderDrawDataNative((ImDrawData*)pdrawData, (SDLGPUCommandBuffer*)pcommandBuffer, (SDLGPURenderPass*)renderPass, (SDLGPUGraphicsPipeline*)pipeline);
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void SDLGPU3RenderDrawData(ImDrawDataPtr drawData, SDLGPUCommandBufferPtr commandBuffer, ref SDLGPURenderPass renderPass, SDLGPUGraphicsPipelinePtr pipeline)
		{
			fixed (SDLGPURenderPass* prenderPass = &renderPass)
			{
				SDLGPU3RenderDrawDataNative((ImDrawData*)drawData, (SDLGPUCommandBuffer*)commandBuffer, (SDLGPURenderPass*)prenderPass, (SDLGPUGraphicsPipeline*)pipeline);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void SDLGPU3RenderDrawData(ref ImDrawData drawData, SDLGPUCommandBufferPtr commandBuffer, ref SDLGPURenderPass renderPass, SDLGPUGraphicsPipelinePtr pipeline)
		{
			fixed (ImDrawData* pdrawData = &drawData)
			{
				fixed (SDLGPURenderPass* prenderPass = &renderPass)
				{
					SDLGPU3RenderDrawDataNative((ImDrawData*)pdrawData, (SDLGPUCommandBuffer*)commandBuffer, (SDLGPURenderPass*)prenderPass, (SDLGPUGraphicsPipeline*)pipeline);
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void SDLGPU3RenderDrawData(ImDrawDataPtr drawData, ref SDLGPUCommandBuffer commandBuffer, ref SDLGPURenderPass renderPass, SDLGPUGraphicsPipelinePtr pipeline)
		{
			fixed (SDLGPUCommandBuffer* pcommandBuffer = &commandBuffer)
			{
				fixed (SDLGPURenderPass* prenderPass = &renderPass)
				{
					SDLGPU3RenderDrawDataNative((ImDrawData*)drawData, (SDLGPUCommandBuffer*)pcommandBuffer, (SDLGPURenderPass*)prenderPass, (SDLGPUGraphicsPipeline*)pipeline);
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void SDLGPU3RenderDrawData(ref ImDrawData drawData, ref SDLGPUCommandBuffer commandBuffer, ref SDLGPURenderPass renderPass, SDLGPUGraphicsPipelinePtr pipeline)
		{
			fixed (ImDrawData* pdrawData = &drawData)
			{
				fixed (SDLGPUCommandBuffer* pcommandBuffer = &commandBuffer)
				{
					fixed (SDLGPURenderPass* prenderPass = &renderPass)
					{
						SDLGPU3RenderDrawDataNative((ImDrawData*)pdrawData, (SDLGPUCommandBuffer*)pcommandBuffer, (SDLGPURenderPass*)prenderPass, (SDLGPUGraphicsPipeline*)pipeline);
					}
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void SDLGPU3RenderDrawData(ImDrawDataPtr drawData, SDLGPUCommandBufferPtr commandBuffer, SDLGPURenderPassPtr renderPass, ref SDLGPUGraphicsPipeline pipeline)
		{
			fixed (SDLGPUGraphicsPipeline* ppipeline = &pipeline)
			{
				SDLGPU3RenderDrawDataNative((ImDrawData*)drawData, (SDLGPUCommandBuffer*)commandBuffer, (SDLGPURenderPass*)renderPass, (SDLGPUGraphicsPipeline*)ppipeline);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void SDLGPU3RenderDrawData(ref ImDrawData drawData, SDLGPUCommandBufferPtr commandBuffer, SDLGPURenderPassPtr renderPass, ref SDLGPUGraphicsPipeline pipeline)
		{
			fixed (ImDrawData* pdrawData = &drawData)
			{
				fixed (SDLGPUGraphicsPipeline* ppipeline = &pipeline)
				{
					SDLGPU3RenderDrawDataNative((ImDrawData*)pdrawData, (SDLGPUCommandBuffer*)commandBuffer, (SDLGPURenderPass*)renderPass, (SDLGPUGraphicsPipeline*)ppipeline);
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void SDLGPU3RenderDrawData(ImDrawDataPtr drawData, ref SDLGPUCommandBuffer commandBuffer, SDLGPURenderPassPtr renderPass, ref SDLGPUGraphicsPipeline pipeline)
		{
			fixed (SDLGPUCommandBuffer* pcommandBuffer = &commandBuffer)
			{
				fixed (SDLGPUGraphicsPipeline* ppipeline = &pipeline)
				{
					SDLGPU3RenderDrawDataNative((ImDrawData*)drawData, (SDLGPUCommandBuffer*)pcommandBuffer, (SDLGPURenderPass*)renderPass, (SDLGPUGraphicsPipeline*)ppipeline);
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void SDLGPU3RenderDrawData(ref ImDrawData drawData, ref SDLGPUCommandBuffer commandBuffer, SDLGPURenderPassPtr renderPass, ref SDLGPUGraphicsPipeline pipeline)
		{
			fixed (ImDrawData* pdrawData = &drawData)
			{
				fixed (SDLGPUCommandBuffer* pcommandBuffer = &commandBuffer)
				{
					fixed (SDLGPUGraphicsPipeline* ppipeline = &pipeline)
					{
						SDLGPU3RenderDrawDataNative((ImDrawData*)pdrawData, (SDLGPUCommandBuffer*)pcommandBuffer, (SDLGPURenderPass*)renderPass, (SDLGPUGraphicsPipeline*)ppipeline);
					}
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void SDLGPU3RenderDrawData(ImDrawDataPtr drawData, SDLGPUCommandBufferPtr commandBuffer, ref SDLGPURenderPass renderPass, ref SDLGPUGraphicsPipeline pipeline)
		{
			fixed (SDLGPURenderPass* prenderPass = &renderPass)
			{
				fixed (SDLGPUGraphicsPipeline* ppipeline = &pipeline)
				{
					SDLGPU3RenderDrawDataNative((ImDrawData*)drawData, (SDLGPUCommandBuffer*)commandBuffer, (SDLGPURenderPass*)prenderPass, (SDLGPUGraphicsPipeline*)ppipeline);
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void SDLGPU3RenderDrawData(ref ImDrawData drawData, SDLGPUCommandBufferPtr commandBuffer, ref SDLGPURenderPass renderPass, ref SDLGPUGraphicsPipeline pipeline)
		{
			fixed (ImDrawData* pdrawData = &drawData)
			{
				fixed (SDLGPURenderPass* prenderPass = &renderPass)
				{
					fixed (SDLGPUGraphicsPipeline* ppipeline = &pipeline)
					{
						SDLGPU3RenderDrawDataNative((ImDrawData*)pdrawData, (SDLGPUCommandBuffer*)commandBuffer, (SDLGPURenderPass*)prenderPass, (SDLGPUGraphicsPipeline*)ppipeline);
					}
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void SDLGPU3RenderDrawData(ImDrawDataPtr drawData, ref SDLGPUCommandBuffer commandBuffer, ref SDLGPURenderPass renderPass, ref SDLGPUGraphicsPipeline pipeline)
		{
			fixed (SDLGPUCommandBuffer* pcommandBuffer = &commandBuffer)
			{
				fixed (SDLGPURenderPass* prenderPass = &renderPass)
				{
					fixed (SDLGPUGraphicsPipeline* ppipeline = &pipeline)
					{
						SDLGPU3RenderDrawDataNative((ImDrawData*)drawData, (SDLGPUCommandBuffer*)pcommandBuffer, (SDLGPURenderPass*)prenderPass, (SDLGPUGraphicsPipeline*)ppipeline);
					}
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void SDLGPU3RenderDrawData(ref ImDrawData drawData, ref SDLGPUCommandBuffer commandBuffer, ref SDLGPURenderPass renderPass, ref SDLGPUGraphicsPipeline pipeline)
		{
			fixed (ImDrawData* pdrawData = &drawData)
			{
				fixed (SDLGPUCommandBuffer* pcommandBuffer = &commandBuffer)
				{
					fixed (SDLGPURenderPass* prenderPass = &renderPass)
					{
						fixed (SDLGPUGraphicsPipeline* ppipeline = &pipeline)
						{
							SDLGPU3RenderDrawDataNative((ImDrawData*)pdrawData, (SDLGPUCommandBuffer*)pcommandBuffer, (SDLGPURenderPass*)prenderPass, (SDLGPUGraphicsPipeline*)ppipeline);
						}
					}
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void SDLGPU3CreateDeviceObjectsNative()
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<void>)funcTable[25])();
			#else
			((delegate* unmanaged[Cdecl]<void>)funcTable[25])();
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void SDLGPU3CreateDeviceObjects()
		{
			SDLGPU3CreateDeviceObjectsNative();
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void SDLGPU3DestroyDeviceObjectsNative()
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<void>)funcTable[26])();
			#else
			((delegate* unmanaged[Cdecl]<void>)funcTable[26])();
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void SDLGPU3DestroyDeviceObjects()
		{
			SDLGPU3DestroyDeviceObjectsNative();
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void SDLGPU3GetSPIRVVertexShaderNative(void** ptr, nuint* size)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<void**, nuint*, void>)funcTable[27])(ptr, size);
			#else
			((delegate* unmanaged[Cdecl]<nint, nint, void>)funcTable[27])((nint)ptr, (nint)size);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void SDLGPU3GetSPIRVVertexShader(void** ptr, nuint* size)
		{
			SDLGPU3GetSPIRVVertexShaderNative(ptr, size);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void SDLGPU3GetSPIRVVertexShader(ref nint ptr, nuint* size)
		{
			fixed (nint* pptr = &ptr)
			{
				SDLGPU3GetSPIRVVertexShaderNative((void**)pptr, size);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void SDLGPU3GetSPIRVVertexShader(void** ptr, ref nuint size)
		{
			fixed (nuint* psize = &size)
			{
				SDLGPU3GetSPIRVVertexShaderNative(ptr, (nuint*)psize);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void SDLGPU3GetSPIRVVertexShader(ref nint ptr, ref nuint size)
		{
			fixed (nint* pptr = &ptr)
			{
				fixed (nuint* psize = &size)
				{
					SDLGPU3GetSPIRVVertexShaderNative((void**)pptr, (nuint*)psize);
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void SDLGPU3GetSPIRVFragmentShaderNative(void** ptr, nuint* size)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<void**, nuint*, void>)funcTable[28])(ptr, size);
			#else
			((delegate* unmanaged[Cdecl]<nint, nint, void>)funcTable[28])((nint)ptr, (nint)size);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void SDLGPU3GetSPIRVFragmentShader(void** ptr, nuint* size)
		{
			SDLGPU3GetSPIRVFragmentShaderNative(ptr, size);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void SDLGPU3GetSPIRVFragmentShader(ref nint ptr, nuint* size)
		{
			fixed (nint* pptr = &ptr)
			{
				SDLGPU3GetSPIRVFragmentShaderNative((void**)pptr, size);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void SDLGPU3GetSPIRVFragmentShader(void** ptr, ref nuint size)
		{
			fixed (nuint* psize = &size)
			{
				SDLGPU3GetSPIRVFragmentShaderNative(ptr, (nuint*)psize);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void SDLGPU3GetSPIRVFragmentShader(ref nint ptr, ref nuint size)
		{
			fixed (nint* pptr = &ptr)
			{
				fixed (nuint* psize = &size)
				{
					SDLGPU3GetSPIRVFragmentShaderNative((void**)pptr, (nuint*)psize);
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void SDLGPU3GetDXBCVertexShaderNative(void** ptr, nuint* size)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<void**, nuint*, void>)funcTable[29])(ptr, size);
			#else
			((delegate* unmanaged[Cdecl]<nint, nint, void>)funcTable[29])((nint)ptr, (nint)size);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void SDLGPU3GetDXBCVertexShader(void** ptr, nuint* size)
		{
			SDLGPU3GetDXBCVertexShaderNative(ptr, size);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void SDLGPU3GetDXBCVertexShader(ref nint ptr, nuint* size)
		{
			fixed (nint* pptr = &ptr)
			{
				SDLGPU3GetDXBCVertexShaderNative((void**)pptr, size);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void SDLGPU3GetDXBCVertexShader(void** ptr, ref nuint size)
		{
			fixed (nuint* psize = &size)
			{
				SDLGPU3GetDXBCVertexShaderNative(ptr, (nuint*)psize);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void SDLGPU3GetDXBCVertexShader(ref nint ptr, ref nuint size)
		{
			fixed (nint* pptr = &ptr)
			{
				fixed (nuint* psize = &size)
				{
					SDLGPU3GetDXBCVertexShaderNative((void**)pptr, (nuint*)psize);
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void SDLGPU3GetDXBCFragmentShaderNative(void** ptr, nuint* size)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<void**, nuint*, void>)funcTable[30])(ptr, size);
			#else
			((delegate* unmanaged[Cdecl]<nint, nint, void>)funcTable[30])((nint)ptr, (nint)size);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void SDLGPU3GetDXBCFragmentShader(void** ptr, nuint* size)
		{
			SDLGPU3GetDXBCFragmentShaderNative(ptr, size);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void SDLGPU3GetDXBCFragmentShader(ref nint ptr, nuint* size)
		{
			fixed (nint* pptr = &ptr)
			{
				SDLGPU3GetDXBCFragmentShaderNative((void**)pptr, size);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void SDLGPU3GetDXBCFragmentShader(void** ptr, ref nuint size)
		{
			fixed (nuint* psize = &size)
			{
				SDLGPU3GetDXBCFragmentShaderNative(ptr, (nuint*)psize);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void SDLGPU3GetDXBCFragmentShader(ref nint ptr, ref nuint size)
		{
			fixed (nint* pptr = &ptr)
			{
				fixed (nuint* psize = &size)
				{
					SDLGPU3GetDXBCFragmentShaderNative((void**)pptr, (nuint*)psize);
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void SDLGPU3GetMetallibVertexShaderNative(void** ptr, nuint* size)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<void**, nuint*, void>)funcTable[31])(ptr, size);
			#else
			((delegate* unmanaged[Cdecl]<nint, nint, void>)funcTable[31])((nint)ptr, (nint)size);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void SDLGPU3GetMetallibVertexShader(void** ptr, nuint* size)
		{
			SDLGPU3GetMetallibVertexShaderNative(ptr, size);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void SDLGPU3GetMetallibVertexShader(ref nint ptr, nuint* size)
		{
			fixed (nint* pptr = &ptr)
			{
				SDLGPU3GetMetallibVertexShaderNative((void**)pptr, size);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void SDLGPU3GetMetallibVertexShader(void** ptr, ref nuint size)
		{
			fixed (nuint* psize = &size)
			{
				SDLGPU3GetMetallibVertexShaderNative(ptr, (nuint*)psize);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void SDLGPU3GetMetallibVertexShader(ref nint ptr, ref nuint size)
		{
			fixed (nint* pptr = &ptr)
			{
				fixed (nuint* psize = &size)
				{
					SDLGPU3GetMetallibVertexShaderNative((void**)pptr, (nuint*)psize);
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void SDLGPU3GetMetallibFragmentShaderNative(void** ptr, nuint* size)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<void**, nuint*, void>)funcTable[32])(ptr, size);
			#else
			((delegate* unmanaged[Cdecl]<nint, nint, void>)funcTable[32])((nint)ptr, (nint)size);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void SDLGPU3GetMetallibFragmentShader(void** ptr, nuint* size)
		{
			SDLGPU3GetMetallibFragmentShaderNative(ptr, size);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void SDLGPU3GetMetallibFragmentShader(ref nint ptr, nuint* size)
		{
			fixed (nint* pptr = &ptr)
			{
				SDLGPU3GetMetallibFragmentShaderNative((void**)pptr, size);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void SDLGPU3GetMetallibFragmentShader(void** ptr, ref nuint size)
		{
			fixed (nuint* psize = &size)
			{
				SDLGPU3GetMetallibFragmentShaderNative(ptr, (nuint*)psize);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void SDLGPU3GetMetallibFragmentShader(ref nint ptr, ref nuint size)
		{
			fixed (nint* pptr = &ptr)
			{
				fixed (nuint* psize = &size)
				{
					SDLGPU3GetMetallibFragmentShaderNative((void**)pptr, (nuint*)psize);
				}
			}
		}

	}
}
